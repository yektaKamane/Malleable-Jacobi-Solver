
Building Charm++ shared library for Charmpy
===========================================

- Build Charm++ in non-SMP mode using '--build-shared --enable-charmpy'
  For example, on a regular Linux machine:
  ./build charm++ netlrts-linux-x86_64 -j8 --with-production --build-shared --enable-charmpy

  NOTE: We are currently requiring non-smp mode because in the most common Python implementation
  (CPython), multiple threads cannot run Python code concurrently due to the Global Interpreter Lock
  (GIL).

- cd lib

- gcc -shared -o libcharm.so -Wl,--whole-archive libck.a libconv-core.a libconv-util.a \
  libmemory-default.a libconv-machine.a libthreads-default.a libconv-partition.a libtmgr.a \
  libhwloc_embedded.a libldb-rand.a libconv-ldb.a libmoduleGreedyRefineLB.a -Wl,--no-whole-archive -lstdc++

  NOTE: For Clang (e.g. on macOS), replace '--whole-archive' and '--no-whole-archive' options with
        '-all_load' and '-noall_load' respectively.

- Optionally, add extra modules to the above command, e.g. libmoduleRefineLB.a
  but note that currently they also need to be manually registered/added in the code.

Developer documentation
=======================

Chares that are defined and that run outside of the C/C++ runtime (e.g. Python objects in a Charmpy
program) require lightweight objects acting as counterpart inside the C/C++ runtime.
These C++ objects are:

  ReadOnlyExt, MainchareExt, GroupExt and ArrayElemExt

and their function is mainly to relay received messages to their external counterpart.

To allow use of the C++ runtime from external clients (e.g. Charmpy), changes to the
following files have been made:

charm++.h
  Declaration of ReadOnlyExt, GroupExt, MainchareExt

charm.h
  Declaration of several functions intended to be called from external client. This
  includes:
    - register callbacks to external client functions
    - register external Charm entities (Readonlies, Mainchare, Group, Array)
    - object creation
    - send message functions
    - hooks to Charm functions

register.C
  define registration functions for external Charm entities

ck.C
  implements most of the new functions and methods

ckarray.h/C
  ArrayElemExt

init.C
  Changes to circumvent linking issues (see 'Improve/support external module linking'
  below for details)
  NOTE: These changes are only enabled if building Charm with charmpy support.

TODO
====

Build libcharm shared library with charmc
-----------------------------------------

The above method to generate libcharm may not work in specialized environments. For example, it does
not work on Cray XE because there are a large number of additional system dependencies that libcharm
has to know about. To avoid this, libcharm should be generated by charmc which knows all the required
flags to make a working executable (in this case library).

Improve/support external module linking
---------------------------------------

There are modules like tracing and load balancers that the Charm++ runtime expects
to be linked at the time the final executable is generated. This includes
definitions of the following functions (at the least empty definitions of them):

void CkRegisterMainModule();
void _registerExternalModules(char **argv);
void _createTraces(char **argv);

These are typically defined in a moduleInit.C or similar file created by charmc
during linking of final program executable.

Problem is that when accesing the Charm shared library from Charmpy, these functions
are never defined, so I have disabled calls to them in some cases, or bypassed with alternative
code with #if CMK_CHARMPY macro.

This means that I implemented an alternative way of registering the main
module, via a callback to external client (called from init.C).
And this also means that registering modules like load balancers has to be done
manually in the Charm code (e.g. in init.C).

This process should be improved.

A solution might be to define these functions in a Python c-extension module, and
maybe when accessing the shared library the functions are found, although this
method assumes that the external client will define them.

Or maybe modify charmc to allow building a shared library with the components that
the user wants predefined and linked in.
