mainmodule jacobi {

// interface for jacobi
//mainmodule Main {
    //
    mainchare Main {
        entry Main(CkArgMsg* m);
    };
//}

    readonly CProxy_Main main_proxy;
    readonly CProxy_Chunk chunks;
    readonly int num_finished;
    readonly double start_time;


// interface for chunk
//module Chunk {
    //
    array [1D] Chunk {
        entry Chunk(int t, int x, int y);
        entry [reductiontarget] void jacobi(){
            for (_sdag_jacobi_i = 0; _sdag_jacobi_i < ITER; ++_sdag_jacobi_i) {
                atomic {
                    sendStrips();
                }

                overlap {
                    when getStripFromLeft(Array<double> s) {
                        atomic {
                            processStripFromLeft(s);
                        }

                    }
                    when getStripFromRight(Array<double> s) {
                        atomic {
                            processStripFromRight(s);
                        }

                    }
                }
                atomic {
                    for (int j=0; j<WORK; ++j) doStencil();
                    //for (int j=0; j<WORK; ++j) doStencil_raw();
                }

            }
            atomic {
                if (CkMyPe() == 0) {
                    double elapsed = CmiWallTimer() - start_time;
                    CkPrintf("Finished in %fs %fs/step, %d iterations\n", elapsed, elapsed/_sdag_jacobi_i, _sdag_jacobi_i);
                    CkPrintf("Numfin=%d, total=%d, Pes = %d\n", _sdag_jacobi_i, total, CkNumPes());
                }
                CkExit();
            }
        };
        entry void getStripFromLeft(Array<double> s);
        entry void getStripFromRight(Array<double> s);
    };
//}
}
