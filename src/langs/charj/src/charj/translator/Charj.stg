group Charj;

charjSource_ci(pd, ids, tds, debug) ::= 
//<pd>
//<ids>
<<
<if(debug)>/* \<charjSource_ci> */<endif>
/*
 * packageDeclaration disabled...
<pd>
 * end packageDeclaration
 */

/*
 * importDeclarations disabled...
<ids>
 * end importDeclarations
 */

<tds>
<if(debug)>/* \</charjSource_ci> */<endif>

>>


charjSource_h(pd, ids, tds, debug) ::=
<<
<if(debug)>/* \<CHARJ_SOURCE> */<endif>
/**************************************************************************
 * WARNING                                                                *
 **************************************************************************
 * This is a machine generated header file.                               *
 * It is not meant to be edited by hand and may be overwritten by charjc. *
 **************************************************************************/

<pd>
<ids>
<tds>

<if(debug)>/* \</CHARJ_SOURCE> */<endif>

>>


charjSource_cc(pd, ids, tds, debug) ::=
<<
<if(debug)>/* \<CHARJ_SOURCE> */<endif>
<ids>
<pd>
<tds>
<if(debug)>/* \</CHARJ_SOURCE> */<endif>

>>

importDeclaration_cc_h(inc_id, use_id) ::= 
<<
<if(debug)>/* \<importDeclaration> */<endif>
#include \<<inc_id>\>
using <use_id>;
<if(debug)>/* \</importDeclaration> */<endif>
>>

classExtends_ci(type) ::= "<type>"


classExtends_cc_h(type) ::= "#include \<<type>.h\>"


interfaceExtends(ts) ::=
<<
: public <ts; separator=", public ">
>>

classDeclaration_h(sym, ident, ext, csds) ::=
<<
<sym.IncludeString>
<sym.NamespaceOpeningString>
<if(ext)>
class <ident> : public <ext> {
<else>
class <ident> {
<endif>

    <csds; separator="\n">
};
<sym.NamespaceClosingString>

>>

classDeclaration_cc(sym, ident, ext, csds) ::=
<<
<sym.IncludeString>
<sym.NamespaceOpeningString>
<if(ext)>
class <ident>: public <ext> {
<else>
class <ident> {
<endif>

    <csds; separator="\n">
};
<sym.NamespaceClosingString>

>>

chareDeclaration_cc(sym, ident, ext, csds) ::=
<<

#include "<ident>.decl.h"
<sym.NamespaceOpeningString>
<if(ext)>/* superclass: <ext> */<endif>
class <ident>: public CBase_<ident> {
    <csds; separator="\n">
};
<sym.NamespaceClosingString>
#include "<ident>.def.h"
>>

chareDeclaration_h(sym, ident, ext, csds) ::=
<<
#include "<ident>.decl.h"
<sym.NamespaceOpeningString>
<if(ext)>/* superclass: <ext> */<endif>
class <ident>: public CBase_<ident> {
    <csds; separator="\n">
};
<sym.NamespaceClosingString>
>>

chareDeclaration_ci(sym, chareType, arrayDim, ident, ext, csds) ::=
<<
<if(debug)>/* \<typeDeclaration> */<endif>
module <ident> {
<if(ext)>
    extern module <ext>;
<endif>
    <sym.NamespaceOpeningString>
    <chareType><if(arrayDim)> [<arrayDim>]<endif> <ident><if(ext)> : <ext><endif> {
        <csds; separator="\n">
    }
    <sym.NamespaceClosingString>
}

<if(debug)>/* \</typeDeclaration> */<endif>

>>


funcMethodDecl_h(modl, gtpl, ty, id, fpl, adl, block) ::=
<<
<if(modl)><modl>: <endif><ty> <gtpl> <id><fpl> <adl>;
>>


funcMethodDecl_ci(modl, gtpl, ty, id, fpl, adl, block) ::=
<<
entry <ty> <gtpl> <id><fpl> <adl>;
>>


funcMethodDecl_cc(modl, gtpl, ty, id, fpl, adl, block) ::=
<<
<if(modl)><modl>: <endif><ty> <gtpl> <id><fpl> <adl> {
    <block>
}
>>


voidMethodDecl_ci(modl, gtpl, id, fpl, block) ::=
<<
entry void<gtpl> <id><fpl>;
>>


voidMethodDecl_h(modl, gtpl, id, fpl, block) ::=
<<
<if(modl)><modl>: <endif>void<gtpl> <id><fpl>;
>>


voidMethodDecl_cc(modl, gtpl, id, fpl, block) ::=
<<
<if(modl)><modl>: <endif>void<gtpl> <id><fpl> {
    <block>
}
>>


ctorDecl_ci(modl, gtpl, id, fpl, block) ::=
<<
entry void<gtpl> <id><fpl>;
>>


ctorDecl_h(modl, gtpl, id, fpl, block) ::=
<<
<if(modl)><modl>:<endif><gtpl> <id><fpl>;
>>


ctorDecl_cc(modl, gtpl, id, fpl, block) ::=
<<
<if(modl)><modl>:<endif><gtpl> <id><fpl> {
    <block>
}
>>


block_cc(bsl) ::=
<<
<bsl:{s| <s><\n>}>
>>


embed_cc(str, blk) ::=
<<
// begin embedded block: <str>
<blk>
// end embedded block: <str>
>>


class_var_decl(modl, type, declList) ::=
<<
<if(modl)><modl>:<else>public:<endif> <type> <declList>;
>>


var_decl_list(var_decls) ::=
<<
<var_decls; separator=", ">
>>


var_decl(id, initializer) ::=
<<
<id><if(initializer)> = <initializer><endif>
>>


var_decl_id(id, array_decl_list) ::=
<<
<id><if(array_decl_list)> <array_decl_list><endif>
>>


var_id_decl(id, adl) ::=
<<
<id><if(adl)> <adl><endif>
>>


mod_list(mods) ::=
<<
<if(mods)><mods; separator=" "><endif>
>>


local_mod_list(mods) ::=
<<
<if(mods)><mods; separator=" "><endif>
>>
 

local_var_decl(modList, type, declList) ::=
<<
<if(modList)>
<modList> <type> <declList>;
<else>
<type> <declList>;
<endif>
>>


type(typeID, arrDeclList) ::=
<<
<typeID><arrDeclList>
>>


typeIdent(typeID, generics) ::=
<<
<typeID><generics>
>>


generic_arg_list(types) ::=
<<
\<<types>\>
>>


formal_param_list(sdecl, vdecl) ::=
<<
<if(vdecl)>
(<sdecl; separator=", ">, <vdecl>)
<else>
(<sdecl; separator=", ">)
<endif>
>>


formal_param_decl(modList, type, declID) ::=
<<
<if(modList)><modList> <endif><type> <declID>
>>


assert(cond, msg) ::=
<<
<if(msg)>
CkAssert(<cond> && <msg>);
<else>
CkAssert(<cond>);
<endif>
>>


if(cond, then, else_) ::=
<<
if <cond> {
    <then>
}<if(else_)> else {
    <else_>
}<endif>
>>


for(initializer, cond, update, body) ::=
<<
for (<if(initializer)><initializer><else>;<endif> <cond>; <update; separator=", ">) {
    <body>
}
>>

while(cond, body) ::=
<<
while <cond> {
    <body>
} 
>>

dowhile(cond, body) ::=
<<
do {
    <body>
} while <cond>;
>>


switch(expr, labels) ::=
<<
switch <expr> {
    <labels>
}
>>

return(val) ::=
<<
return<if(val)> <val><endif>;
>>

label(text, stmt) ::=
<<
<text>: <stmt>
>>

case(expr, block) ::=
<<
case <expr>: <block>
>>

method_call(primary, generic_types, args) ::=
<<
<if(generic_types)>
<primary>\<<generic_types>\>(<args>)
<else>
<primary>(<args>)
<endif>
>>


array_construction_with_init(array_decls, initializer) ::=
<<
<array_decls> = {<initializer>};
>>


array_construction(exprs, array_decls) ::=
<<
[<exprs; separator="][">]<array_decls>
>> 


arguments(exprs) ::=
<<
<exprs; separator=", ">
>>


