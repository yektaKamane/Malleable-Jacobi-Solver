group Charj;

charjSource_ci(pd, ids, tds) ::= 
//<pd>
//<ids>
<<
<tds>
>>


charjSource_cc(pd, ids, tds) ::= 
<<
<pd>
<ids>
<tds>
>>


classExtends_ci(type) ::= "<type>"


classExtends_cc(type) ::= ": public CBase_<type>"


interfaceExtends(ts) ::=
<<
: public <ts; separator=", public ">
>>


classDeclaration_ci(mod, ident, gen, ext, impl, ctls) ::=
<<
module <ident> {
    chare <ident> <gen>: <ext> {
        <ctls>
    }
}

>>


classDeclaration_h(mod, ident, gen, ext, impl, ctls) ::=
<<


class <ident> <gen>: public CBase_<ident> <impl> {
    <ctls>
};


>>

classDeclaration_cc(mod, ident, gen, ext, impl, ctls) ::=
<<


#include "<ident>.decl.h"
class <ident> <gen>: public CBase_<ident> <impl> {
    <ctls>
};
#include "<ident>.def.h"


>>


classTopLevelScope(classScopeDeclarations) ::= 
<<
// _classTopLevelScope_
<classScopeDeclarations; separator="\n">
// _!classTopLevelScope_
>>


funcMethodDecl_h(modl, 
            gtpl,
            ty,
            id,
            fpl,
            adl,
            tc,
            block) ::=
<<
<modl>: <ty> <gtpl> <id><fpl> <adl> <tc>;
>>


funcMethodDecl_cc(modl, 
            gtpl,
            ty,
            id,
            fpl,
            adl,
            tc,
            block) ::=
<<
<modl>: <ty> <gtpl> <id><fpl> <adl> <tc> <block>
>>


voidMethodDecl_ci(modl, gtpl, id, fpl, tc, block) ::=
<<
entry void<gtpl> <id><fpl> <tc>;
>>


voidMethodDecl_h(modl, gtpl, id, fpl, tc, block) ::=
<<
<modl>: void<gtpl> <id><fpl> <tc>;
>>


voidMethodDecl_cc(modl, gtpl, id, fpl, tc, block) ::=
<<
<modl>: void<gtpl> <id><fpl> <tc> <block>
>>


ctorDecl_ci(modl, gtpl, id, fpl, tc, block) ::=
<<
entry<gtpl> <id><fpl> <tc>;
>>


ctorDecl_h(modl, gtpl, id, fpl, tc, block) ::=
<<
<modl>:<gtpl> <id><fpl> <tc>;
>>


ctorDecl_cc(modl, gtpl, id, fpl, tc, block) ::=
<<
<modl>:<gtpl> <id><fpl> <tc> <block>
>>


