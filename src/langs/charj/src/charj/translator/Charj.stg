group Charj;

charjSource_ci(pd, ids, tds) ::= 
//<pd>
//<ids>
<<
<tds>
>>


charjSource_h(pd, ids, tds, cb) ::= 
<<
/**************************************************************************
 * WARNING                                                                *
 **************************************************************************
 * This is a machine generated header file.                               *
 * It is not meant to be edited by hand and may be overwritten by charjc. *
 **************************************************************************/

<pd>
<ids>
<tds>
<cb>

>>


charjSource_cc(pd, ids, tds, cb) ::= 
<<
<ids>
<pd>
<tds>
<cb>

>>

packageDeclaration_cc_h(ids) ::= 
<<
namespace <ids; separator=" { namespace "> {
>>

importDeclaration_cc_h(inc_id, use_id) ::= 
<<
#include \<<inc_id>\>
using <use_id>;
>>

classExtends_ci(type) ::= "<type>"


classExtends_cc_h(type) ::= "#include \<<type>.h\>"


interfaceExtends(ts) ::=
<<
: public <ts; separator=", public ">
>>


classDeclaration_ci(mod, ident, gen, ext, impl, ctls) ::=
<<
module <ident> {
<if(ext)>
    extern module <ext>;
    chare <ident> <gen>: <ext> {
<else>
    chare <ident> <gen> {
<endif>
        
        <ctls>
    }
}

>>


classDeclaration_h(mod, ident, gen, ext, impl, ctls) ::=
<<

#include "<ident>.decl.h"
<ext>
class <ident> <gen>: public CBase_<ident> <impl> {
    <ctls>
};


>>

classDeclaration_cc(mod, ident, gen, ext, impl, ctls) ::=
<<


#include "<ident>.decl.h"
<ext>
class <ident> <gen>: public CBase_<ident> <impl> {
    <ctls>
};
#include "<ident>.def.h"


>>


classTopLevelScope(classScopeDeclarations) ::= 
<<
<classScopeDeclarations; separator="\n">
>>


funcMethodDecl_h(modl, gtpl, ty, id, fpl, adl, tc, block) ::=
<<
<modl>: <ty> <gtpl> <id><fpl> <adl> <tc>;
>>


funcMethodDecl_ci(modl, gtpl, ty, id, fpl, adl, tc, block) ::=
<<
entry <ty> <gtpl> <id><fpl> <adl> <tc>;
>>


funcMethodDecl_cc(modl, gtpl, ty, id, fpl, adl, tc, block) ::=
<<
<modl>: <ty> <gtpl> <id><fpl> <adl> <tc> <block>
>>


voidMethodDecl_ci(modl, gtpl, id, fpl, tc, block) ::=
<<
entry void<gtpl> <id><fpl> <tc>;
>>


voidMethodDecl_h(modl, gtpl, id, fpl, tc, block) ::=
<<
<modl>: void<gtpl> <id><fpl> <tc>;
>>


voidMethodDecl_cc(modl, gtpl, id, fpl, tc, block) ::=
<<
<modl>: void<gtpl> <id><fpl> <tc> <block>
>>


ctorDecl_ci(modl, gtpl, id, fpl, tc, block) ::=
<<
entry void<gtpl> <id><fpl> <tc>;
>>


ctorDecl_h(modl, gtpl, id, fpl, tc, block) ::=
<<
<modl>:<gtpl> <id><fpl> <tc>;
>>


ctorDecl_cc(modl, gtpl, id, fpl, tc, block) ::=
<<
<modl>:<gtpl> <id><fpl> <tc> <block>
>>


block_cc(bsl) ::=
<<
{
    <bsl; separator="\n">
}
>>


embed_cc(str, blk) ::=
<<
// begin embedded block: <str>
<blk>
// end embedded block: <str>
>>


primitive_var_decl(modList, type, declList) ::=
<<
<if(modList)>
<modList>: <type> <declList>;
<else>
<type> <declList>;
<endif>
>>


object_var_decl(modList, type, declList) ::=
<<
<if(modList)>
<modList>: <type>* <declList>;
<else>
<type>* <declList>;
<endif>
>>


type(typeID, arrDeclList) ::=
<<
<typeID><arrDeclList>
>>

/*
object_type(typeID, arrDeclList) ::=
<<
<typeID>*<arrDeclList>
>>


chare_type(typeID, arrDeclList) ::=
<<
CProxy_<typeID><arrDeclList>
>>*/


formal_param_list(sdecl, vdecl) ::=
<<
<if(vdecl)>
(<sdecl; separator=", ">, <vdecl>)
<else>
(<sdecl; separator=", ">)
<endif>
>>


formal_param_decl(modList, type, declID) ::=
<<
    <modList> <type> <declID>
>>
