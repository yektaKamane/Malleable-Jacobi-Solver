group Charj;

charjSource_ci(pd, ids, tds, debug) ::= 
//<pd>
//<ids>
<<
<if(debug)>/* \<charjSource_ci> */<endif>
/*
 * packageDeclaration disabled...
<pd>
 * end packageDeclaration
 */

/*
 * importDeclarations disabled...
<ids>
 * end importDeclarations
 */

<tds>
<if(debug)>/* \</charjSource_ci> */<endif>

>>


charjSource_h(pd, ids, tds, cb, debug) ::= 
<<
<if(debug)>/* \<CHARJ_SOURCE> */<endif>
/**************************************************************************
 * WARNING                                                                *
 **************************************************************************
 * This is a machine generated header file.                               *
 * It is not meant to be edited by hand and may be overwritten by charjc. *
 **************************************************************************/

<pd>
<ids>
<tds>
<cb>

<if(debug)>/* \</CHARJ_SOURCE> */<endif>

>>


charjSource_cc(pd, ids, tds, cb, debug) ::= 
<<
<if(debug)>/* \<CHARJ_SOURCE> */<endif>
<ids>
<pd>
<tds>
<cb>
<if(debug)>/* \</CHARJ_SOURCE> */<endif>

>>

packageDeclaration_cc_h(ids) ::= 
<<
<if(debug)>/* \<packageDeclaration> */<endif>
namespace <ids; separator=" { namespace "> {
<if(debug)>/* \</packageDeclaration> */<endif>
>>

importDeclaration_cc_h(inc_id, use_id) ::= 
<<
<if(debug)>/* \<importDeclaration> */<endif>
#include \<<inc_id>\>
using <use_id>;
<if(debug)>/* \</importDeclaration> */<endif>
>>

classExtends_ci(type) ::= "<type>"


classExtends_cc_h(type) ::= "#include \<<type>.h\>"


interfaceExtends(ts) ::=
<<
: public <ts; separator=", public ">
>>


classDeclaration_ci(mod, ident, gen, ext, impl, ctls) ::=
<<
<if(debug)>/* \<typeDeclaration> */<endif>
module <ident> {
<if(ext)>
    extern module <ext>;
    chare <ident> <gen>: <ext> {
<else>
    chare <ident> <gen> {
<endif>
        
        <ctls>
    }
}
<if(debug)>/* \</typeDeclaration> */<endif>

>>


classDeclaration_h(mod, ident, gen, ext, impl, ctls) ::=
<<
<if(debug)>/* \<typeDeclaration> */<endif>

#include "<ident>.decl.h"
<ext>
class <ident> <gen>: public CBase_<ident> <impl> {
    <ctls>
};
<if(debug)>/* \</typeDeclaration> */<endif>


>>

classDeclaration_cc(mod, ident, gen, ext, impl, ctls) ::=
<<
<if(debug)>/* \<typeDeclaration> */<endif>


#include "<ident>.decl.h"
<ext>
class <ident> <gen>: public CBase_<ident> <impl> {
    <ctls>
};
#include "<ident>.def.h"
<if(debug)>/* \</typeDeclaration> */<endif>


>>


classTopLevelScope(classScopeDeclarations) ::= 
<<
<classScopeDeclarations; separator="\n">
>>


funcMethodDecl_h(modl, gtpl, ty, id, fpl, adl, tc, block) ::=
<<
<modl>: <ty> <gtpl> <id><fpl> <adl> <tc>;
>>


funcMethodDecl_ci(modl, gtpl, ty, id, fpl, adl, tc, block) ::=
<<
entry <ty> <gtpl> <id><fpl> <adl> <tc>;
>>


funcMethodDecl_cc(modl, gtpl, ty, id, fpl, adl, tc, block) ::=
<<
<modl>: <ty> <gtpl> <id><fpl> <adl> <tc> {
    <block>
}
>>


voidMethodDecl_ci(modl, gtpl, id, fpl, tc, block) ::=
<<
entry void<gtpl> <id><fpl> <tc>;
>>


voidMethodDecl_h(modl, gtpl, id, fpl, tc, block) ::=
<<
<modl>: void<gtpl> <id><fpl> <tc>;
>>


voidMethodDecl_cc(modl, gtpl, id, fpl, tc, block) ::=
<<
<modl>: void<gtpl> <id><fpl> <tc> {
    <block>
}
>>


ctorDecl_ci(modl, gtpl, id, fpl, tc, block) ::=
<<
entry void<gtpl> <id><fpl> <tc>;
>>


ctorDecl_h(modl, gtpl, id, fpl, tc, block) ::=
<<
<modl>:<gtpl> <id><fpl> <tc>;
>>


ctorDecl_cc(modl, gtpl, id, fpl, tc, block) ::=
<<
<modl>:<gtpl> <id><fpl> <tc> {
    <block>
}
>>


block_cc(bsl) ::=
<<
<bsl:{s| <s><\n>}>
>>


embed_cc(str, blk) ::=
<<
// begin embedded block: <str>
<blk>
// end embedded block: <str>
>>


var_decl_list(var_decls) ::=
<<
<var_decls; separator=", ">
>>


var_decl(id, initializer) ::=
<<
<id><if(initializer)> = <initializer><endif>
>>


var_decl_id(id, array_decl_list) ::=
<<
<id><if(array_decl_list)> <array_decl_list><endif>
>>


var_id_decl(id, adl) ::=
<<
<id><if(adl)> <adl><endif>
>>


mod_list(mods) ::=
<<
<if(mods)><mods; separator=" "><endif>
>>


local_mod_list(mods) ::=
<<
<if(mods)><mods; separator=" "><endif>
>>
 

primitive_var_decl(modList, type, declList) ::=
<<
<if(modList)>
<modList>: <type> <declList>;
<else>
<type> <declList>;
<endif>
>>


object_var_decl(modList, type, declList) ::=
<<
<if(modList)>
<modList>: <type> <declList>;
<else>
<type> <declList>;
<endif>
>>


type(typeID, arrDeclList) ::=
<<
<typeID><arrDeclList>
>>


typeIdent(typeID, generics) ::=
<<
<typeID><generics>
>>


generic_arg_list(types) ::=
<<
\<<types>\>
>>


formal_param_list(sdecl, vdecl) ::=
<<
<if(vdecl)>
(<sdecl; separator=", ">, <vdecl>)
<else>
(<sdecl; separator=", ">)
<endif>
>>


formal_param_decl(modList, type, declID) ::=
<<
<if(modList)><modList> <endif><type> <declID>
>>


assert(cond, msg) ::=
<<
<if(msg)>
CkAssert(<cond> && <msg>);
<else>
CkAssert(<cond>);
<endif>
>>


if(cond, then, else_) ::=
<<
if (<cond>) {
    <then>
}<if(else_)> else {
    <else_>
}<endif>
>>


// note: initializer carries its own semicolon
for(initializer, cond, update, body) ::=
<<
for (<initializer> <cond>; <update>) {
    <body>
}
>>

while(cond, body) ::=
<<
while (<cond>) {
    <body>
} 
>>

dowhile(cond, body) ::=
<<
do {
    <body>
} while (<cond>);
>>


switch(expr, labels) ::=
<<
switch (<expr>) {
    <labels>
}
>>

return(val) ::=
<<
return<if(val)> <val><endif>;
>>

label(text, stmt) ::=
<<
<text>: <stmt>
>>

case(expr, block) ::=
<<
case <expr>: <block>
>>

for_cond(expr) ::=
<<
<expr>
>>

for_update(exprs) ::=
<<
<exprs; separator=", ">
>>

method_call(primary, generic_types, args) ::=
<<
<if(generic_types)>
<primary>\<<generic_types>\>(<args>)
<else>
<primary>(<args>)
<endif>
>>


array_construction_with_init(array_decls, initializer) ::=
<<
<array_decls> = {<initializer>};
>>


array_construction(exprs, array_decls) ::=
<<
[<exprs; separator="][">]<array_decls>
>> 


arguments(exprs) ::=
<<
<exprs; separator=", ">
>>


