group Charj;

charjSource_ci(pd, ids, tds) ::= 
//<pd>
//<ids>
<<
<tds>
>>


charjSource_h(pd, ids, tds) ::= 
<<
/**************************************************************************
 * WARNING                                                                *
 **************************************************************************
 * This is a machine generated header file.                               *
 * It is not meant to be edited by hand and can be overwritten by charjc. *
 * Do not edit this file unless you know what you're doing.               *
 **************************************************************************/

<pd> {
<ids>
<tds>
}

>>


charjSource_cc(pd, ids, tds) ::= 
<<
<pd> {
<ids>
<tds>
}

>>

packageDeclaration_cc_h(id) ::= "namespace <id>"

importDeclaration_cc_h(inc_id, use_id) ::= 
<<
#include \<<inc_id>\>
using <use_id>;
>>

classExtends_ci(type) ::= "<type>"


classExtends_cc_h(type) ::= "#include \<<type>.h\>"


interfaceExtends(ts) ::=
<<
: public <ts; separator=", public ">
>>


classDeclaration_ci(mod, ident, gen, ext, impl, ctls) ::=
<<
module <ident> {
    extern module <ext>;
    chare <ident> <gen>: <ext> {
        <ctls>
    }
}

>>


classDeclaration_h(mod, ident, gen, ext, impl, ctls) ::=
<<

#include "<ident>.decl.h"
<ext>
class <ident> <gen>: public CBase_<ident> <impl> {
    <ctls>
};


>>

classDeclaration_cc(mod, ident, gen, ext, impl, ctls) ::=
<<


#include "<ident>.decl.h"
<ext>
class <ident> <gen>: public CBase_<ident> <impl> {
    <ctls>
};
#include "<ident>.def.h"


>>


classTopLevelScope(classScopeDeclarations) ::= 
<<
<classScopeDeclarations; separator="\n">
>>


funcMethodDecl_h(modl, gtpl, ty, id, fpl, adl, tc, block) ::=
<<
<modl>: <ty> <gtpl> <id><fpl> <adl> <tc>;
>>


funcMethodDecl_ci(modl, gtpl, ty, id, fpl, adl, tc, block) ::=
<<
entry <ty> <gtpl> <id><fpl> <adl> <tc>;
>>


funcMethodDecl_cc(modl, gtpl, ty, id, fpl, adl, tc, block) ::=
<<
<modl>: <ty> <gtpl> <id><fpl> <adl> <tc> <block>
>>


voidMethodDecl_ci(modl, gtpl, id, fpl, tc, block) ::=
<<
entry void<gtpl> <id><fpl> <tc>;
>>


voidMethodDecl_h(modl, gtpl, id, fpl, tc, block) ::=
<<
<modl>: void<gtpl> <id><fpl> <tc>;
>>


voidMethodDecl_cc(modl, gtpl, id, fpl, tc, block) ::=
<<
<modl>: void<gtpl> <id><fpl> <tc> <block>
>>


ctorDecl_ci(modl, gtpl, id, fpl, tc, block) ::=
<<
entry<gtpl> <id><fpl> <tc>;
>>


ctorDecl_h(modl, gtpl, id, fpl, tc, block) ::=
<<
<modl>:<gtpl> <id><fpl> <tc>;
>>


ctorDecl_cc(modl, gtpl, id, fpl, tc, block) ::=
<<
<modl>:<gtpl> <id><fpl> <tc> <block>
>>


block_cc(bsl) ::=
<<
{
    <bsl; separator="\n">
}
>>


embed_cc(str, blk) ::=
<<
// begin embedded block: <str>
<blk>
// end embedded block: <str>
>>
