group Charj;

charjSource_ci(pd, ids, tds, debug) ::= 
//<pd>
//<ids>
<<
<if(debug)>/* \<charjSource_ci> */<endif>
/*
 * packageDeclaration disabled...
<pd>
 * end packageDeclaration
 */

/*
 * importDeclarations disabled...
<ids>
 * end importDeclarations
 */

<tds>
<if(debug)>/* \</charjSource_ci> */<endif>

>>


charjSource_h(pd, ids, tds, cb, debug) ::= 
<<
<if(debug)>/* \<CHARJ_SOURCE> */<endif>
/**************************************************************************
 * WARNING                                                                *
 **************************************************************************
 * This is a machine generated header file.                               *
 * It is not meant to be edited by hand and may be overwritten by charjc. *
 **************************************************************************/

<pd>
<ids>
<tds>
<cb>

<if(debug)>/* \</CHARJ_SOURCE> */<endif>

>>


charjSource_cc(pd, ids, tds, cb, debug) ::= 
<<
<if(debug)>/* \<CHARJ_SOURCE> */<endif>
<ids>
<pd>
<tds>
<cb>
<if(debug)>/* \</CHARJ_SOURCE> */<endif>

>>

packageDeclaration_cc_h(ids) ::= 
<<
<if(debug)>/* \<packageDeclaration> */<endif>
namespace <ids; separator=" { namespace "> {
<if(debug)>/* \</packageDeclaration> */<endif>
>>

importDeclaration_cc_h(inc_id, use_id) ::= 
<<
<if(debug)>/* \<importDeclaration> */<endif>
#include \<<inc_id>\>
using <use_id>;
<if(debug)>/* \</importDeclaration> */<endif>
>>

classExtends_ci(type) ::= "<type>"


classExtends_cc_h(type) ::= "#include \<<type>.h\>"


interfaceExtends(ts) ::=
<<
: public <ts; separator=", public ">
>>

classDeclaration_h(ident, ext, csds) ::=
<<
/* superclass: <ext> */
class <ident>: public CBase_<ident> {
    <csds; separator="\n">
};
>>

classWrapper_h(ident, ext, csds, class1) ::=
<<
<if(debug)>/* \<typeDeclaration> */<endif>

#include "<ident>.decl.h"

<classDeclaration_h(ident=ident, ext=ext, csds=csds)>

<if(debug)>/* \</typeDeclaration> */<endif>
>>

templateDeclaration_h(tident, ident, ext, csds) ::=
<<
#include "<ident>.decl.h"
template \<class <tident; separator=", class ">\>
<classDeclaration_h(ident=ident, ext=ext, csds=csds)>
>>

classDeclaration_cc(ident, ext, csds) ::=
<<
<if(debug)>/* \<typeDeclaration> */<endif>


#include "<ident>.decl.h"
/* superclass: <ext> */
class <ident>: public CBase_<ident> {
    <csds; separator="\n">
};
#include "<ident>.def.h"
<if(debug)>/* \</typeDeclaration> */<endif>

>>


charedeclaration_ci(chareType, arrayDim, ident, ext, csds) ::=
<<
<if(debug)>/* \<typeDeclaration> */<endif>
module <ident> {
<if(ext)>
    extern module <ext>;
    <chareType><if(arrayDim)> [<arrayDim>]<endif> <ident>: <ext> {
<else>
    <chareType><if(arrayDim)> [<arrayDim>]<endif> <ident> {
<endif>
        <csds; separator="\n">
    }
}

<if(debug)>/* \</typeDeclaration> */<endif>

>>


funcMethodDecl_h(modl, gtpl, ty, id, fpl, adl, block) ::=
<<
<if(modl)><modl>: <endif><ty> <gtpl> <id><fpl> <adl>;
>>


funcMethodDecl_ci(modl, gtpl, ty, id, fpl, adl, block) ::=
<<
entry <ty> <gtpl> <id><fpl> <adl>;
>>


funcMethodDecl_cc(modl, gtpl, ty, id, fpl, adl, block) ::=
<<
<if(modl)><modl>: <endif><ty> <gtpl> <id><fpl> <adl> {
    <block>
}
>>


voidMethodDecl_ci(modl, gtpl, id, fpl, block) ::=
<<
entry void<gtpl> <id><fpl>;
>>


voidMethodDecl_h(modl, gtpl, id, fpl, block) ::=
<<
<if(modl)><modl>: <endif>void<gtpl> <id><fpl>;
>>


voidMethodDecl_cc(modl, gtpl, id, fpl, block) ::=
<<
<if(modl)><modl>: <endif>void<gtpl> <id><fpl> {
    <block>
}
>>


ctorDecl_ci(modl, gtpl, id, fpl, block) ::=
<<
entry void<gtpl> <id><fpl>;
>>


ctorDecl_h(modl, gtpl, id, fpl, block) ::=
<<
<if(modl)><modl>:<endif><gtpl> <id><fpl>;
>>


ctorDecl_cc(modl, gtpl, id, fpl, block) ::=
<<
<if(modl)><modl>:<endif><gtpl> <id><fpl> {
    <block>
}
>>


block_cc(bsl) ::=
<<
<bsl:{s| <s><\n>}>
>>


embed_cc(str, blk) ::=
<<
// begin embedded block: <str>
<blk>
// end embedded block: <str>
>>


class_var_decl(modl, type, declList) ::=
<<
<if(modl)>
<modl>:
<else>
public: 
<endif>
<type> <declList>;
>>


var_decl_list(var_decls) ::=
<<
<var_decls; separator=", ">
>>


var_decl(id, initializer) ::=
<<
<id><if(initializer)> = <initializer><endif>
>>


var_decl_id(id, domainExp) ::=
<<
<id><if(domainExp)>(<domainExp>)<endif>
>>


var_id_decl(id, adl) ::=
<<
<id><if(adl)> <adl><endif>
>>


mod_list(mods) ::=
<<
<if(mods)><mods; separator=" "><endif>
>>


local_mod_list(mods) ::=
<<
<if(mods)><mods; separator=" "><endif>
>>
 

local_var_decl(modList, type, declList, domainExps) ::=
<<
<if(modList)>
<modList> <type> <declList>
<else>
<type> <declList>;
<endif>
>>


type(typeID, arrDeclList) ::=
<<
<typeID><arrDeclList>
>>


typeIdent(typeID, generics) ::=
<<
<typeID><generics>
>>


generic_arg_list(types) ::=
<<
\<<types>\>
>>


formal_param_list(sdecl, vdecl) ::=
<<
<if(vdecl)>
(<sdecl; separator=", ">, <vdecl>)
<else>
(<sdecl; separator=", ">)
<endif>
>>


formal_param_decl(modList, type, declID) ::=
<<
<if(modList)><modList> <endif><type> <declID>
>>


assert(cond, msg) ::=
<<
<if(msg)>
CkAssert(<cond> && <msg>);
<else>
CkAssert(<cond>);
<endif>
>>


if(cond, then, else_) ::=
<<
if <cond> {
    <then>
}<if(else_)> else {
    <else_>
}<endif>
>>


for(initializer, cond, update, body) ::=
<<
for (<initializer> <cond> <update>) {
    <body>
}
>>

while(cond, body) ::=
<<
while <cond> {
    <body>
} 
>>

dowhile(cond, body) ::=
<<
do {
    <body>
} while <cond>;
>>


switch(expr, labels) ::=
<<
switch <expr> {
    <labels>
}
>>

return(val) ::=
<<
return<if(val)> <val><endif>;
>>

label(text, stmt) ::=
<<
<text>: <stmt>
>>

case(expr, block) ::=
<<
case <expr>: <block>
>>

for_cond(expr) ::=
<<
<expr>
>>

for_update(exprs) ::=
<<
<exprs; separator=", ">
>>

method_call(primary, generic_types, args) ::=
<<
<if(generic_types)>
<primary>\<<generic_types>\>(<args>)
<else>
<primary>(<args>)
<endif>
>>


array_construction_with_init(array_decls, initializer) ::=
<<
<array_decls> = {<initializer>};
>>


array_construction(exprs, array_decls) ::=
<<
[<exprs; separator="][">]<array_decls>
>> 


arguments(exprs) ::=
<<
<exprs; separator=", ">
>>

range_constructor(range, others, len) ::=
<<
<if(range)>
Domain\<<len>\>(<range>)<if(others)>, <others; separator=", "><endif>
<else>
<endif>
>>