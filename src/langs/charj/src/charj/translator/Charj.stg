group Charj;

charjSource_ci(basename, pd, ids, tds, debug) ::=
<<

// interface for <basename>
<tds; separator="\n\n">

>>


charjSource_h(basename, pd, ids, tds, debug) ::=
<<
#ifndef __<basename>__
#define __<basename>__

/**************************************************************************
 * WARNING                                                                *
 **************************************************************************
 * This is a machine generated header file.                               *
 * It is not meant to be edited by hand and may be overwritten by charjc. *
 **************************************************************************/

<ids>
<tds; separator="\n\n">

#endif // __<basename>__

>>


charjSource_cc(basename, pd, ids, tds, debug) ::=
<<
#include "<basename>.h"

<ids>
<tds; separator="\n\n">

>>

importDeclaration_cc_h(inc_id, use_id) ::=
<<
#include \<<inc_id>\>
using <use_id>;
>>

classExtends_ci(type) ::= "<type>"


classExtends_cc_h(type) ::= "#include \<<type>.h\>"


interfaceExtends(ts) ::=
<<
: public <ts; separator=", public ">
>>

type_preamble_h(sym) ::=
<<
<sym.Includes:{include| #include\<<include>\>
}>
<sym.Usings:{using| using <using>;
}>
<sym.MemberTypeNames:{name| class <name>;
}>
>>

classDeclaration_h(sym, ident, ext, csds) ::=
<<
<type_preamble_h(sym)>
<classDeclaration_h_cont(pds = sym.packageNames, sym = sym, ident = ident, ext = ext, csds = csds)>
>>

classDeclaration_h_cont(pds, sym, ident, ext, csds) ::=
<<
<if(first(pds))>namespace <first(pds)>
{
    <classDeclaration_h_cont(pds = rest(pds), sym = sym, ident = ident, ext = ext, csds = csds)>
} // namespace <first(pds)>
<else>
<if(ext)>
class <ident> : public <ext> {
<else>
class <ident> {
<endif>

    <csds; separator="\n\n">
};
<endif>
>>


classDeclaration_cc(sym, ident, ext, csds) ::=
<<
<classDeclaration_cc_cont(pds = sym.packageNames, sym = sym, ident = ident, ext = ext, csds = csds)>
>>

classDeclaration_cc_cont(pds, sym, ident, ext, csds) ::=
<<
<if(first(pds))>namespace <first(pds)>
{
    <classDeclaration_cc_cont(pds = rest(pds), sym = sym, ident = ident, ext = ext, csds = csds)>
} // namespace <first(pds)>
<else>
<csds; separator="\n\n">
<endif>
>>


chareDeclaration_cc(sym, ident, ext, csds) ::=
<<
#include "<ident>.decl.h"
<chareDeclaration_cc_cont(pds = sym.packageNames, sym = sym, ident = ident, ext = ext, csds = csds)>
#include "<ident>.def.h"
>>

chareDeclaration_cc_cont(pds, sym, ident, ext, csds) ::=
<<
<if(first(pds))>namespace <first(pds)>
{
    <chareDeclaration_cc_cont(pds = rest(pds), sym = sym, ident = ident, ext = ext, csds = csds)>
} // namespace <first(pds)>
<else>
<csds; separator="\n\n">
<endif>
>>

chareDeclaration_h(sym, ident, ext, csds) ::=
<<
<type_preamble_h(sym)>
#include "<ident>.decl.h"
<chareDeclaration_h_cont(pds = sym.packageNames, sym = sym, ident = ident, ext = ext, csds = csds)>
>>

chareDeclaration_h_cont(pds, sym, ident, ext, csds) ::=
<<
<if(first(pds))>namespace <first(pds)>
{
    <chareDeclaration_h_cont(pds = rest(pds), sym = sym, ident = ident, ext = ext, csds = csds)>
} // namespace <first(pds)>
<else>
<if(ext)>/* superclass: <ext> */<endif>
class <ident>: public CBase_<ident> {
    <csds; separator="\n">
};
<endif>
>>

chareDeclaration_ci(sym, chareType, arrayDim, ident, ext, csds) ::=
<<
module <ident> {
<if(ext)>
    extern module <ext>;
<endif>
    <chareDeclaration_ci_cont(pds = sym.packageNames, chareType = chareType, arrayDim = arrayDim, ident = ident, ext = ext, csds = csds)>
}
>>


chareDeclaration_ci_cont(pds, sym, chareType, arrayDim, ident, ext, csds) ::=
<<
<if(first(pds))>namespace <first(pds)>
{
    <chareDeclaration_ci_cont(pds = rest(pds), sym = sym, chareType = chareType, arrayDim = arrayDim, ident = ident, ext = ext, csds = csds)>
} // namespace <first(pds)>
<else>
<chareType><if(arrayDim)> [<arrayDim>]<endif> <ident><if(ext)> : <ext><endif> {
    <csds; separator="\n">
};
<endif>
>>

funcMethodDecl_h(modl, gtpl, ty, id, fpl, adl, block) ::=
<<
<if(first(modl))><modl; separator=" ">: <endif><ty><gtpl> <id><fpl><adl>;
>>


funcMethodDecl_ci(modl, gtpl, ty, id, fpl, adl, block) ::=
<<
entry <ty><gtpl> <id><fpl><adl>;
>>


funcMethodDecl_cc(sym, modl, gtpl, ty, id, fpl, adl, block) ::=
<<
<ty><gtpl> <sym.Name>::<id><fpl><adl>
<block>
>>


ctorDecl_ci(modl, gtpl, id, fpl, block) ::=
<<
entry void<gtpl> <id><fpl>;
>>


ctorDecl_h(modl, gtpl, id, fpl, block) ::=
<<
<if(modl)><modl; separator=" ">: <endif><id><fpl>;
>>


ctorDecl_cc(modl, gtpl, id, fpl, block) ::=
<<
<id>::<id><fpl>
<block>
>>


block_cc(bsl) ::=
<<
{
    <bsl; separator="\n">
}
>>


embed_cc(str, blk) ::=
<<
// begin embedded block: <str>
<blk>
// end embedded block: <str>
>>


class_var_decl(modl, type, declList) ::=
<<
<if(modl)><modl>:<else>public:<endif> <type> <declList>;
>>


var_decl_list(var_decls) ::=
<<
<var_decls; separator=", ">
>>


var_decl(id, initializer) ::=
<<
<id><if(initializer)> = <initializer><endif>
>>


var_decl_id(id, array_decl_list) ::=
<<
<id><if(array_decl_list)> <array_decl_list><endif>
>>


var_id_decl(id, adl) ::=
<<
<id><if(adl)> <adl><endif>
>>


mod_list(mods) ::=
<<
<if(mods)><mods; separator=" "><endif>
>>


local_mod_list(mods) ::=
<<
<if(mods)><mods; separator=" "><endif>
>>


local_var_decl(modList, type, declList) ::=
<<
<if(modList)>
<modList> <type> <declList>;
<else>
<type> <declList>;
<endif>
>>


simple_type(typeID, arrDeclList) ::=
<<
<typeID><arrDeclList>
>>


obj_type(typeID, arrDeclList) ::=
<<
<typeID><arrDeclList>
>>

proxy_type(typeID, arrDeclList) ::=
<<
CProxy_<typeID><arrDeclList>
>>

pointer_type(typeID, arrDeclList) ::=
<<
<typeID>*<arrDeclList>
>>

reference_type(typeID, arrDeclList) ::=
<<
<typeID>&<arrDeclList>
>>


typeIdent(typeID, generics) ::=
<<
<typeID><generics>
>>


generic_arg_list(types) ::=
<<
\<<types>\>
>>


formal_param_list(sdecl, vdecl) ::=
<<
<if(vdecl)>
(<sdecl; separator=", ">, <vdecl>)
<else>
(<sdecl; separator=", ">)
<endif>
>>


formal_param_decl(modList, type, declID) ::=
<<
<if(modList)><modList> <endif><type> <declID>
>>


assert(cond, msg) ::=
<<
<if(msg)>
CkAssert(<cond> && <msg>);
<else>
CkAssert(<cond>);
<endif>
>>


if(cond, then, else_) ::=
<<
if <cond> <then><if(else_)> else <else_><endif>
>>


for(initializer, cond, update, body) ::=
<<
for (<if(initializer)><initializer><else>;<endif> <cond>; <update; separator=", ">) <body>
>>

while(cond, body) ::=
<<
while <cond> <body>
>>

dowhile(cond, body) ::=
<<
do <body> while <cond>;
>>


switch(expr, labels) ::=
<<
switch <expr> {
    <labels>
}
>>

return(val) ::=
<<
return<if(val)> <val><endif>;
>>

label(text, stmt) ::=
<<
<text>: <stmt>
>>

case(expr, block) ::=
<<
case <expr>: <block>
>>

method_call(primary, generic_types, args) ::=
<<
<if(generic_types)>
<primary>\<<generic_types>\>(<args>)
<else>
<primary>(<args>)
<endif>
>>


array_construction_with_init(array_decls, initializer) ::=
<<
<array_decls> = {<initializer>};
>>


array_construction(exprs, array_decls) ::=
<<
[<exprs; separator="][">]<array_decls>
>>


arguments(exprs) ::=
<<
<exprs; separator=", ">
>>


