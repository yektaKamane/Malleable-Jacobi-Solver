int worker( char *t, char **r)

	The user writes this function. Its name does not have to be 
	"worker"; It can be anything. "worker" can be any function
	that the use writes to perform the task on the slave
	processors. It must allocate and compute the response 
	data structure, and return a pointer to it, by assigning to r;
	It must also return the size of the response data structure as
	its return value.


CmsInit(worker, int max); 

	This function must be called before firing any tasks for the workers.
	max is the largest possible number of tasks you will fire
	before calling either CmsAwaitResponses or CmsProcessResponses
	next. (So the system know how many it may have to buffer).

CmsFireTask(int ref, char * t, int size)

	Creates task to be worked on by a worker. The task description
	is pointed to by t, and goes on for size bytes. "ref" must be
	a unique serial number between 0 and max (see CmsInit).

CmsAwaitResponses(); 
	
	This call allows the system to use processor 0 as a worker. It
	returns after all the tasks have sent back their responses. The
	responses themselves can be extracted using CmsGetResponse.

char *  CmsGetResponse(int ref);

	Extracts the response associated with the reference number ref
	from the system's buffers.

CmsProcessResponses(consumer);
	Instead of using AwaitResponses/GetResponse pair, you can use
	this call alone. It turns the control over to the Cms system
	on processor 0, so it can be used as a worker. As soon as a
	response is available on processor 0, cms calls the user
	specified "consumer" function with two parameters: the
	response (a char *) and an integer refnum. 
	(Question should the "size" of the response be passed as a
	parameter to the consumer? User can do that as an explicit
	field of the response themselves, if necessary)

CmsExit(); 

	Must be called on all processors to terminate execution.


Once either CmsProcessResponses or CmsAwaitResponses returns, you may
fire the next batch of tasks via CmsFireTask again.
