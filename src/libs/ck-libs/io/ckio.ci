module CkIO {
  namespace Ck { namespace IO {
      message FileReadyMsg;
      message SessionReadyMsg;
      message SessionCommitMsg;

      namespace impl {
        readonly CProxy_Director director;

        mainchare Director
        {
          entry Director();

          /// Serialize setting up each file through this chare, so that all PEs
          /// have the same sequence
          entry void openFile(std::string name, CkCallback opened, Options opts) {
            atomic {
              if (-1 == opts.peStripe)
                opts.peStripe = 16 * 1024 * 1024;
              if (-1 == opts.writeStripe)
                opts.writeStripe = 4 * 1024 * 1024;

              if (-1 == opts.activePEs) {
                size_t numStripes = (bytes + opts.peStripe - 1) / opts.peStripe;
                opts.activePEs = std::min((size_t)CkNumNodes(), numStripes);
              }
              if (-1 == opts.basePE)
                opts.basePE = 0;
              if (-1 == opts.skipPEs)
                opts.skipPEs = CkMyNodeSize();

              CkAssert(lastActivePE(opts) < CkNumPes());
              CkAssert(opts.writeStripe <= opts.peStripe);

              files[filesOpened] = impl::FileInfo(name, opts);
              managers.openFile(filesOpened++, name, opened, opts);
            }
          };

          entry void prepareWriteSession(FileToken file, size_t bytes, size_t offset,
                                         CkCallback ready, CkCallback complete) {
            atomic {
              int numElements = files[file].activePEs;
              CkArrayOpts opts(numElements);
              opts.setMap();
              CProxy_WriteSession session =
                CProxy_WriteSession::ckNew(file, bytes, offset, complete, opts);
              ready.send(new SessionReadyMessage(session));
            }
          };
        }

        group Manager
        {
          entry Manager();

          entry void openFile(FileToken token, std::string name,
                              CkCallback opened, Options opts) {
            atomic {
              CkAssert(files.end() == files.find(token));
              files[token] = impl::FileInfo(name, opts);

              // Open file if we're one of the active PEs
              // XXX: Or maybe wait until the first write-out, to smooth the metadata load?
              if (((CkMyPe() - opts.basePE) % opts.skipPEs == 0 &&
                   CkMyPe() < lastActivePE(opts)) ||
                  true) {
                files[token].fd = doOpenFile(name);
              }

              contribute(sizeof(FileToken), token, CkReduction::max_int, opened);
            }
          };
        };

        array [1D] WriteSession
        {
          entry WriteSession(FileToken file, size_t offset, size_t bytes,
                             CkCallback complete);
          entry void forwardData(size_t offset, size_t bytes,
                                 const char data[bytes]);
        };
      }
    }
  }
}
