#ifndef __SPANNING_TREE_H_
#define __SPANNING_TREE_H_

/**
 * Author: jjgalvez@illinois.edu (Juan Galvez)
 */
#include "charm++.h"
#include <vector>

/**
 * Abstract class (interface) to generate a spanning tree from a set of pes or logical
 * (Charm++) nodes. These will be referred to simply as nodes, physical nodes will
 * be referred to as phynodes.
 */
class SpanningTreeGenerator {
public:
  /**
   * Given a list of nodes (with root node in position 0), returns the children
   * of root (and their corresponding subtree).
   * Tree algorithm will reorganize nodes vector, so that nodes are grouped by
   * subtree.
   *
   * \param[in] nodes List of IDs of pes/nodes to form a spanning tree, with root in position 0
   * \param[out] nodes For output, nodes list is reorganized, such that they
   * are grouped by subtree, with the first node of each subtree being its root.
   *
   * \param[in] maxBranches Max number of children the root should have.
   * \note Each algorithm can interpret this differently.
   *
   * \param[out] children children[i] has position in \param nodes of i-th child
   * i-th subtree is range [nodes[children[i]], nodes[children[i+1]])
   * Number of children of root is thus children.size() - 1
   *
   * \return number of children of root generated by algorithm
   */
  virtual int buildSpanningTree(std::vector<int> &nodes,
                                int maxBranches,
                                std::vector<int> &children) = 0;
};

// ------------- ST_RecursivePartition -------------

class TopoManager;

/**
 * This strategy is phynode aware, and can form a tree of pes or logical nodes.
 * Will benefit from topology information (coordinates of hosts in the machine,
 * and distance between hosts), but can be used without topology information
 * (and will still be phynode aware).
 *
 * Works for any N-d mesh/torus, including non-contiguous allocations and holes in
 * allocation (e.g. Blue Waters).
 *
 * Algorithm complexity is O(n) where n is number of nodes.
 *
 * Inside a phynode, there will only be one root node, and currently every other
 * node in that phynode is a direct descendant of it (this can be easily changed).
 * Edges between phynodes are only between their corresponding root nodes (as a
 * result there will only be one edge between phynodes).
 */
class ST_RecursivePartition : public SpanningTreeGenerator {
public:

  /**
   * \param nodeTree true if forming tree of nodes, false if tree of pes.
   *
   * \param preSorted true if nodes will be provided grouped by phynode. Allows
   * using slightly more efficient implementation.
   */
  ST_RecursivePartition(bool nodeTree=true, bool preSorted=false);

  /**
   * \param maxBranches Max number of children in different phynode as root
   *
   * \param[out] nodes Nodes will be grouped by subtree, *and* by phynode in output.
   */
  virtual int buildSpanningTree(std::vector<int> &nodes, int maxBranches,
                                std::vector<int> &children);

private:

  class PhyNode;
  class PhyNodeCompare;

  void initPhyNodes(std::vector<int> &nodes, std::vector<PhyNode> &phynodes) const;
  /**
   * \param phyNodes list of phyNodes to build tree from (root phynode in position 0)
   * \param[out] result will store list of nodes grouped by subtree, with the first node
   *   in the subtree being its root)
   * \param[out] children will contain indices (in result) of first node of each subtree
   */
  void build(std::vector<PhyNode*> &phyNodes, std::vector<int> &result,
             std::vector<int> &children, int maxBranches) const;
  void partition(std::vector<PhyNode*> &nodes, int start, int end,
                 int numPartitions, std::vector<int> &children) const;
  void chooseSubtreeRoots(std::vector<PhyNode*> &phyNodes,
                          std::vector<int> &children) const;
  void bisect(std::vector<PhyNode*> &nodes, int start, int end,
              int numPartitions, std::vector<int> &children) const;
  void trisect(std::vector<PhyNode*> &nodes, int start, int end,
              int numPartitions, std::vector<int> &children) const;
  int maxSpreadDimension(std::vector<PhyNode*> &nodes, int start, int end) const;
#if XE6_TOPOLOGY
  void translateCoordinates(std::vector<PhyNode> &nodes) const;
#endif

  bool nodeTree;
  bool preSorted;
  TopoManager *tmgr;
};

#endif
