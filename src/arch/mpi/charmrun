#!/bin/sh
#
# Conv-host for MPI:
#  Translates +pN-style conv-host options into 
# mpirun -npN options.

args=""
pes=1

while [ $# -gt 0 ]
do
	case $1 in
	+ppn)
		args=$args" +ppn "$2
		shift
		;;
	+ppn*)
		args=$args" "$1
		;;
	+p)
		pes=$2
		shift
		;;
	+p*)
		pes=`echo $1 | awk '{print substr($1,3)}'`
		;;
	*) 
		args=$args" "$1
		;;
	esac
	shift
done

echo "Running on $pes processors: $args"

if [ -n "$PBS_NODEFILE" ]
then
  mpirun -np $pes $args
elif [ -n "$LSB_HOSTS" ]
then
# Tungsten
  echo cmpirun -lsf -poll -no_smp -gm_long 200000 $args 
  cmpirun -lsf -poll -no_smp -gm_long 200000 $args 
elif [ -n "$PBS_QUEUE" -o -n "$LSF_QUEUE" ]
then
# Interactive mode: create, and submit a batch job
        script="charmrun_script.$$.sh"
        indir=`pwd`
        output="$indir/charmrun_script.$$.stdout"
        result="$indir/charmrun_script.$$.result"
	rm -f $result
# Some machine specific 
	USE_LSF=0
# 10 minutes	
	walllimit=10
	queue_stat=qstat
	queue_qsub=qsub
	queue_kill=qdel
	hostname=`hostname`
	case "$hostname" in
	turing*.turing.uiuc.edu) 
		ppn='#PBS -l nodes='$pes':ppn=1:myr2'
		extra='-machinefile $PBS_NODEFILE'
		;;
	tg-login*)
		# always ppn=2
		nodes=`expr \( $pes + 1 \) / 2`
		ppn='#PBS -l nodes='$nodes':ppn=2'
		extra='-machinefile $PBS_NODEFILE'
		;;
	co-login*.ncsa.uiuc.edu)
		mem='#PBS -l mem=500mb'
		ncpus="#PBS -l ncpus=$pes"
		;;
	tun*)
		USE_LSF=1
		queue_stat=bjobs
		queue_qsub=bsub
		queue_kill=bkill
		;;
	*)
		ncpus="#PBS -l ncpus=$pes"
		;;
	esac
	if test $USE_LSF -eq 0
	then
	  mpirun=`which mpirun`
          cat > $script << EOF
#!/bin/sh
# This is a charmrun-generated PBS batch job script.
# The lines starting with #PBS are queuing system flags:
#
$ppn
#
$ncpus
#
#PBS -l walltime=$walllimit:00
#
$mem
#
#PBS -q $PBS_QUEUE
#
#PBS -N autobuild
#
#PBS -j oe
#
#PBS -o $output

cd $indir

cat \$PBS_NODEFILE
$mpirun -np $pes $extra $args

# Save mpirun exit status
status=\$?
echo \$status > $result
EOF
	else
#  use LSF
	  mpirun="cmpirun -lsf -poll -no_smp -gm_long 200000"
          cat > $script << EOF
#!/bin/sh
# This is a charmrun-generated PBS batch job script.
# The lines starting with #PBS are queuing system flags:
#
#BSUB -J autobuild
#BSUB -W 0:$walllimit
#BSUB -n $pes
#BSUB -o $output

cd $indir
echo \$LSB_MCPU_HOSTS
$mpirun $args
# Save mpirun exit status
status=\$?
echo \$status > $result
EOF
	fi

End() {
	echo "Charmrun> $queue_kill $jobid ..."
	$queue_kill $jobid
	rm -f $script
	exit $1
}

        echo "Submitting batch job for> $mpirun -np $pes $args"
        echo " using the command> $queue_qsub $script"
        chmod 755 $script
	while [ -z "$jobid" ]
	do
	  [ $USE_LSF = 0 ] && jobid=`$queue_qsub $script|tail -1`
	  [ $USE_LSF = 1 ] && jobid=`$queue_qsub < $script|tail -1|sed -e 's/[^0-9]*//g'`
	done
	echo "Job enqueued under job ID $jobid"
# kill job if interrupted
	trap 'End 1' 2
	retry=0
# Wait for the job to complete, by checking its status
        while [ true ]
        do
                $queue_stat $jobid > tmp.$$
		exitstatus=$?
                if test -f $output
                then
# The job is done-- print its output
                        rm tmp.$$
# When job hangs, result file does not exist
			test -f $result && status=`cat $result` || status=1
			test $status -eq 0 && status=`grep 'End of program' $output > /dev/null 2>&1`
			cat $output
			rm -f $result
			test -f $status && rm -f $script $output
			exit $status
                fi
# The job is still queued or running-- print status and wait
                tail -1 tmp.$$
                rm tmp.$$
# Job ID may not exist now
		if test $exitstatus -ne 0
		then
# retry a few times when error occurs
			retry=`expr $retry + 1`
			if test $retry -gt 6
			then
				echo "Charmrun> too many errors, abort!"
				exit 1
			else
				sleep 15
			fi
		else
# job still in queue
			retry=0
                	sleep 20
		fi
        done
else
  mpirun -np $pes $args
fi



