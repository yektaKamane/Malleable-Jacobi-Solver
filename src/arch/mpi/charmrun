#!/bin/sh
#
# Conv-host for MPI:
#  Translates +pN-style conv-host options into 
# mpirun -npN options.

args=""
pes=1

while [ $# -gt 0 ]
do
	case $1 in
	+ppn)
		args=$args" +ppn "$2
		shift
		;;
	+ppn*)
		args=$args" "$1
		;;
	+p)
		pes=$2
		shift
		;;
	+p*)
		pes=`echo $1 | awk '{print substr($1,3)}'`
		;;
	*) 
		args=$args" "$1
		;;
	esac
	shift
done

echo "Running on $pes processors: $args"

if [ -n "$PBS_NODEFILE" ]
then
  mpirun -np $pes $args
elif [ -n "$PBS_QUEUE" ]
then
# Interactive mode: create, and submit a batch job
        script="charmrun_script.$$.sh"
        indir=`pwd`
        output="$indir/charmrun_script.$$.stdout"
        echo "Submitting batch job for> mpirun -np $pes $args"
        echo " using the command> qsub $script"
	mpirun=`which mpirun`
# Some machine specific 
	hostname=`hostname`
	if [ $hostname = 'turing-2.turing.uiuc.edu' ] 
	then 
		ppn='#PBS -l nodes='$pes':ppn=1'
		extra='-machinefile $PBS_NODEFILE'
	fi
        cat > $script << EOF
#!/bin/sh
# This is a charmrun-generated PBS batch job script.
# The lines starting with #PBS are queuing system flags:

# This determines the number of nodes and pes (here $nodes and $pes):
$ppn
#
#PBS -l ncpus=$pes
#
# This determines the wall-clock time limit (here 5 minutes):
#PBS -l walltime=5:00

# Set memory limit to 500 Mbytes
#PBS -l mem=500mb

# Queue name (see info about other queues in web documentation)
#PBS -q $PBS_QUEUE
#
# Export all my environment variables to the job
#PBS -V
#
# Charge job to project abc (recommended for users with multiple projects)
# [If project is invalid, a valid project will be automatically selected]
##PBS -A abc
#
# Job name (default = name of script file)
#PBS -N autobuild
#
#PBS -j oe
#
# Filename for standard output (default = <job_name>.o<job_id>)
#PBS -o $output
#
cd $indir

# This is the actual command to run the job:
cat \$PBS_NODEFILE
$mpirun -np $pes $extra $args
EOF
        chmod 755 $script
	while [ -z "$jobid" ]
	do
          jobid=`qsub $script|tail -1`
	done
	echo "Job enqueued under job ID $jobid"
# Wait for the job to complete, by checking its status
        while [ true ]
        do
                qstat $jobid > tmp.$$
                if test ! $? -eq 0 -a -f $output
                then
# The job is done-- print its output
                        rm tmp.$$
                        if `grep 'End of program' $output > /dev/null 2>/dev/null`
			then
                        	exec cat $output
			else
				cat $output
				rm $output 
				exit 1
			fi
                fi
# The job is still queued or running-- print status and wait
                tail -1 tmp.$$
                rm tmp.$$
                sleep 20
        done
else
	echo "Charmrun> failed."
	exit 1
fi



