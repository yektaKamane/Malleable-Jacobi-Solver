#!/bin/sh
#
# Conv-host for MPI:
#  Translates +pN-style conv-host options into 
# mpirun -npN options.

args=""
pes=1

while [ $# -gt 0 ]
do
	case $1 in
	+ppn)
		args=$args" +ppn "$2
		shift
		;;
	+ppn*)
		args=$args" "$1
		;;
	+p)
		pes=$2
		shift
		;;
	+p*)
		pes=`echo $1 | awk '{print substr($1,3)}'`
		;;
	*) 
		args=$args" "$1
		;;
	esac
	shift
done

echo "Running on $pes processors: $args"

if [ -n "$PBS_NODEFILE" ]
then
  mpirun -np $pes $args
elif [ -n "$PBS_QUEUE" ]
then
# Interactive mode: create, and submit a batch job
        script="charmrun_script.$$.sh"
        indir=`pwd`
        output="$indir/charmrun_script.$$.stdout"
        result="$indir/charmrun_script.$$.result"
	rm -f $result
        echo "Submitting batch job for> mpirun -np $pes $args"
        echo " using the command> qsub $script"
	mpirun=`which mpirun`
# Some machine specific 
	hostname=`hostname`
	case "$hostname" in
	turing*.turing.uiuc.edu|tg-login*) 
		ppn='#PBS -l nodes='$pes':ppn=1'
		extra='-machinefile $PBS_NODEFILE'
		;;
	co-login*.ncsa.uiuc.edu)
		mem='#PBS -l mem=500mb'
		ncpus="#PBS -l ncpus=$pes"
		;;
	*)
		ncpus="#PBS -l ncpus=$pes"
		;;
	esac
        cat > $script << EOF
#!/bin/sh
# This is a charmrun-generated PBS batch job script.
# The lines starting with #PBS are queuing system flags:

# This determines the number of nodes and pes (here $nodes and $pes):
$ppn
#
$ncpus
#
# This determines the wall-clock time limit (here 5 minutes):
#PBS -l walltime=5:00
#
$mem
#
# Queue name (see info about other queues in web documentation)
#PBS -q $PBS_QUEUE
#
# Job name (default = name of script file)
#PBS -N autobuild
#
#PBS -j oe
#
# Filename for standard output (default = <job_name>.o<job_id>)
#PBS -o $output
#
cd $indir

# This is the actual command to run the job:
cat \$PBS_NODEFILE
$mpirun -np $pes $extra $args
# Save mpirun exit status
status=\$?
echo \$status > $result
EOF
        chmod 755 $script
	while [ -z "$jobid" ]
	do
          jobid=`qsub $script|tail -1`
	done
	echo "Job enqueued under job ID $jobid"
# Wait for the job to complete, by checking its status
        while [ true ]
        do
                qstat $jobid > tmp.$$
# Job ID does not exist now
                if test $? -ne 0 -a -f $output
                then
# The job is done-- print its output
                        rm tmp.$$
# When job hangs, result file does not exist
			test -f $result && status=`cat $result` || status=1
			test $status -eq 0 && status=`grep 'End of program' $output > /dev/null 2>/dev/null`
			cat $output
			rm -f $result
			test -f $status && rm -f $script $output
			exit $status
                fi
# The job is still queued or running-- print status and wait
                tail -1 tmp.$$
                rm tmp.$$
                sleep 20
        done
else
  mpirun -np $pes $args
fi



