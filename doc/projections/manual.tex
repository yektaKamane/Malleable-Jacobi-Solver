\documentclass[10pt,dvips]{article}
\usepackage{../pplmanual,epsfig,graphicx}
\input{../pplmanual}

\title{\projections{} Manual}
\version{2.1}
\credits{
By Mike DeNardo, Sid Cammeresi, Theckla Loucios, Orion Lawlor, Gengbin Zheng,
Chee Wai Lee, and Sindhura Bandhakavi
}

\begin{document}
\maketitle

\section{Introduction}

\projections{} is a parallel performance analysis/visualization tool
to help you understand and analyze what is happening in your parallel
(\charmpp{}) program. It is a post-mortem trace-based tool with
features that allow you to control the amount of information generated
and to a lesser degree the amount of perturbation the tracing
activities introduce into the application.

Performance analysis with \projections{} typically involves 3 phases:

\begin{itemize}
\item 
Instrumentation of user code (automated by default) and linking trace
generation modules. (see section \ref{sec::preparation})
\item
Generating trace data files. (see section \ref{sec::trace generation})
\item
Visualizing data and derived information (e.g. statistics); analyzing
possible performance problems (currently a manual process) of the
application. (see section \ref{sec::visualization})
\end{itemize}

\section{Preparing the \charmpp{} Application}
\label{sec::preparation}

The \charmpp{} runtime is automatically instrumented by default. This
means {\em most} users will not need to manually insert code into
their applications (see section \ref{sec::api}) in order to generate
trace data.

In the event that greater control over tracing activities
(e.g. dynamically turning instrumentation on and off) are desired,
\projections{} provides an API that allows users to insert code into
their applications for such purposes. Users may also register and
trace their own application-specific events (with limited support by
the visualization tool) via this API.

Please note that automatic instrumentation introduces the overhead of
an if-statement for each significant runtime event, even if no
performance analysis traces are desired.

Users who consider such an overhead to be unacceptable (e.g. for a
production application which requires the absolute best performance)
may recompile the \charmpp{} runtime with the {\tt -DCMK\_OPTIMIZE}
flag which removes the instrumentation stubs.

Otherwise, to enable the tracing of your application, users simply
need to link the appropriate trace data generation module(s) (also
referred to as {\em tracemode(s)}). (see section \ref{sec::trace modules})

\subsection{\projections{} API}
\label{sec::api}

\subsubsection{Selective Tracing}

\charmpp{} allows user to start/stop tracing the execution at certain
points in time on the local processor. Users are advised to make these
calls on all processors and at well-defined points in the application.

Users may choose to have instrumentation turned off at first (by
command line option {\tt +traceoff} - see section \ref{sec:: general
runtime options}) if some period of time in middle of the
application\'s execution is of interest to the user.

Alternatively, users may start the application with instrumentation
turned on (default) and turn off tracing for specific sections of the
application.

Again, users are advised to be consistent as the {\tt +traceoff}
runtime option applies to all processors in the application.

\begin{itemize}
\item
{\tt void traceBegin()}

Enables the runtime to trace events (including all user events) on the local processor where {\tt traceBegin} is called.

\item
{\tt void traceEnd()}

Prevents the runtime from tracing events (including all user events) on the local processor where {\tt traceEnd} is called.

\end{itemize}

\subsubsection{User Events}

\projections{} has a limited ability to visualize traceable user
specified events. You can make use of the following API calls to do
this. The general steps to do this are:

\begin{enumerate}
\item
Register an event with an identifying string and either specify or acquire
a globally unique event identifier.

\item
Use the event identifier to specify trace points in your code of interest to you.
\end{enumerate}

The functions available are as follows:

\begin{itemize}
\item
{\tt int traceRegisterUserEvent(char* EventDesc, int EventNum=-1) }

This function registers a user event by associating {\tt EventNum} to
{\tt EventDesc}. If {\tt EventNum} is not specified, a globally unique
event identifier is obtained from the runtime and returned.

{\tt EventNum} has to be the same on all processors. There are 3 ways
to ensure that, and correspondingly 3 ways to call the function:

\begin{enumerate}
\item
Call {\tt traceRegisterUserEvent} on node 0 in main::main without specifying
an event number, and store returned event number into a readonly variable.
\item
Call {\tt traceRegisterUserEvent} on all nodes without specifying an
event number. The returned value is the common event number that is
agreed on system-wide.
\item
Call {\tt traceRegisterUserEvent} and specify the event number on
processor 0. Doing this on other processors would have no
effect. Afterwards, the event number can be used in the following user
event calls.
\end{enumerate}

Eg. {\tt traceRegisterUserEvent("Time Step Begin", 10);}

Eg. {\tt eventID = traceRegisterUserEvent(``Time Step Begin'');}

\item
{\tt void traceUserEvent(int EventNum) }

This function works like a marker, indicating an occurrence of a
user-defined point event with the given {\tt EventNum}.

Eg. {\tt traceUserEvent(10);}

\item
{\tt void traceUserBracketEvent(int EventNum, double StartTime, double EndTime) }

This function records an event interval or activity identified by {\tt
EventNum} that lasts the period of time between {\tt StartTime} and
{\tt EndTime}. Both {\tt StartTime} and {\tt EndTime} can be obtained
from function call {\tt CmiWallTimer()} in seconds.

Eg.
\begin{verbatim}
   traceRegisterUserEvent("Critical Code", 20);
   double critStart;  // times of start
   critStart = CmiWallTimer();
   // do the critical code
   traceUserBracketEvent(20, critStart,CmiWallTimer());
\end{verbatim}

\end{itemize}

\subsection{Tracemodes}
\label{sec::trace modules}

Currently there are 2 tracemodes available. Zero or more tracemodes
may be specified at link-time. When no tracemodes are specified, no
trace data is generated.

\subsubsection{Projections mode}

Link time option: {\tt -tracemode projections}

This tracemode generates detailed log files that contain information
about all \charmpp{} events like entry method calls and message
packing during the execution of the program.  The data will be used by
\projections{} in visualization and analysis.

This tracemode generates a single symbol table file and $p$ ASCII log
files for $p$ processors. The names of the log files will be
NAME.\#.log where NAME is the name of your executable and \# is the
processor \#. The name of the symbol table file is NAME.sts where NAME
is the name of your executable.

This is the main source of data expected by the performance
visualizer. Certain tools like timeline will not work without the
detailed data from this tracemode. Refer to \ref{apx::file
formats} for more information about the format of the files generated
by this tracemode.

See section \ref{sec::projections runtime options} for application runtime
options available to this tracemode for generating trace data.

\subsubsection{Summary mode}

Compile option: {\tt -tracemode summary}

In this tracemode, execution time across all entry points for each
processor is partitioned into a fixed number of equally sized
time-interval bins. These bins are globally resized whenever they are
all filled in order to accomodate longer execution times while keeping
the amount of space used constant.

Additional data like the total number of calls made to each entry
point is summarised within each processor.

This tracemode generates a single symbol table file and $p$ ASCII
summary files for $p$ processors. The names of the summary files will
be NAME.\#.sum where NAME is the name of your executable and \# is the
processor \#. The name of the symbol table file is NAME.sum.sts where NAME
is the name of your executable.

This tracemode can be used to control the amount of output generated
in a run. It is typically used in scenarios where a quick look at the
overall utilization graph of the application is desired to identify
smaller regions of time for more detailed study. Attempting to
generate the same graph using the detailed logs of the prior tracemode
may be unnecessarily time consuming or impossible.

See section \ref{sec::summary runtime options} for application runtime
options available to this tracemode for generating trace data.

\section{Generating trace data}
\label{sec::trace generation}

A set of runtime options are available to you depending on which {\em
tracemode(s)} you have specified at link time. These are used to
control various aspects of trace file output.

The appropriate files (see preceeding descriptions of available
tracemodes) are generated automatically when the application is run.

\subsection{General runtime options}
\label{sec::general runtime options}

The following is a list of runtime options available with the same
semantics for all tracemodes:

\begin{itemize}
\item
{\tt +traceroot DIR}: place all generated files in DIR.
\item
{\tt +traceoff}:      trace generation is turned off when the application is started. The user is expected to insert code to turn tracing on at some point in the run.
\end{itemize}

\subsection{Projections tracemode runtime options}
\label{sec::projections runtime options}

The following is a list of runtime options available under this tracemode:

\begin{itemize}
\item
{\tt +logsize NUM}:   keep only NUM log entries in the memory of each processor. The logs are emptied and flushed to disk when filled.
\item
{\tt +binary-trace}:  generate projections log in binary form.
\item
{\tt +gz-trace}:      generated gzip (if available) compressed log files.
\end{itemize}

\subsection{Summary tracemode runtime options}
\label{sec::summary runtime options}

The following is a list of runtime options available under this tracemode:

\begin{itemize}
\item
{\tt +logsize NUM}:   use NUM time-interval bins. The bins are resized and compacted when filled.
\item
{\tt +binsize TIME}:   sets the initial time quantum each bin represents.
\item
{\tt +version}:        set summary version to generate.
\end{itemize}

\section{The \projections{} Performance Visualization Tool}
\label{sec::visualization}

\subsection{Compiling \projections{}}
\begin{enumerate}
\item[1)]
   Make sure the JDK commands ``java'', ``javac'' and ``jar''
   are in your path
\item[2)]
   From {\tt PROJECTIONS\_LOCATION/}, type ``make''
\item[3)]
   The following files are placed in `bin':

      {\tt projections}           : Starts projections, for UNIX machines

      {\tt projections.bat}       : Starts projections, for Windows machines

      {\tt projections.jar}       : archive of all the java and image files
\end{enumerate}

\subsection{Running \projections{}}
From any location, type

{\tt > PROJECTIONS\_LOCATION/bin/projections [NAME.sts]}

where {\tt PROJECTIONS\_LOCATION} is the path to the main projections
directory.

Supplying the optional {\tt NAME.sts} file in the command line will
cause projections to load data from the file at startup. This shortcut
saves time selecting a set of data from the GUI's file dialog.

\subsection{Using \projections{}}

\begin{figure}[htb]
\center
\epsfig{figure=fig/front-with-summary.eps,height=3in}
\caption{\projections{} main window}
\label{mainwindow}
\end{figure}

When \projections{} is started, it will display a main window as shown in figure \ref{mainwindow}. If summary (.sum) files are available in the set of data, a low-resolution utilization graph will be displayed as shown. Otherwise, the main window shows a blank screen.



\subsubsection{Open File}

   Clicking on the Open File button brings up a dialog box to let you select
   the location of the data you want to look at.  Navigate to the directory
   containing your data and select the .sts file.  Click on 'OK'.  If you
   have selected a valid file, \projections{} will load in some preliminary data
   from the files and then activate the rest of the buttons in the main window.
   If your file is invalid, you will be shown an error dialog.

   As mentioned in last section, a .sts file can be directly opened through command
   line, and thus time is saved.

\subsubsection{Graphs}

   The Graphs window is where you can analyze your data by breaking it into
   any number of intervals and look at what goes on in each of those intervals.

   When the Graph Window first appears, a dialog box will also appear, asking
   you what interval settings you want to use.  It will show you the total
   amount of time your program run took (in microseconds) and ask you to enter
   either the interval size you want or the number of intervals you want.
   Entering a number in either box will recalculate the other number, so you
   will know both items. Click on 'OK' when you are satisifed with your choice.
   Your data will then be analyzed.

   The amount of time to analyze your data depends on several factors, including
   the number of processors, number of entries, and number of intervals you have
   selected.  Although a progress meter has not been implemented at this time,
   you can look at the console window to see which log file is being analyzed.
   Even for large amounts of data, this step should not take more than a few
   minutes, though.

   \begin{figure}[htb]
   \center
   \epsfig{figure=fig/graph.eps,height=4.3in}
   \caption{Graph module}
   \label{graph}
   \end{figure}

      The Graph Window has 3 components in its display:
   \begin{enumerate}
   \item[1)]
   Display Panel:
      \begin{itemize}
      \item[-]
        Largest Component in top/left corner
      \item[-]
        Displays title, graph, and axes
      \item[-]
        Allows you to toggle display between a line graph and a bar graph
      \item[-]
        Allows you to scale the graph along the X-axis.  You can either enter
        a scale value $>=$ 1.0 in the text box, or you can use the $<<$ and $>>$
        buttons to increment/decrement the scale by .25.  Clicking on Reset
        sets the scale back to 1.0.  When the scale is greater than 1.0, a
        scrollbar will appear along the bottom of the graph to let you
        scroll back and forth.
      \end{itemize}

   \item[2)]
   Legend Panel:
      \begin{itemize}
      \item[-]
        Top right side of the display
      \item[-]
        Shows what is currently being displayed on the graph and what color it
        is.
      \item[-]
        Click on the 'Select Display Items' button to bring up a window to
        add/remove items from the graph and to change the colors of the items.
        \begin{itemize}
	\item[*]
          The Select Display Items window shows a list of items that you can
          display on the graph.  There are 3 main sections:
            System Usage, System Msgs, and User Entries
          The System Usage and System Msgs are the same for all programs.  The
          User Entries section has program-specific items in it.
	\item[*]
          Click on the checkbox next to an item to have it displayed on the
          graph.
	\item[*]
          Click on the colorbox next to an item to modify its color.
	\item[*]
          Click on 'Select All' to choose all of the items
	\item[*]
          Click on 'Clear All' to remove all of the items
	\item[*]
          Click on 'Apply' to apply you choices/changes to the graph
	\item[*]
          Click on 'Close' to exit
	\end{itemize}
      \end{itemize}
   \item[3)]
   Control Panel:
      \begin{itemize}
      \item[-]
        Bottom of the display
      \item[-]
        Allows you to toggle what is displayed on the X-axis.  You can either
        have the x-axis display the data by interval or by processor.
      \item[-]
        Allows you to toggle what is displayed on the Y-axis.  You can either
        have the y-axis display the data by the number of msgs sent or
        by the amount of time taken.
      \item[-]
        Allows you to change what data is being displayed by iterating through
        the selections.  If you have selected an x-axis type of 'interval',
        that means you are looking at what goes on in each interval for a
        specific processor.  Clicking on the $<<, <, >, >>$ buttons will change
        the processor you are looking at by either -5, -1, +1, or +5.
        Conversely, if you have an x-axis of 'processor', then the iterate
        buttons will change the value of the interval that you are looking at
        for each processor.
      \item[-]
        Allows you to indicate which intervals/processors you want to examine.
        Instead of just looking at one processor or one interval, the box and
        buttons on the right side of this panel let you choose any number or
        processors/intervals to look at.  Just enter the number(s) in the box.
        If you want to look at multiple items, separate them with commas.  If
        your selections include a range of items, you can separate those with
        a dash.

        ex: Want to see processors 1,3,5,7:  Enter 1,3,5,7

	ex: Want to see processors 1,2,3,4:  Enter 1-4

	ex: Want to see processors 1,2,3,7:  Enter 1-3,7

        Clicking on 'Apply' updates the graph with your choices.
        Clicking on 'Select All' chooses the entire range.  When you select more
        than one set of data to display, the graph will show the TOTAL amount of
        the data for all of those items, EXCEPT for the processor usage, which
        shows the average amount.
      \end{itemize}
    \end{enumerate}

\subsubsection{Timelines}

   The Timeline window lets you look at what a specific processor is doing at
   each moment of the program.

   \begin{figure}[htb]
   \center
   \epsfig{figure=fig/timeline.eps,height=3.8in}
   \caption{Timeline module}
   \label{timeline}
   \end{figure}

      When the Timeline window first appears, a dialog box appears along with it.
   The box asks for the following information:
   \begin{itemize}
   \item[-]
     Processor(s):  Choose which processor(s) you want to see a timeline for.
                    To enter multiple values, separate them with a comma or a
                    dash (for ranges).  (See the Graphs section for examples)
   \item[-]
     Begin Time  : Choose what time you want your timeline to start at.
   \item[-]
     End Time    : Choose what time you want your timeline to end at.
   \item[-]
     Length      : Choose the length of your timeline.
   \end{itemize}

   The dialog box tells you what the valid processor choices are as well as what
   the valid time ranges are.

   Instead of entering a BeginTime, you can have the dialog box choose a
   BeginTime for you based on the occurrence of a specific entry.  To do this,
   you go to the bottom portion of the dialog box and select an entry to find an
   occurrence of.  Then, you choose the processor you want to find an occurrence
   on, and which occurrence you want to find (N).  Click on 'Search for Begin
   Time'.  The dialog box will display a message telling you if your occurrence
   was found and when it was found.  If valid, the time is automatically entered
   as the begin time.

   When you are satisifed with your time and processor ranges, click on 'OK'.
   \projections{} will then get the Timeline data for you.  The time for this step
   depends on the number of items in your time range and the number of
   processors you have chosen.

   The Timeline Window consists of two parts:
   \begin{enumerate}
   \item[1)]
      Display Panel:
      This is where the timelines are displayed and is the largest portion of
      the window.  The time axes are displayed at the top and the bottom of the
      panel, and the units are microseconds.  The left side of the panel shows
      the processor labels.  Underneath each label is a percentage telling you
      what amount of the total time in your timeline was actually spent working
      on this program.

      The timeline itself consists of colored bars for each
      work item.  Placing the cursor over one of these bars will bring up a
      pop-up window telling you the name of that item, the begin time, the end
      time, and the total time.  It will also tell you what amount of time was
      spent packing, how many messages were created during this work item, and
      which processor created this item.  If you click on the item, a window
      will appear telling you similar information to the pop-up window.  This
      window will also list all of the messages created during this work item,
      and it will tell you what time they were sent at and to which entry.

   \item[2)]
      Control Panel:

	It's located at the bottom of the window. Its components are described
	as follows.

      Checkboxes:
      \begin{itemize}
      \item[-]
        Display Pack Times\\
        Lets you toggle display of Time spent packing
      \item[-]
        Display Message Creations\\
        Lets you toggle display of message creations. These are represented
        by little vertical lines at the time a message was created.
      \item[-]
	Display Idle Time\\
        Lets you toggle display of idle time
      \item[-]
        View User Event ({\bf really cool new feature!!!})\\
	Checking this box will bring up a new window showing the string description,
	begin time, end time and duration of all user events on each processor.
	Especially, the user event caught by function {\tt traceUserEvent} has
	a duration of 0.

      \begin{figure}[htb]
      \center
      \epsfig{figure=fig/userevent.eps,height=1.5in}
      \caption{User Event Window}
      \label{userevent}
      \end{figure}

        Like system events, user events are also displayed as thin lines or bars
	above in the disply area.
      \end{itemize}
      Buttons:
      \begin{itemize}
      \item[-]
        Select Ranges\\
        Brings up the initial dialog box
      \item[-]
        Change Colors\\
        Lets you change colors for the work items
      \item[-]
        Scale\\
        Enter a scale $>=$ 1.0 in the box, or click on the $<<$ and $>>$ buttons to
        adjust the scale by 0.25 increments.  Click on Reset to set the scale
        back to 1.0
      \end{itemize}

      Another really cool new feature {\bf zoomability} has been implemented in
      timeline module.

      To determine the exact time of any event on the timeline, move your mouse
      along either the top or bottom axis and a white vertical highlight line
      will show where your cursor is along the timeline.  The "Highlight Time"
      box on the bottom of the Timeline window will show the exact time of your
      cursor.

      To select an area, click on the axis to define the start of the area and
      drag the mouse to the end of the area to be defined.  Two yellow vertical
      lines will bracket the area of interest.  The exact times of the selected
      area will be shown in the "Selection Start Time" text area and the
      "Selection End Time" text area.  The difference between these times is
      shown in ms in the "Selected Length" text area.  Thus, this feature can be
      used to measure the time between two events of interest across processors,
      and is an easy way to measure the time of an entry point (instead of
      getting the "Tool Tip" balloon by putting the cursor in the entry point.

      To zoom into a selected area (instead of using the scale field and/or the
      "<<" and ">>" buttons) simply select an area and click on either the "Zoom
      Selected" or the "Load Selected" buttons.  The difference between these
      two buttons is that the "Load Selected" zooms into the selected area and
      discards any events that are outside the time range.  This is useful
      because it will be a lot faster to zoom because the "Zoom Selected" draws
      all the events on a virtual canvas and then zooms into the canvas.
      However, if the "Load Selected" button is used, to zoom back out, you need
      to start over from "Select Ranges" button and that will slow down the processing.

   \end{enumerate}

\subsubsection{Usage Profile}

   The Usage Profile window lets you see percentage-wise what each processor
   spends its time on during a specified period.

   When the window first comes up, a dialog box appears asking for the
   processor(s) you want to look at as well as the time range you want to look
   at.  This is similar to the dialog for the Timelines.

   The bottom portion of the Usage Profile window lets you adjust the scales in
   both the X and Y directions.  The X direction is useful if you are looking at
   a large number of processors.  The Y direction is useful if there are
   small-percentage items for a processor.

   The left side of the display shows a scale from 0\% to 100\%.  The main part of
   the display shows the statistics.  Each processor is represented by a
   vertical bar.  The top of the bar always shows the overhead time.  Below that
   is always (if exists) the idle time and then the message packing/unpacking
   times.  The rest of the bar is ordered from the bottom with the largest
   percentage items being closest to the bottom.  If you place the cursor over a
   portion of the bar, a pop-up window will appear telling you the name of the
   item, what percent of the usage it has, and the processor it is on.

\subsubsection{Animations}

   This window animates the processor usage by displaying
   different colors for different amount of usage.

   The left box allows you to select the real time between frames;
   the right box the processor time between frames.


\subsubsection{View Log Files}

   This window lets you see a translation of a log file from a bunch of numbers
   to an English version.  A dialog box asks which processor you want to look
   at.  After choosing and pressing OK, the translated version appears.

   Each line has:
   \begin{itemize}
   \item[-] a line number (starting at 0)
   \item[-] the time the event occurred at
   \item[-] a description of what happened.
   \end{itemize}

\subsubsection{Histograms}

This module allows you to examine the execution time distribution of all your
entry points(EP). It gives a histogram of different number of EP's that have
execution time falling in different time bins. Under the graph there are also
statistics given in numbers.

\subsubsection{Overview}

Overview gives user an overview of the utilization of all processors during the
execution. Each processor has a row of colored bars in the display, different colors
indicating different utilization at that time. Moving a mouse over the graph
will invoke a display of the processor usage of the specific processor at the
specific time in the status bar below the graph. Vertical and horizontal zoom is
enabled by two zooming bars to the right and lower of the graph.

\end{document}
