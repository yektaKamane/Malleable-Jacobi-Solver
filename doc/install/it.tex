\newcommand{\ITC}{Interface Translator} 
\newcommand{\itc}{IT Charm++} 

\newcommand{\BE}{\begin{enumerate}}
\newcommand{\EE}{\end{enumerate}}
\newcommand{\BC}{\begin{center}}
\newcommand{\EC}{\end{center}}
\newcommand{\BEQ}{\begin{equation}}
\newcommand{\EEQ}{\end{equation}}
\newcommand{\BI}{\begin{itemize}}
\newcommand{\EI}{\end{itemize}}
\newcommand{\BF}{\begin{figure}}
\newcommand{\EF}{\end{figure}}
\newcommand{\BT}{\begin{tabbing}}
\newcommand{\ET}{\end{tabbing}}
\newcommand{\BAR}{\begin{array}}
\newcommand{\EAR}{\end{array}}
\newcommand{\BV}{\begin{verbatim}}
\newcommand{\EV}{\end{verbatim}}


\section[Interface Translator]{Interface Translator}
\label{Interface Translator}

This section describes what files are needed and created
when using \itc, and how an \itc\ program is compiled.

\subsection{Basic Files and Compilation}

Users of the non-translator version must \#include "ckdefs.h"
(which contains macros provided by \itc)
in their C++ code (pgm.C).
Users must create an additional
interface file (pgm.ci) containing the essential components of
their program as described below.  The interface file must be
named $<$module$>$.ci, where $<$module$>$ is the name of the module, and
the .ci stands for Charm++ Interface file.

Compile the \itc program pgm.C as usual, ensuring that the
pgm.ci file precedes the pgm.C file:
\begin{verbatim}
        charmc -language charm++ -o pgm pgm.ci pgm.C
                      OR
        charmc -language charm++ pgm.ci
        charmc -language charm++ -o pgm pgm.C
\end{verbatim}
The interface file, pgm.ci, is transparently processed by a tool
called charmxi (Charm++ interface translator) to produce a
"pgm.top.h" file and a "pgm.bot.h" file.
(The non-parsing
translator will NOT look at or cross-check with pgm.h and pgm.C
files; it will SOLELY process the pgm.ci file.)
For each module only one pgm.top.h and one pgm.bot.h file will be
produced from the pgm.ci file.

The resulting pgm.top.h file contains only declarations, not
definitions; and the pgm.bot.h file contains functions and
variable definitions generated by the interface translator.

Generally speaking, the pgm.top.h file must be \#include'd at the
top of pgm.C, and the pgm.bot.h must be \#include'd at the bottom
of pgm.C BY THE USER.  Here are more details about this:

\subsection{One Module, One or Multiple Source Code Files}

\BE
\item
There is only one module.ci file

\item
There may be several .C and .h files containing the code for the module.

\item
In all the .C files of a module, the user \#include's ckdefs.h
and module.top.h at the beginning of the file as
follows:
\BV
        #include "ckdefs.h"
        #include "chare.h"
        #include "c++interface.h"
        #include "module.top.h"
\end{verbatim}

\item
In only ONE .C file, the user \#include's module.bot.h
at the end of the file.  This .C file MUST contain the
class declaration, so the wrapper functions don't give
an error.
\EE

\subsection{Multiple Modules}

\BE
\item
There is ONE module.ci file for EACH module.

\item
Sharing of user-defined declarations/definitions across
	modules is done with the usual C++ extern declarations,
	in the HEADER .h files.

\item
IN ADDITION, if moduleAA is using a message or chare (i.e.
	some construct) which is defined in moduleBB, moduleAA
	needs to declare as extern the accessed message or chare
	in the moduleAA.ci file.  This is done by preceding the
	construct with the word 'extern' in the interface file.
\EE

Compile the .ci files before any Charm++ program file:
\BV
        charmc -language charm++ -c moduleAA.ci moduleBB.ci
        charmc -language charm++ -c moduleAA.C
        charmc -language charm++ -c moduleBB.C
        charmc -language charm++ -o pgm moduleAA.o moduleBB.o
\end{verbatim}

\subsection{Currently unsupported Features of Charm++}

The non-translator version does not support accumulators, monotonics
(they can be implemented as BOC libraries), or varsize messages (they
can be implemented by the user using pack/unpack functions).

\subsection{Extensions to Charm++: EXTERN, THREADED and Return Values}

\BI
\item To declare a chare or message as extern:
        This is done by preceding the construct with the word
'extern' in the interface file.

\item To declare an entry point as a threaded entry point:
	This is done by preceding the construct with the word
	'threaded' in the interface file.

\item For an entry point to return a message of type MsgType:
	This is indicated by preceding the entry point with the
	MsgType in the interface file.
\EI

If more than one of the above words must precede a construct,
the words must appear in the order listed.
