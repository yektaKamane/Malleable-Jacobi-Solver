\documentclass[10pt]{article}
\usepackage{../pplmanual}
\input{../pplmanual}
\def\smallfbox#1{\small \fbox{#1}}

\title{Charisma Manual}
\version{1.0}
\credits{
Charisma started as an orchestration language by Laxmikant Kale, Mark Hills and
Chao Huang. It has been developed and maintained by Chao Huang.
}

\begin{document}
\maketitle

\section{Introduction}

This manual describes Charisma, an orchestration language for migratable
parallel objects. 

\section{Charisma Syntax}
A Charisma program is composed of two parts: the orchestration code in a .or
file, and sequential user code in C/C++ form. 

\subsection{Orchestration Code}
The orchestration code in the .or file can be divided into two part. The header
part contains information about the program, included external files, defines,
and declaration of parallel constructs used in the code. The orchestration
section is made up of statements that forms a global control flow of the
parallel program. In the orchestration code, Charisma employs a macro dataflow
approach; the statments produce and consume values, from which the control flows
can be organized, and messages and method invocations generated. 

The very first line should give the name of the Charisma program with the {\tt
program} keyword.

\begin{alltt}
    program jacobi    
\end{alltt}

The {\tt program} keyword can be replaced with {\tt module}, which means that
the output program is going to be a library module instead of a stand-alone
program. 


\subsection{Sequential Code}

\appendix

\section{Example: Jacobi 1D}
Following is the content of the orchestration file jacobi.or. 

\begin{SaveVerbatim}{foodecl}
program jacobi

class  JacobiMain : MainChare;
class  JacobiWorker : ChareArray1D;
param  lb : double[900];
param  rb : double[900];
obj  workers :  JacobiWorker[30];

begin
    for iter := 1 to 10
	foreach i in workers
	    <lb[i], rb[i]> := workers[i].produceBorders();
	    workers[i].compute(lb[i+1], rb[i-1]);
	end-foreach
    end-for
end
\end{SaveVerbatim}
\vspace{0.1in}
\smallfbox{\BUseVerbatim{foodecl}}
\vspace{0.1in}

The class {\tt JacobiMain} does not need any sequential code, so the only
sequential code are in JacobiWorker.h and JacobiWorker.C. Note that
JacobiWorker.h is not really an ANSI C header file. Instead, it is the
sequential portion of the class's declaration. Charisma will generate the class
declaration from the orchestration code, and incorporate the sequential portion
in the final header file. 

\begin{SaveVerbatim}{foodecl}
#define N 900
#define M 30

int currentArray;	
double localData[2][M][N]; 
double localLB[N];
double localRB[N];
int myLeft,myRight,myUpper,myLower;

void initialize();
void compute(double lghost[], double rghost[]);
void produceBorders(outport lb,outport rb);
double abs(double d);
\end{SaveVerbatim}
\vspace{0.1in}
\smallfbox{\BUseVerbatim{foodecl}}
\vspace{0.1in}

Similarly, the sequential C code will be integrated into the generated C file.
Below is part of the sequential C code taken from JacobiWorker.C to show how
consumed parameters ({\tt rghost} and {\tt lghost} in {\tt
JacobiWorker::compute}) and produced parameters ({\tt lb} and {\tt rb} in {\tt
JacobiWorker::produceBorders}) are handled.

\begin{SaveVerbatim}{foodecl}
void JacobiWorker::compute(double rghost[], double lghost[]){
    /* local computation for updating elements*/
}

void JacobiWorker::produceBorders(outport lb, outport rb){
    produce(lb,localData[currentArray][myLeft],myLower-myUpper+1);
    produce(rb,localData[currentArray][myRight],myLower-myUpper+1);
}
\end{SaveVerbatim}
\vspace{0.1in}
\smallfbox{\BUseVerbatim{foodecl}}
\vspace{0.1in}

The user compile these input files with the following command:

\begin{alltt}
> orchc jacobi.or
\end{alltt}

The compiler generates the parallel code for sending out messages, organizing
flow of control, and then it looks for sequential code files for the classes
declared, namely {\tt JacobiMain} and {\tt JacobiWorker}, and integrates them
into the final output: {\tt jacobi.h}, {\tt jacobi.C} and {\tt jacobi.ci}, which
is a Charm++ program and can be built the way a Charm++ program is built.


\end{document}
