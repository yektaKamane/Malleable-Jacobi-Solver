\section{Introduction}

If array elements compute a small piece of a large 2D image, then these 
image chunks can be combined across processors to form one large 
image using the liveViz library. In other 
words, liveViz provides a way to reduce 2D-image data, which 
combines small chunks
 of images deposited by chares into one large image.

This visualization library follows the client server model.
The server, a parallel Charm++ program, does all image assembly, 
and opens a network (CCS) socket which clients use to request and 
download images.  The client is a small Java program.
A typical use of this is:
\begin{alltt}
	cd charm/pgms/charm++/ccs/liveViz/server
	make
	./charmrun ./pgm +p2 ++server ++server-port 1234 &
	~/charm/bin/liveViz localhost 1234
\end{alltt}



\section{How to use liveViz with \charmpp{} program}

The liveViz routines are in the Charm++ header ``liveViz.h''.

A typical program provides a chare array with one entry method 
with the following prototype:

\begin{alltt}
  entry void functionName(liveVizRequestMsg *m);
\end{alltt}

This entry method is supposed to deposit its (array element's) chunk of 
the image. This entry method has following structure:

\begin{alltt}
  void myArray::functionName (liveVizRequestMsg *m)
  \{
    // prepare image chunk
       ...

    liveVizDeposit (m, startX, startY, width, height, imageBuff, this);

    // delete image buffer if it was dynamically allocated
  \}
\end{alltt}

Here, ``width'' and ``height'' are the size, in pixels, of this array
element's portion of the image, contributed in ``imageBuff'' (described below).
This will show up on the client's assembled image at 0-based pixel
(startX,startY).  The client's display width and height are stored
in m->req.wid and m->req.ht.

By default liveViz combines image chunks by doing a saturating sum of 
overlapping pixel values. If you want liveViz to combine image chunks by using 
max (i.e. for overlapping pixels in deposited image chunks, final image will 
have the pixel with highest intensity or in other words largest value), you need
to pass one more parameter (liveVizCombine\_t) to the ``liveVizDeposit'' function:

\begin{alltt}
 liveVizDeposit (m, startX, startY, width, height, imageBuff, this, 
                   max\_image\_data);
\end{alltt}

You can also reduce floating-point image data using
 sum\_float\_image\_data or max\_float\_image\_data.


\section{Format of deposit image}

``imageBuff'' is run of bytes representing a rectangular portion
of the image.  This buffer represents image using a row-major format,
so 0-based pixel (x,y) (x increasing to the right, y increasing downward
in typical graphics fashion) is stored at array offset ``x+y*width''.

If the image is gray-scale (as determined by liveVizConfig, below), each pixel
is represented by one byte.  If the image is color, each pixel is represented
by 3 consecutive bytes representing red, green, and blue intensity.

If the image is floating-point, each pixel is represented by a single
`float', and after assembly colorized by calling the user-provided
routine below.  This routine converts fully assembled `float' pixels 
to RGB 3-byte pixels, and is called only on processor 0 after each
client request.

\begin{alltt}
extern "C"
void liveVizFloatToRGB(liveVizRequest &req, 
        const float *floatSrc, unsigned char *destRgb,
        int nPixels);
\end{alltt}


\section{liveViz Initialization}

liveViz library needs to be initialized before it can be used for 
visualization. For initialization follow the following steps
from your main chare:

\begin{enumerate}
\item Create your chare array (array proxy object 'a') with the entry 
      method 'functionName' (described above).
\item Create a CkCallback object ('c'), specifying 'functionName' as the 
      callback function.  This callback will be invoked whenever the
      client requests a new image.
\item Create a liveVizConfig object ('cfg').  LiveVizConfig takes a number
     of parameters, as described below.
\item Call liveVizInit (cfg, a, c).
\end{enumerate}

The liveVizConfig parameters are:
\begin{itemize}
  \item The first parameter is the pixel type to be reduced:
     \begin{itemize}
       \item ``false'' or liveVizConfig::pix\_greyscale means a greyscale image (1 byte per pixel).
       \item ``true'' or liveVizConfig::pix\_color means a color image (3 RGB bytes per pixel).
       \item liveVizConfig::pix\_float means a floating-point color image (1 float per pixel, can only be used with sum\_float\_image\_data or max\_float\_image\_data).
     \end{itemize}
   \item The second parameter is the flag ``serverPush'', which is currently unused. Set to true or false.     
   \item The third parameter is an optional 3D bounding box (type CkBbox3d).  If present, this puts the client into a 3D visualization mode.
\end{itemize}

A typical 2D, RGB, non-push call to liveVizConfig looks like this:
\begin{alltt}
   liveVizConfig cfg(true,false);
\end{alltt}

\section{Compilation}

A \charmpp{} program that uses liveViz must be linked with '-module liveViz'. 

Before compiling a liveViz program, the liveViz library may need to be compiled. 
To compile the liveViz library:
\begin{itemize}
\item go to .../charm/tmp/libs/ck-libs/liveViz
\item make
\end{itemize}


\section{Poll Mode}

Because liveVizDeposit, above, performs its image reduction over your array, 
you must ensure that your own reductions are not interleaved with the 
liveVizDeposits.  This is trivial if your program performs no reductions,
but if you do reductions you must somehow prevent this interleaving.
One method to do this is to buffer the liveViz request message until 
you can handle it safely.  Another method is to use liveVizPoll,
which creates a separate ``shadow'' array that liveViz uses to do
its reductions.

liveVizPoll must get control during the creation of your array,
so you call liveVizPollInit with a liveVizConfig object (just like
liveVizInit) and a CkArrayOptions object, like:

\begin{alltt}
        CkArrayOptions opts(nElements);
        liveVizPollInit(cfg,opts);
        CProxy_myArr arr=CProxy_myArr::ckNew(opts);
\end{alltt}

You get requests from liveVizPoll in a polling fashion.
The routine ``liveVizPoll'' returns a liveVizPollRequestMsg
if one is available.  If a non-NULL message is returned, you
must then call liveVizPollDeposit and repeat the call.

An idiomatic use of these routines is:
\begin{alltt}
	... in some user compute routine ...
        timestep++;
        liveVizPollRequestMsg *req;
        while (NULL!=(req=liveVizPoll(this,timestep))) {
                //...prepare image for request...
                liveVizPollDeposit(this,timestep,req,
                        startx,starty,sizex,sizey,img);
        }
\end{alltt}

A sample liveVizPoll server example is available at:
\begin{alltt}
           .../charm/pgms/charm++/ccs/liveViz/pollserver
\end{alltt}
