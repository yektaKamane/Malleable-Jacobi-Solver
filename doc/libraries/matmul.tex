\section{Introduction and Motivation}
The matrix multiplication library provides a simple way to add the capabilities
to do matrix-matrix multiplications to any two-dimensional chare arrays in
\charmpp. It is envisioned that in the future this will become part of a
larger \charmpp linear algebra (CLA) library.

The matrix multiplication library was designed as a way to add the capability
of doing the matrix-matrix multiplication to a user's already-existing 2D chare
array. It assumes that the user will evenly distribute their data among the
array elements. The library uses bound arrays to access this data locally in
order to minimize communication between the user's and the library's arrays.
The library provides both a ``2D'' and a ``3D'' algorithm to carry out the
multiplication. The ``2D'' algorithm is faster but requires more memory. The
``3D'' algorithm requires less memory and provides greater opportunity to
overlap communication and computation if the user's program has other work that
can be done while the multiplication is carried out.



\section{Compiling and Linking}
To user the matrix multiplication library, do
\begin{verbatim}
charmc CLA_Matrix.ci
charmc -c CLA_Matrix.C
\end{verbatim}
. This will make the necessary {\tt .decl.h} and {\tt .def.h} files as well
as the object file for the library.

In the user's main {\tt .ci} file, the user must specify
\begin{verbatim}
extern module CLA_Matrix;
\end{verbatim}
. If not, \charmpp will complain about missing modules.

The declarations of all classes and functions needed for compilation are in
{\tt CLA\_Matrix.h}.

For linking the application, a few things are needed. First, the user must link
{\tt CLA\_Matrix.o} into their application. Second, the user must pass the
{\tt -module CkMulticast} to {\tt charmc}. Finally, a BLAS library must be
linked to the application. In reality, only the {\tt dgemm} routine (and as
a result, usually {\tt xerbla}) is needed. Copies of {\tt dgemm} and
{\tt xerbla} which can be used are included in the package. However, it is
recommended that you link an optimized BLAS into your application to get
higher performance.


\section{Usage Description}
The library performs the operation $C \leftarrow \beta C + \alpha AB$. In
order to do
this, we first initialize the library telling it to which user array it should
bind the chare arrays used to represent $A, B,$ and $C$. When each element of
the user arrays bound to $A$ and $B$ is ready, it makes a library call telling
it to start the multiplication. The array bound to $C$ makes a similar call,
specifying a callback to be called then the operation is done. As each chunk
of $C$ is ready, the library executes the callback.

\section{Library Interface Details}

\subsection{Library Initialization}

To initialize the library, the user should call {\tt make\_multiplier}. It
has the following signature:
\begin{verbatim}
int make_multiplier(CLA_Matrix_interface *A, CLA_Matrix_interface *B,
 CLA_Matrix_interface *C, CProxy_ArrayElement bindA,
 CProxy_ArrayElement bindB, CProxy_ArrayElement bindC,
 int M, int K, int N, int m, int k, int n, int strideM, int strideK,
 int strideZ, CkCallback cbA, CkCallback cbB, CkCallback cbC,
 CkGroupID gid, int algorithm);
\end{verbatim}

\begin{itemize}

\item The {\tt CLA\_Matrix\_interface} class (described in the following
section) is used to interact with the matrix multiplication library. The
arguments {\tt A}, {\tt B}, and {\tt C} should point to different instances
of objects of this class.

\item The arguments {\tt bindA}, {\tt bindB}, and {\tt bindC} should be proxies
to which the libraries {\tt A}, {\tt B}, and {\tt C} arrays, respectively, will
be bound. There is no restriction as to whether these arrays must all be
different or the same.

\item The integers {\tt M}, {\tt K}, and {\tt N} refer to the size of the
global data matrices. The {\tt A} matrix is of size {\tt M x K}. The {\tt B}
matrix is of size {\tt K x N}. The {\tt C} matrix is of size {\tt M x N}.

\item The arguments {\tt m}, {\tt k}, and {\tt n} determine how many elements
of the global matrices each array element will hold. A ``typical'' chunk of
a matrix which has {\tt M} as a dimension will have {\tt m} elements. If
{\tt m} does not divide {\tt M}, the last element of the array along the given
dimension will have {\tt M mod m} elements. The above is the same for the
{\tt K} and {\tt k} as well as {\tt N} and {\tt n}.

\item The striding arguments are used to specify the stride at which elements
along a given dimension should be created. For example, if {\tt bindA} is a
dense matrix, {\tt strideM} and {\tt strideK} should both be $1$. If {\tt bindC}
has elements at $(0, 0), (0, 2), (0, 4), \ldots$, {\tt strideN} should be $2$.
Note that although each of the dimensions is shared by two (potentially)
distinct arrays, there is no support for them to have different strides.

\item Since the library takes advantage of bound arrays to access memory
directly between the user and library objects, it is necessary to make sure
the library is properly initialized before it is used. As the {\tt A}, {\tt B},
and {\tt C} chare arrays finish initializing all their elements, they will
make callbacks to {\tt cbA}, {\tt cbB}, and {\tt cbC}, respectively. These
can all be the same, but this is not checked, so there will be three calls made
to it.

\item The {\tt gid} argument is a {\tt CkGroupID} identifier which should be
used by the library to do its collective communications.

\item The {\tt algorithm} argument specifies which algorithm the library should
use to carry out the multiplication. The valid options are {\tt MM\_ALG\_2D}
for the ``2D'' algorithm, and {\tt MM\_ALG\_3D} for the ``3D'' algorithm.

\end{itemize}

If the initialization success, zero is retuned. Otherwise, a negative number
is returned.

\subsection{Performing Multiplications}

The user interacts with the library through {\tt CLA\_Matrix\_interface}
objects. Their constructor takes no arguments. A call to {\tt make\_multiplier}
(described below) will properly initialize them. The class has two methods
the user needs to use. First, is the {\tt multiply} method. It has the
following signature:
\begin{verbatim}
void multiply(double alpha, double beta, double *data, void (*fptr) (void *),
              void *usr_data, int x, int y);
\end{verbatim}
Each element of the user's $A, B,$ and $C$ arrays must call this method to
perform the multiplication.
\begin{itemize}

\item The parameters {\tt alpha} and {\tt beta} correspond to $\alpha$ and
$\beta$ in $C = \beta C + \alpha AB$. The same value must be passed for each
of these two parameters at each elemnts of $A, B,$ and $C$.

\item The paremeter {\tt data} specifies where the data to be mutiplier is
held. This is a two-dimensional array stored in a one-dimensional array. The
size of the array is determined at creation time (based on user paremeters)
and does not have to be specified at this point. For $A$ and $B$ {\tt data}
should contain the matrices to be multiplied. For $C$, it is the destination
where the result will be stored (and if $\beta \neq 0$, the data which will
be multiplied by $\beta$ and added to $\alpha AB$).

\item The {\tt fptr} paremeter specifies the
callback which the library calls (at array $C$ when the computation is
complete. When it is called, it passes {\tt usr\_data} to it. Only
the elements of the $C$ array must specify a non-null value for {\tt fptr}.

\item The values of {\tt x} and {\tt y} specify the coordinates of the calling
element in the users chare array (these should always be {\tt thisIndex.x} and
{\tt thisIndex.y}, respectively).

\end{itemize}

The second function of the {\tt CLA\_Matrix\_interface} objects is the
{\tt sync} method. This should be called at each element of the array when it
is ready to migrate. It takes as arguments two intergers, {\tt x} and {\tt y},
which should always be {\tt thisIndex.x} and {\tt thisIndex.y}, respectively.
Note that migration is currently only supported for the ``2D'' algorithm.

\section{Example}
A complete example can be found in {\tt projects/matrix\_multiply/CLA\_Matrix}
in CVS. What follows are some of the more important files from that example.

In the users {\tt .ci} file:
\begin{verbatim}
mainmodule matTest {
  extern module CLA_Matrix; // make sure to include, or get Charm++ errors
  ...
  readonly CProxy_tester dataProxyA;
  readonly CProxy_tester dataProxyB;
  readonly CProxy_tester dataProxyC;
  ...
  mainchare Main {
    ...
    entry void chunk_inited(); // callback to know library is ready
  };
  ...
  array [2D] tester{
    ...
    entry void multiply(double alpha, double beta); // start multiplication
  };
};
\end{verbatim}

In the main function:
\begin{verbatim}
...
/* create interface objects, data proxies*/
CLA_Matrix_interface matA, matB, matC;

dataProxyA = CProxy_tester::ckNew();
dataProxyB = CProxy_tester::ckNew();
dataProxyC = CProxy_tester::ckNew();

/* make multicast manager, callback */
CkGroupID gid = CProxy_CkMulticastMgr::ckNew();
CkCallback *cb = new CkCallback(CkIndex_Main::chunk_inited(), mainProxy);

/* size and stride variable determined earlier, ready to init library */
make_multiplier(&matA, &matB, &matC, dataProxyA, dataProxyB, dataProxyC, M, K,
  N, m, k, n, M_stride, K_stride, N_stride, *cb, *cb, *cb, gid, MM_ALG_2D);

...
/* create tester objects */
for(i = ...)
  for(j = ...)
    dataProxyA(i, j).insert(...);
dataProxyA.doneInserting();
...
\end{verbatim}

When the library is ready, tell the {\tt tester} (user) objects to multiply:
\begin{verbatim}
void chunk_inited(){
  /* make sure all three proxies are ready */
  if(++msg_received != 3)
    return;
  dataProxyA.multiply(1, 0);
  dataProxyB.multiply(1, 0);
  dataProxyC.multiply(1, 0);
}
\end{verbatim}

The user's objects start the multiplication:
\begin{verbatim}
void tester::multiply(double alpha, double beta){
  /* "matrix" is the CLA_Matrix_interface object created in main. */
  /* pass "this" as the user_data argument so that we can dereference it
   * in done_cb below. */
  matrix.multiply(alpha, beta, data, tester::done_cb, (void*) this,
   thisIndex.x, thisIndex.y);
}
\end{verbatim}

The {\tt C} {\tt tester} object will be notified when the multiplication
has completed.
\begin{verbatim}
class tester {
  ...
  static void done_cb(void *obj){
      ((tester*) obj)->round_done();
  }
  void round_done(){
    CkPrintf("[%d %d] has its chunk of C ready.\n", thisIndex.x, thisIndex.y);
    // continue with user's code, doing something useful
    ...
  }
  ...
};
\end{verbatim}
