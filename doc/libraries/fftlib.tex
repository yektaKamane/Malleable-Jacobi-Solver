
\section{Introduction and Motivation}
The 3D FFT library provides an interface to do paralle FFT computation
in a scalable fashion. 

The parallelization is achieved by splitting the 3D transform into
multiple phases. There are two possibilities for doing the splitting:
One is dividing the data space (over which the fft is to be performed)
into a set of slabs (figure 1). Each slab is essentially a collection
of planes). First, 2D FFTs are done over the planes in the slab. Then
a distributed 'transform' will send the data to destination so that
fft in the third direction is performed. This approach takes two
computation phases and one 'transform' phase. The second way for
splitting is dividing the data into collections of pencils. First, 1D
FFTs are computed over the pencils; then a 'transform' is performed
and 1D FFTs are done over second dimention; again a 'transform' is
performed and FFTs are computed over the last dimension. So this
approach takes three computation phases and two 'transform' phases. In
first approach, the parallelism is limited by the number of
planes.While in second approach, it's limited by the number of
pencils. So the second approach provides finer grained parallelism and
it's possible to perform better when the number of processing units is
larger than the number of planes.

\section{Compilation and Execution}

To install the FFT library, you will need to have charm++ installed in
you system. You can follow the Charm++ manual to do that. Also you
will need to have FFTW (version 2.1.5) installed. FFTW can be
downloaded from http://www.fftw.org.

The FFT library source is at
your-charm-dir/src/libs/ck-libs/fftlib. Before installation of the
library, make sure that the path for FFTW library is consistent with
your FFTW installation. Then cd to your-charm-dir/tmp, and do 'make
fftlib'. To compile a program using the fftlib, pass the '-lfftlib
-L(your-fftwlib-dir) -lfftw' flag to charmc.

\section{Library Initialization and Data Format} 
To initialize the library, user will need to construct a data struct and pass it to the library. 

For plane-based version, the struct is called: NormalFFTinfo . And the
constructor of 'NormalFFTinfo' is defined as:

\begin{alltt}
        NormalFFTinfo(CProxy_NormalSlabArray &srcProxy, CProxy_NormalSlabArray &destProxy,
                      int srcDim[2], int destDim[2], int isSrc, complex *dptr, 
                      int srcPlanesPerSlab=1, int destPlanesPerSlab=1)

        Where: 
        CProxy_NormalSlabArray &srcProxy : proxy for source charm array 
        CProxy_NormalSlabArray &destProxy : proxy for destination charm array 
        int srcDim[2] : FFT plane data dimension at source array (*)
        int destDim[2] : FFT plane data dimension at destination array ( srcDim[1] must equal to destDim[0].) (*) 
        int isSrcArray : whether this array is source (1) or destination (0)
        complex *dataptr : pointer to FFT data 
        int srcPlanesPerSlab : number of planes in each slab at source array, default value is 1 (**) 
        int destPlanesPerSlab : number of planes in each slab at destination array, default value is 1 (**)

          * Data layout : The multi-dimensional FFT data are supposed
            to be stored in a contiguous one-dimensional array in
            row-major order. For example, in source array, data is
            {\it srcPlanesPerSlab} planes, each plane is {\it
            srcSize[0]} rows of size {\it srcSize[0]} numbers. Similar
            rules apply to destination side.


          ** Currently, srcPlanesPerSlab/destPlanesPerSlab has to be
             the same across all array elements.

          *** Total data size can be calculated by:
              srcPlanesPerSlab*srcDim[0]*srcDim[1] at source array, and
              destPlanesPerSlab*destDim[0]*destDim[1] at destination array
 
\end{alltt}

%{\it put a figure here with reference of above parameters.}
%\caption doing a {\it nz*ny*nz} size FFT, if data layout at source side is x then y then z, and at destination is z then x then y,
%srcDim[] = {ny, nx}, destDim={nx, nz}


For pencil-based version, the struct is called: LineFFTinfo.

\begin{alltt} 
        LineFFTinfo(CProxy_NormalLineArray &xProxy, 
                    CProxy_NormalLineArray &yProxy, 
                    CProxy_NormalLineArray &zProxy, 
                    int size[3], int isSrcArray, complex *dataptr, 
                    int srcPencilsPerSlab=1, int destPencilsPerSlab=1) 

        where: 
        CProxy_NormalSlabArray &xProxy : proxy for first charm array 
        CProxy_NormalSlabArray &yProxy : proxy for second charm array 
        CProxy_NormalSlabArray &zProxy : proxy for third charm array 
        int size[3] : FFT plane data dimension (*)
        int isSrcArray : whether this array is source (1) or intermediate (2) or  destination (0)
        complex *dataptr : pointer to FFT data 
        int srcPencilsPerSlab : number of pencils in each slab at source array, default value is 1
        int destPencilsPerSlab : number of pencils in each slab at destination array, default value is 1

          *data layout : pencils in the three arrays are of size {\it
           size[0]/size[1]/size[2]}. And if there is more than one
           pencil per slab, the other dimension is the dimension for
           pencils in the next array.

\end{alltt}

%{\it put a figure here with reference of above parameters.}
%\caption doing a {\it nz*ny*nz} size FFT,


In both cases, data is deposited by passing in a pointer to the data
field, and the pointer will be stored in 'complex *dataptr' in the
struct. Memory allocation and initializtion of data field needs to be
done by user before pointer is passed in. The library doesn't allocate
any memory for data field. Also note that FFT's done internally in the
library are in-place FFTs, which means that data field will be
overwriten with results.

\section{Library Interfaces}
There are two types of interfaces provided by the library: Charm++
based and AMPI based. 

\subsection{Charm++ interface}

The Charm++ interface is the raw interface of the library and slightly
more difficult to use but gives more flexibility. To use the charm++
based library, user has to create their own charm arrays which derive
from predefined arrays in library. By overiding default methods, user
can add in additional functions.


For the plane-based library, there are several relevant member
functions: 'doFFT', 'doIFFT', 'doneFFT' and 'doneIFFT'. 'doFFT' and
'doIFFT' need to be called to start the computation. 'doneFFT' and
'doneIFFT' are callback functions, and they need to be
inheritated. 

The sample code below should shed more light on this. For complex
sample programs, refer to file under
your-charm-dir/pgms/charm++/fftdemo/.



(sample code here)
\begin{alltt}

.ci File:  
mainmodule testpencil {
        extern module fftlib;
        readonly CProxy_myXLines xlinesProxy;
        readonly CProxy_myYLines ylinesProxy;
        readonly CProxy_myZLines zlinesProxy;
 
        mainchare main {
                entry main();
        };
        array [2D] myXLines:XLines {
                entry myXLines(LineFFTinfo &info);
                entry void doIt();
        };
        array [2D] myYLines:YLines {
                entry myYLines(LineFFTinfo &info);
        };
        array [2D] myZLines:ZLines {
                entry myZLines(LineFFTinfo &info);
        };
};


.C File:

...
class myXLines: public XLines {
 public:
  myXLines(CkMigrateMessage *m):XLines(m) {}
  myXLines(LineFFTinfo &i):XLines(i) {
    ... // Your stuff here
  }
 
  void doIt() {
    ... // Your stuff here
    doTranspose();  // Inherited method from predefined library class
    ... // Your stuff here
  }
};

// Similarly for myYLines and myZLines
...

main::main(CkArgMsg *m)
{
  ...

  xlinesProxy = CProxy_myXLines::ckNew();  // Create the new arrays
  ylinesProxy = CProxy_myYLines::ckNew();
  zlinesProxy = CProxy_myZLines::ckNew();

  zlinesProxy.setReductionClient(reductionHandler, (void *)NULL);

  ...
                                                                                
  for (z = 0; z < sizeZ; z++) {
    for (y = 0; y < sizeY; y++) {
      xlinesProxy(y, z).insert(info, numPes);  // Dynamically Insert the arrays 
    }
    base += numProcForSizeZ;
  }
  xlinesProxy.doneInserting();
  
  // Similarly for ylinesProxy and zlinesProxy
  ...

  xlinesProxy.doIt();  // Start the FFT compuation

  ...
}

\end{alltt}

\subsection {AMPI Interface}
The MPI-like interface aims at easy migration of MPI program to
use the library.

The AMPI interface has five functions:
\begin{itemize}
\item init\_fftlib - initialization of library. This will create
charm++ level data structures, prepare for FFT computation.
\item start\_fft - start the FFT. 
\item wait\_fft - wait for the FFT to finish. 
\item start\_ifft - start the inverse FFT. (similar as start\_fft)
\item wait\_ifft - wait for the inverse FFT to finish. ( similar as wait\_fft)
\end{itemize}

(sample code here)
\begin{alltt}
\end{alltt}

