\section{Introduction}

\charmpp\ is an explicitly parallel language based on \CC\ with a runtime
library for supporting parallel computation called the Charm kernel.  It
provides a clear separation between sequential and parallel objects.  The
execution model of \charmpp\ is message driven, thus helping one write programs
that are latency-tolerant.  \charmpp\ supports dynamic load balancing while
creating new work as well as periodically, based on object migration.  Several
dynamic load balancing strategies are provided.  \charmpp\ supports both
irregular as well as regular, data-parallel applications.  It is built on top of the
{\sc Converse} interoperable runtime system for parallel programming.

Currently the parallel platforms supported by \charmpp\ are the BlueGene/L,BlueGene/P, PSC
Lemieux, IBM SP, SGI Origin2000, Cray XT3/4, Cray X1, Cray T3E, a single workstation or a
network of workstations from Sun Microsystems (Solaris), IBM RS-6000 (AIX) SGI
(IRIX 5.3 or 6.4), HP (HP-UX), Intel x86 (Linux, Windows 98/2000/XP), Intel
IA64, Intel x86\_64, multicore x86 and x86\_64, and Apple Mac. The communication protocols and infrastructures supported
by \charmpp\ are UDP, TCP, Myrinet, Infiniband, Quadrics Elan, Shmem, MPI and
NCSA VMI.  \charmpp\ programs can run without changing the source on all these
platforms.  Please see the \charmpp{}/\converse{} Installation and
Usage \htmladdnormallink{Manual}{http://charm.cs.uiuc.edu/manuals/html/install/manual.html}
for details about installing, compiling and running \charmpp\ programs.

\subsection{\charmpp\ Execution Model}

A \charmpp\ program consists of a number of \charmpp\ objects distributed
across the available number of processors. Thus, the basic unit of parallel
computation in \charmpp\ programs is the {\em chare}\index{chare}, a \charmpp\
object that can be created on any available processor and can be accessed from
remote processors.  A \index{chare}chare is similar to a process, an actor, an
ADA task, etc.  \index{chare}Chares are created dynamically, and many chares
may be active simultaneously.  Chares send \index{message}{\em messages} to one
another to invoke methods asynchronously.  Conceptually, the system maintains a
``work-pool'' consisting of seeds for new \index{chare}chares, and
\index{message}messages for existing chares. The Charm++ runtime system ({\em
Charm RTS}) may pick multiple items, non-deterministically, from this pool
and execute them.  

Methods of a \index{chare}chare that can be remotely invoked are called
\index{entry method}{\em entry} methods.  Entry methods may take marshalled
parameters, or a pointer to a message object.  Since \index{chare}chares can
be created on remote processors, obviously some constructor of a chare needs
to be an entry method.  Ordinary entry methods\footnote{``Threaded'' or
``synchronous'' methods are different.} are completely non-preemptive--
\charmpp\ will never interrupt an executing method to start any other work,
and all calls made are asynchronous.

\charmpp\ provides dynamic seed-based load balancing. Thus location (processor
number) need not be specified while creating a remote \index{chare}chare. The
Charm RTS will then place the remote chare on a least loaded processor. Thus
one can imagine chare creation as generating only a seed for the new chare,
which may {\em take root} on the most {\em fertile} processor. Charm RTS
identifies a \index{chare}chare by a {\em ChareID}.  Since user code does not
need to name a chares' processor, chares can potentially migrate from one
processor to another.  (This behavior is used by the dynamic load-balancing
framework for chare containers, such as arrays.)

Other \charmpp\ objects are collections of chares. They are: {\em
chare-arrays}, \index{group}{\em chare-groups}, and \index{nodegroup}{\em
chare-nodegroups}, referred to as {\em arrays}, {\em groups}, and {\em
nodegroups} throughout this manual. An array is a collection of arbitrary
number of migratable chares, indexed by some index type, and mapped to
processors according to a user-defined map group. A group (nodegroup) is a
collection of chares, one per processor (SMP node), that is addressed using
a unique system-wide name.

Every \charmpp\ program must have at least one \kw{mainchare}.  Each
\kw{mainchare} is created by the system on processor 0 when the \charmpp\
program starts up.  Execution of a \charmpp\ program begins with the Charm
Kernel constructing all the designated \kw{mainchare}s.  For a \kw{mainchare} named X, execution starts at constructor X() or X(CkArgMsg *) which are equivalent.
Typically, the
\kw{mainchare} constructor starts the computation by creating arrays, other
chares, and groups.  It can also be used to initialize shared \kw{readonly}
objects.

The only method of communication between processors in \charmpp\ is
asynchronous \index{entry method} entry method invocation on remote chares.
For this purpose, Charm RTS needs to know the types of
\index{chare}chares in the user program, the methods that can be invoked on
these chares from remote processors, the arguments these methods take as
input etc. Therefore, when the program starts up, these user-defined
entities need to be registered with Charm RTS, which assigns a unique
identifier to each of them. While invoking a method on a remote object,
these identifiers need to be specified to Charm RTS. Registration of
user-defined entities, and maintaining these identifiers can be cumbersome.
Fortunately, it is done automatically by the \charmpp\ interface translator.
The \charmpp\ interface translator generates definitions for {\em proxy}
objects. A proxy object acts as a {\em handle} to a remote chare. One
invokes methods on a proxy object, which in turn carries out remote method
invocation on the chare.

In addition, the \charmpp\ interface translator provides ways to enhance the
basic functionality of Charm RTS using user-level threads and futures. These
allow entry methods to be executed in separate user-level threads.  These
\index{threaded} {\em threaded} entry methods may block waiting for data by
making {\em synchronous} calls to remote object methods that return results in
messages.

\charmpp\ program execution is terminated by the \kw{CkExit} call.  Like the
\kw{exit} system call, \kw{CkExit} never returns. The Charm RTS ensures
that no more messages are processed and no entry methods are called after a
\kw{CkExit}. \kw{CkExit} need not be called on all processors; it is enough
to call it from just one processor at the end of the computation.

The following sections provide detailed information about various features of the
\charmpp\ programming system.\footnote{For a description of the underlying design
philosophy please refer to the following papers :\\
    L. V. Kale and Sanjeev Krishnan,
    {\em ``\charmpp : Parallel Programming with Message-Driven Objects''},
    in ``Parallel Programming Using \CC'',
    MIT Press, 1995. \\
    L. V. Kale and Sanjeev Krishnan,
    {\em ``\charmpp : A Portable Concurrent Object Oriented System
    Based On \CC''},
    Proceedings of the Conference on Object Oriented Programming,
    Systems, Languages and Applications (OOPSLA), September 1993.
}.

