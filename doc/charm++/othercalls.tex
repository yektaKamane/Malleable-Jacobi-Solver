\subsection{\kw{initcall} routines}
\index{initcall}
\label{initcall}
\experimental{}
Some registration routines need be executed exactly once
on every processor before the computation begins.
By declaring a regular \CC\ subroutine \index{initcall}
\kw{initcall} in the .ci file, you ask \charmpp to execute 
the routine exactly once on every node before the
computation begins.

\begin{alltt}
module foo \{
    initcall void fooGlobalInit(void);
    chare bar \{
        ...
        initcall void barInit(void);
    \};
\};
\end{alltt}

This code will execute the routines \uw{fooGlobalInit} and
\uw{bar::barInit} before the main computation starts.
These routines should only do registration, not computation--
use a mainchare, which gets executed on only one processor,
to begin the computation.

\subsection{Other Calls}

\label{other Charm++ calls}

The following calls provide information about the machines upon which the
parallel program is executing.  Processing Element refers to a single CPU.
Node refers to a single machine-- a set of processing elements which share
memory (i.e. an address space).  Processing Elements and Nodes are numbered,
starting from zero.

Thus if a parallel program is executing on one 4-processor workstation and one
2-processor workstation, there would be 6 processing elements (0, 1 ,2, 3, 4,
and 5) but only 2 nodes (0 and 1).  A given node's processing elements are
numbered sequentially.

\function{int CkNumPes()} \index{CkNumPes}
\desc{returns the total number of processors, across all nodes.}

\function{int CkMyPe()} \index{CkMyPe}
\desc{returns the processor number on which the call was made.}

\function{int CkMyRank()} \index{CkMyRank}
\desc{returns the rank number of the processor on which the call was made.
Processing elements within a node are ranked starting from zero.}

\function{int CkMyNode()} \index{CkMyNode}
\desc{returns the address space number (node number) on which the call was made.}

\function{int CkNumNodes()} \index{CkMyNodes}
\desc{returns the total number of address spaces.}

\function{int CkNodeFirst(int node)} \index{CkNodeFirst}
\desc{returns the processor number of the first processor in this address space.}

\function{int CkNodeSize(int node)} \index{CkNodeSize}
\desc{returns the number of processors in the address space on which the call was made.}

\function{int CkNodeOf(int pe)} \index{CkNodeOf}
\desc{returns the node number on which the call was made.}

\function{int CkRankOf(int pe)} \index{CkRankOf}
\desc{returns the rank of the given processor within its node.}

The following calls provide commonly needed functions.

\function{void CkAbort(const char *message)} \index{CkAbort}
\desc{Cause the program to abort, printing the given error message.}

\function{void CkExit()} \index{CkExit}
\desc{This call informs the Charm kernel that computation on all processors
should terminate.  After the currently executing entry method completes, no
more messages or entry methods will be called.  \kw{CkExit} should be the last
call of the entry method from which it was called.}

\function{double CkCpuTimer()} \index{CkCpuTimer} \index{timers}
\desc{Returns the current value of the system timer in seconds. The system
timer is started when the program begins execution. This timer measures process
time (user and system).}

\function{double CkWallTimer()} \index{CkWallTimer} \index{timers}
\desc{Returns the elapsed time in seconds since the program has started from the wall
clock timer.}

\function{double CkTimer()} \index{CkTimer} \index{timers}
\desc{This is an alias for either \kw{CkWallTimer} on dedicated machines (such as ASCI Red) or 
\kw{CkCpuTimer} for machines with multiple user processes per CPU (such as workstation cluster.)}

