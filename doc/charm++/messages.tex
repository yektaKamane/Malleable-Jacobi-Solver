\subsection{Messages}

\label{messages}
Although \charmpp supports automated parameter marshalling for entry methods,
you can also manually handle the process of packing and unpacking parameters by
using messages. By using messages, you can potentially improve performance by
avoiding unnecessary copying

A message encapsulates all the parameters sent to an
entry method.  Since the parameters are already encapsulated,
sending messages is often more efficient than parameter marshalling.
In addition, messages are easier to queue and store on the
receive side.

The largest difference between parameter marshalling and messages
is that entry methods {\em keep} the messages passed to them.
Thus each entry method must be passed a {\em new} message.
On the receiving side, the entry method must either store the
passed message or explicitly {\em delete} it, or else the message
will never be destroyed, wasting memory.

Several kinds of message are available.
Regular \charmpp{} messages are objects of
\textit{fixed size}. One can have messages that contain pointers or variable
length arrays (arrays with sizes specified at runtime) and still have these
pointers to be valid when messages are sent across processors, with some
additional coding.  Also available is a mechanism for assigning
\textit{priorities} to messages that applies all kinds of messages.
A detailed discussion of priorities appears later in this section.

Like all other entities involved in asynchronous method invocation, messages
need to be declared in the {\tt .ci} file. In the {\tt .ci} file (the
interface file), a message is declared as: 

\begin{alltt}
 message MessageType;
\end{alltt}

%A message that contains variable length arrays is declared as:
%
%\begin{alltt}
% message MessageType \{
%   type1 var_name1[];
%   type2 var_name2[];
%   type3 var_name3[];
%\};
%\end{alltt}
%
If the name of the message class is \uw{MessageType}, the class must inherit 
publicly from a class whose name is \uw{CMessage\_MessageType}. This class
is generated by the charm translator. Then message definition has the form:

\begin{alltt}
 class MessageType : public CMessage_MessageType \{
    // List of data and function members as in \CC
 \};
\end{alltt}


\subsubsection{Message Creation and Deletion}

\label{memory allocation}

\index{message}Messages are allocated using the \CC\ \kw{new} operator:

\begin{alltt}
 MessageType *msgptr =
  new [(int sz1, int sz2, ... , int priobits=0)] MessageType[(constructor arguments)];
\end{alltt}

The optional arguments to the new operator are used when allocating messages
with variable length arrays or \kw{prioritized} messages. \uw{sz1, sz2, ...}
denote the size (in appropriate units) of the memory blocks that need to be
allocated and assigned to the pointers that the message contains. The
\uw{priobits} argument denotes the size of a bitfield (number of bits) that
will be used to store the message priority.   

For example, to allocate a message whose class declaration is:

\begin{alltt}
class Message : public CMessage_Message \{
  // .. fixed size message
  // .. data and method members
\};
\end{alltt}

do the following:

\begin{alltt}
Message *msg = new Message;
\end{alltt}

To allocate a message whose class declaration is:

\begin{alltt}
class VarsizeMessage : public CMessage_VarsizeMessage \{
 public:
  int *firstArray;
  double *secondArray;
\};
\end{alltt}

do the following:

\begin{alltt}
VarsizeMessage *msg = new (10, 20) VarsizeMessage;
\end{alltt}

This allocates a \uw{VarsizeMessage}, in which \uw{firstArray} points to an
array of 10 ints and \uw{secondArray} points to an array of 20 doubles.  This
is explained in detail in later sections. 

To add a \index{priority}priority bitfield to this message, 

\begin{alltt}
VarsizeMessage *msg = new (10, 20, sizeof(int)*8) VarsizeMessage;
\end{alltt}

Note, you must provide number of bits which is used to store the priority as
the \uw{priobits} parameter. The section on prioritized execution describes how
this bitfield is used.

In Section~\ref{message packing} we explain how messages can contain arbitrary
pointers, and how the validity of such pointers can be maintained across
processors in a distributed memory machine.

When a message \index{message} is sent to a \index{chare}chare, the programmer
relinquishes control of it; the space allocated to the message is freed by the
system.  When a message is received at an entry point it is not freed by the
runtime system.  It may be reused or deleted by the programmer.  Messages can
be deleted using the standard \CC{} \kw{delete} operator.  

There are no limitations of the methods of message classes except that the
message class may not redefine operators \texttt{new} or \texttt{delete}.


\subsubsection{Messages with Variable Length Arrays}

\label{varsize messages}
\index{variable size messages}
\index{varsize message}

An ordinary message in \charmpp\ is a fixed size message that is allocated
internally with an envelope which encodes the size of the message. Very often,
the size of the data contained in a message is not known until runtime. One can
use packed\index{packed messages} messages to alleviate this problem.  However,
it requires multiple memory allocations (one for the message, and another for
the buffer.) This can be avoided by making use of a \emph{varsize} message.
In \emph{varsize} messages, the space required for these variable length arrays
is allocated with the message such that it is contiguous to the message.

Such a message is declared as 

\begin{alltt}
 message mtype \{
   type1 var_name1[];
   type2 var_name2[];
   type3 var_name3[];
 \};
\end{alltt}

in \charmpp\ interface file. The class \uw{mtype} has to inherit from
\uw{CMessage\_mtype}. In addition, it has to contain variables of corresponding
names pointing to appropriate types. If any of these variables (data members)
are private or protected, it should declare class \uw{CMessage\_mtype} to be a
``friend'' class. Thus the \uw{mtype} class declaration should be similar to:

\begin{alltt}
class mtype : public CMessage_mtype \{
 private:
   type1 *var_name1;
   type2 *var_name2;
   type3 *var_name3;
   friend class CMessage_mtype;
\};
\end{alltt}

\small
\hrule

\noindent\textbf{An Example}

Suppose a \charmpp\ message contains two variable length arrays of types
\texttt{int} and \texttt{double}:

\begin{alltt} 
class VarsizeMessage: public CMessage_VarsizeMessage \{
  public:
    int lengthFirst;
    int lengthSecond;
    int* firstArray;
    double* secondArray;
    // other functions here
\};
\end{alltt}

Then in the \texttt{.ci} file, this has to be declared as: 

\begin{alltt}
message VarsizeMessage \{
  int firstArray[];
  double secondArray[];
\};
\end{alltt}

We specify the types and actual names of the fields that
contain variable length arrays. The dimensions of these arrays are NOT
specified in the interface file, since they will be specified in the
constructor of the message when message is created. In the {\tt .h} or {\tt .C}
file, this class is declared as:

\begin{alltt} 

class VarsizeMessage : public CMessage_VarsizeMessage \{ 
  public: 
    int lengthFirst;
    int lengthSecond;
    int* firstArray;
    double* secondArray;
    // other functions here
\};
\end{alltt}

The interface translator generates the \uw{CMessage\_VarsizeMessage} class,
which contains code to properly allocate, pack and unpack the
\uw{VarsizeMessage}.


One can allocate messages of the \uw{VarsizeMessage} class as follows:

\begin{alltt}
// firstArray will have 4 elements
// secondArray will have 5 elements 
VarsizeMessage* p = new(4, 5, 0) VarsizeMessage;
p->firstArray[2] = 13;     // the arrays have already been allocated 
p->secondArray[4] = 6.7; 
\end{alltt}

Another way of allocating a varsize message is to pass a \uw{sizes} in an array
instead of the parameter list. For example,

\begin{alltt}
int sizes[2];
sizes[0] = 4;               // firstArray will have 4 elements
sizes[1] = 5;               // secondArray will have 5 elements 
VarsizeMessage* p = new(sizes, 0) VarsizeMessage;
p->firstArray[2] = 13;     // the arrays have already been allocated 
p->secondArray[4] = 6.7; 
\end{alltt}

\hrule
\normalsize

No special handling is needed for deleting varsize messages.

\subsubsection{Message Packing}

\label{message packing}
\index{message packing}

The \charmpp{} interface translator generates implementation for three static
methods for the message class \uw{CMessage\_mtype}. These methods have the
prototypes:

\begin{alltt}
    static void* alloc(int msgnum, size_t size, int* array, int priobits);
    static void* pack(mtype*);
    static mtype* unpack(void*);
\end{alltt}

One may choose not to use the translator-generated methods and may override
these implementations with their own \uw{alloc}, \uw{pack} and \uw{unpack}
static methods of the \uw{mtype} class.  The \kw{alloc} method will be called
when the message is allocated using the \CC\ \kw{new} operator. The programmer
never needs to explicitly call it.  Note that all elements of the message are
allocated when the message is created with \kw{new}. There is no need to call
\kw{new} to allocate any of the fields of the message. This differs from a
packed message where each field requires individual allocation. The \kw{alloc}
method should actually allocate the message using \kw{CkAllocMsg}, whose
signature is given below:

\begin{alltt}
void *CkAllocMsg(int msgnum, int size, int priobits); 
\end{alltt}  


For varsize messages, these static methods \texttt{alloc}, \texttt{pack}, and 
\texttt{unpack} are
generated by the interface translator.  For example, these
methods for the \kw{VarsizeMessage} class above would be similar to:

\begin{alltt}
// allocate memory for varmessage so charm can keep track of memory
static void* alloc(int msgnum, size_t size, int* array, int priobits)
\{
  int totalsize, first_start, second_start;
  // array is passed in when the message is allocated using new (see below).
  // size is the amount of space needed for the part of the message known
  // about at compile time.  Depending on their values, sometimes a segfault
  // will occur if memory addressing is not on 8-byte boundary, so altered
  // with ALIGN8
  first_start = ALIGN8(size);  // 8-byte align with this macro
  second_start = ALIGN8(first_start + array[0]*sizeof(int));
  totalsize = second_start + array[1]*sizeof(double);
  VarsizeMessage* newMsg = 
    (VarsizeMessage*) CkAllocMsg(msgnum, totalsize, priobits);
  // make firstArray point to end of newMsg in memory
  newMsg->firstArray = (int*) ((char*)newMsg + first_start);
  // make secondArray point to after end of firstArray in memory
  newMsg->secondArray = (double*) ((char*)newMsg + second_start);

  return (void*) newMsg;
\}

// returns pointer to memory containing packed message
static void* pack(VarsizeMessage* in)
\{
  // set firstArray an offset from the start of in
  in->firstArray = (int*) ((char*)in->firstArray - (char*)in);
  // set secondArray to the appropriate offset
  in->secondArray = (double*) ((char*)in->secondArray - (char*)in);
  return in;
\}

// returns new message from raw memory
static VarsizeMessage* VarsizeMessage::unpack(void* inbuf)
\{
  VarsizeMessage* me = (VarsizeMessage*)inbuf;
  // return first array to absolute address in memory
  me->firstArray = (int*) ((size_t)me->firstArray + (char*)me);
  // likewise for secondArray
  me->secondArray = (double*) ((size_t)me->secondArray + (char*)me);
  return me;
\}
\end{alltt}

The pointers in a varsize message can exist in two states.  At creation, they
are valid \CC\ pointers to the start of the arrays.  After packing, they become
offsets from the address of the pointer variable to the start of the pointed-to
data.  Unpacking restores them to pointers. 

\subsubsection{Custom Packed Messages}

\index{packed messages}

In many cases, a message must store a {\em non-linear} data structure using
pointers.  Examples of these are binary trees, hash tables etc. Thus, the
message itself contains only a pointer to the actual data. When the message is
sent to the same processor, these pointers point to the original locations,
which are within the address space of the same processor. However, when such a
message is sent to other processors, these pointers will point to invalid
locations.

Thus, the programmer needs a way to ``serialize'' these messages
\index{serialized messages}\index{message serialization}{\em only if} the
message crosses the address-space boundary.  \charmpp{} provides a way to do
this serialization by allowing the developer to override the default
serialization methods generated by the \charmpp{} interface translator.
Note that this low-level serialization has nothing to do with parameter
marshalling or the PUP framework described later.

Packed messages are declared in the {\tt .ci} file the same way as ordinary
messages:

\begin{alltt}
message PMessage;
\end{alltt}

Like all messages, the class \uw{PMessage} needs to inherit from
\uw{CMessage\_PMessage} and should provide two {\em static} methods: \kw{pack}
and \kw{unpack}. These methods are called by the \charmpp\ runtime system, when
the message is determined to be crossing address-space boundary. The prototypes
for these methods are as follows:

\begin{alltt}
static void *PMessage::pack(PMessage *in);
static PMessage *PMessage::unpack(void *in);
\end{alltt}

Typically, the following tasks are done in \kw{pack} method:

\begin{itemize}

\item Determine size of the buffer needed to serialize message data.

\item Allocate buffer using the \kw{CkAllocBuffer} function. This function
takes in two parameters: input message, and size of the buffer needed, and
returns the buffer.

\item Serialize message data into buffer (alongwith any control information
needed to de-serialize it on the receiving side.

\item Free resources occupied by message (including message itself.)  

\end{itemize}

On the receiving processor, the \kw{unpack} method is called. Typically, the
following tasks are done in the \kw{unpack} method:

\begin{itemize}

\item Allocate message using \kw{CkAllocBuffer} function. {\em Do not
use \kw{new} to allocate message here. If the message constructor has
to be called, it can be done using the in-place \kw{new} operator.}

\item De-serialize message data from input buffer into the allocated message.

\item Free the input buffer using \kw{CkFreeMsg}.

\end{itemize}

Here is an example of a packed-message implementation:

\begin{alltt}
// File: pgm.ci
mainmodule PackExample \{
  ...
  message PackedMessage;
  ...
\};

// File: pgm.h
...
class PackedMessage : public CMessage_PackedMessage
\{
  public:
    BinaryTree<char> btree; // A non-linear data structure 
    static void* pack(PackedMessage*);
    static PackedMessage* unpack(void*);
    ...
\};
...

// File: pgm.C
...
void*
PackedMessage::pack(PackedMessage* inmsg)
\{
  int treesize = inmsg->btree.getFlattenedSize();
  int totalsize = treesize + sizeof(int);
  char *buf = (char*)CkAllocBuffer(inmsg, totalsize);
  // buf is now just raw memory to store the data structure
  int num_nodes = inmsg->btree.getNumNodes();
  memcpy(buf, &num_nodes, sizeof(int));  // copy numnodes into buffer
  buf = buf + sizeof(int);               // don't overwrite numnodes
  // copies into buffer, give size of buffer minus header
  inmsg->btree.Flatten((void*)buf, treesize);    
  buf = buf - sizeof(int);              // don't lose numnodes
  delete inmsg;
  return (void*) buf;
\}

PackedMessage*
PackedMessage::unpack(void* inbuf)
\{
  // inbuf is the raw memory allocated and assigned in pack
  char* buf = (char*) inbuf;
  int num_nodes;
  memcpy(&num_nodes, buf, sizeof(int));
  buf = buf + sizeof(int);
  // allocate the message through charm kernel
  PackedMessage* pmsg = 
    (PackedMessage*)CkAllocBuffer(inbuf, sizeof(PackedMessage));
  // call "inplace" constructor of PackedMessage that calls constructor
  // of PackedMessage using the memory allocated by CkAllocBuffer,
  // takes a raw buffer inbuf, the number of nodes, and constructs the btree
  pmsg = new ((void*)pmsg) PackedMessage(buf, num_nodes);  
  CkFreeMsg(inbuf);
  return pmsg;
\}
... 
PackedMessage* pm = new PackedMessage();  // just like always 
pm->btree.Insert('A');
...
\end{alltt}


While serializing an arbitrary data structure into a flat buffer, one must be
very wary of any possible alignment problems.  Thus, if possible, the buffer
itself should be declared to be a flat struct.  This will allow the \CC\
compiler to ensure proper alignment of all its member fields.



\subsubsection{Immediate Messages}

Immediate messages are special messages that skip the Charm scheduler, they
can be executed in an ``immediate'' fashion even in the middle of 
a normal running entry method. 
They are supported only in nodegroup.



