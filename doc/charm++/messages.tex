\subsection{Messages}

In \charmpp, \index{chare}chares and \index{group}groups communicate using 
messages. Sending a message \index{message} to an object corresponds to an 
asynchronous method invocation.

Message definitions are very similar to class definitions in C++. 

In the {\tt .ci} file (the interface file), a message is declared as: 

\begin{tabbing}
~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \kill
\> \kw{message} \uw{MessageType};
\end{tabbing}

In the {\tt .h} file, message definition has the form:

\begin{tabbing}
~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \kill
\> \kw{class} \uw{MessageType} : \kw{public CMessage}\_\uw{MessageType} \{ \\
\> \>  // List of data and function members as in C++ \\
\> \};
\end{tabbing}

\subsubsection{Message Creation and Deletion}
\label{memory allocation}

\index{message}Messages are allocated using the \CC\ \kw{new}\index{new}
operator as usual :

\begin{tabbing}
~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \kill
\> \uw{MessageType} *{\it msgptr} = \\
\> \> \kw{new} [((\kw{int} *){\it sizes\_array}, \kw{int} {\it priobits}=0)] \uw{MessageType}[(constructor arguments)]; \\
\end{tabbing}

For example, to allocate a \index{varsize message}varsize message like:

\begin{verbatim}
message VarsizeMessage {
  int length;
  int firstArray[VARSIZE];
  double secondArray[VARSIZE];
};
\end{verbatim}

assign the size array and allocate the message:
\begin{verbatim}
int size[2];
size[0] = 10;
size[1] = 20;
VarsizeMessage *msg = new (size) VarsizeMessage;
\end{verbatim}

To give the integer \index{priority}priority to this message, 
\begin{verbatim}
VarsizeMessage *msg = new (size, sizeof(int)*8) VarsizeMessage;
\end{verbatim}
Note, you must provide number of bits which is used to store the priority as the {\it priobits} parameter.

In Section~\ref{message packing} we explain how messages can
contain arbitrary pointers, and how the validity of such pointers can be
maintained across processors in a distributed memory machine.

When a message \index{message} is sent to a \index{chare}chare, the programmer
relinquishes control of it; the space allocated to the message is
freed by the system.  When a message is received at an entry point it
is not freed by the runtime system.  It may be reused or deleted by
the programmer.  Messages can be deleted using the standard C++
\kw{delete}\index{delete} operator.  


\subsubsection{Entry Method Attributes}
\label{attributes}

Charm++ provides a handful of special attributes that \index{entry method}entry
methods may have.  In order to give a particular \index{entry method}entry
method an attribute, you must specify the keyword for the desired attribute in
the attribute list of that entry method's .ci file declaration.  The syntax for
this is as follows:

\small
\keyword{entry} \userword{[attribute1, ..., attributeN] void EntryMethod(MessageType *)};
\normalsize

Charm++ currently offers four attributes that one may give an entry method:
threaded, sync, exclusive, and virtual.
\index{threaded}\index{sync}\index{exclusive}\index{virtual}

\index{threaded}Threaded \index{entry method}entry methods are simply entry
methods which are run in their own nonpremptible threads.  To make an
\index{entry method}entry method threaded, one simply adds the keyword
\keyword{threaded} to the attribute list of that entry method.

\index{sync}Sync \index{entry method}entry methods are special in that calls to
sync entry methods are blocking - they do not return control to the caller
until the method is finished executing completely.  Sync methods may have
return values; however, they may only return messages.  To make an \index{entry
method}entry method a sync entry method, add the keyword \keyword{sync} to the
attribute list of that entry method.

\index{exclusive}Exclusive entry methods, which exist only on node groups, are
\index{entry method}entry methods that do not execute while other exclusive
\index{entry method}entry methods of its node group are executing in the same
node.  If one exclusive method of a node group is executing on node 0, and
another one is scheduled to run on that same node, the second exclusive method
will wait for the first to finish before it executes.  To make an \index{entry
method}entry method exclusive, add the keyword \keyword{exclusive} to that
entry method's attribute list.

\index{virtual}Virtual \index{entry method}entry methods are inherited in the
same manner as virtual methods of sequential C++ objects.  For a detailed
discussion of inheritance in Charm++, refer to section \ref{inheritance and
templates}.  To make an entry method virtual, just add the keyword
\keyword{virtual} to that method's attribute list.  Additionally, one may make
a virtual \index{entry method}entry method a pure virtual entry method.  They
behave in the same way as pure virtual methods in C++ and are declared in a
very similar fashion.  To make a virtual entry method pure, add a ``= 0'' after
that entry method's .ci file declaration.  This looks like the following:

\small
\keyword{entry} \userword{[virtual] void PureVirtualEntry(MessageType *) = 0};
\normalsize



\subsubsection{Message Packing}
\label{message packing}
\index{message packing}
\index{packed messages}

When one declares \charmpp\ messages in the ``.ci'' file, the
translator generates code to register those messages along with their
size with the runtime system. This information is later used to
efficiently allocate messages by the runtime system.

In many cases, the messages store {\em non-linear} data structures
using pointers.  Examples of these are binary trees, hash tables
etc. Thus, the message itself contains only a pointer to the actual
data. When the message is sent to the same processor, these pointers
point to the original locations, which are within the address space of
the same processor, however, when such a message is sent to other
processors, these pointers will point to invalid locations.

Thus, the programmer needs a way to ``serialize'' these messages
\index{serialized messages}\index{message serialization}{\em
only if} the message crosses the address-space boundary. This is
provided in \charmpp\ using
\kw{packed} \index{packed} messages.

Such messages are declared in the {\tt .ci} file as:

\verb+message [packed] PMessage;+

The class \uw{PMessage} needs to inherit from \uw{CMessage\_PMessage}
and needs to provide two {\em static} methods: \kw{pack}, \index{pack}
and \kw{unpack}\index{unpack}. These methods are called by the
\charmpp\ runtime system, when the message is determined to be
crossing address-space boundary. The prototypes for these methods are
as follows:

\begin{verbatim}
static void *PMessage::pack(PMessage *in);
static PMessage *PMessage::unpack(void *in);
\end{verbatim}

Typically, the following tasks are done in \kw{pack} method:

\begin{itemize}
\item Determine size of the buffer needed to serialize message data.
\item Allocate buffer using the \kw{CkAllocBuffer}
\index{CkAllocBuffer} function. This
function takes in two parameters: input message, and size of the
buffer needed, and returns the buffer.
\item Serialize message data into buffer (alongwith any control
information needed to de-serialize it on the receiving side.
\item Free resources occupied by message (including message itself.)  
\end{itemize}

On the receiving processor, the \kw{unpack} method is
called. Typically, the following tasks are done in the \kw{unpack}
method:

\begin{itemize}
\item Allocate message using \kw{CkAllocBuffer} function. {\em Do not
use \kw{new} to allocate message here. If the message constructor has
to be called, it could be done using the in-place \kw{new} \index{new}
operator.}
\item De-serialize message data from input buffer into the allocated message.
\item Free the input buffer using \kw{CkFreeMsg}\index{CkFreeMsg}.
\end{itemize}

Here is an example of a {\em packed} message implementation:

\begin{verbatim}
// File: pgm.ci
module PackExample {
  ...
  message [packed] PackedMessage;
  ...
};

// File: pgm.h
...
class PackedMessage : public CMessage_PackedMessage
{
  public:
    BinaryTree<NodeType> *btree; // Non-linear data structure
    static void *pack(PackedMessage *);
    static PackedMessage *unpack(void *);
    ...
};
...

// File: pgm.C
...
void *
PackedMessage::pack(PackedMessage *inmsg)
{
  int numnodes = inmsg->btree->numNodes();
  int totalsize = numnodes*sizeof(NodeType) + sizeof(int);
  int *buf = (int *)CkAllocBuffer(inmsg, totalsize);
  *buf++ = numnodes;
  inmsg->btree->flatten((void *)buf); // copies nodes, and 
                                      // replaces pointers by indices
  delete inmsg;
  return (void *)(--buf);
}

PackedMessage *
PackedMessage::unpack(void *inbuf)
{
  int *buf = (int *)inbuf;
  int numnodes = *buf++;
  PackedMessage *pmsg = CkAllocBuffer(inbuf, sizeof(PackedMessage));
  pmsg = new ((void *)pmsg) PackedMessage(inbuf, numnodes); // constructs btree
  CkFreeMsg(inbuf);
}
... 
}
\end{verbatim}

While serializing an arbitrary data structure into a flat buffer, one
must be very wary of any possible alignment problems.  Thus, if
possible, the buffer itself should be declared to be a flat struct.
This will allow the \CC\ compiler to ensure proper alignment of all
its member fields.

\subsubsection{Variable Size Messages}
\label{varsize messages}
\index{variable size messages}
\index{varsize message}

An ordinary message in \charmpp\ is a fixed size message that is
allocated internally with an envelope which encodes the size of the
message. Very often, the size of the data contained in a message is
not known until runtime. One can use \kw{packed}\index{packed
messages} messages to alleviate 
this problem. However, it requires multiple memory allocations (one
for the message, and another for the buffer.) This can be avoided by
making use of a \kw{varsize}\index{varsize} message.

A \kw{varsize} message is declared as {\tt message [varsize] mtype} in
\charmpp\ interface file. The class \uw{mtype} has to inherit from
\uw{CMessage\_mtype} AND has to provide \kw{pack}\index{pack},
\kw{unpack}\index{unpack}, AND
\kw{alloc}\index{alloc} class methods.

Thus, a varsize message is declared in the interface as: 

\verb+message [varsize] MyVarsizeMessage;+ 

In the \CC\ header file, it has to be defined as: 

\begin{verbatim}
class MyVarsizeMessage : public CMessage_MyVarsizeMessage { 
// Other methods & data members 
  static void *alloc(int msgnum, size_t size, int *array, int priobits); 
  static void* pack(msg* in); 
  static msg* unpack(void* in); 
}; 
\end{verbatim}

The \kw{alloc} method should actually allocate the message using
\kw{CkAllocMsg}\index{CkAllocMsg}, whose signature is given below:

\begin{verbatim}
void *CkAllocMsg(int msgnum, int size, int priobits); 
\end{verbatim}  

{\bf An Example:}

Suppose a \charmpp\ message contains two varsize fields 
(denoted here using an old keyword VARSIZE):

\begin{verbatim} 
message VarsizeMessage { 
  int length; 
  int firstArray[VARSIZE]; 
  double secondArray[VARSIZE]; 
}; 
\end{verbatim}

Then in \charmpp, this can be represented as: 

\begin{verbatim}
message [varsize] NewVarsizeMessage; 

class NewVarsizeMessage : public CMessage_NewVarsizeMessage { 
  public: 
    int len; 
    int *firstArray; 
    double *secondArray; 

  static void *alloc(int msgnum, int size, int *array, int priobits) 
  { 
    int totalsize; 
    totalsize = size + array[0]*sizeof(int) + array[1]*sizeof(double); 
    NewVarsizeMessage *newMsg = 
      (NewVarsizeMessage *) CkAllocMsg(msgnum, totalsize, priobits); 
    newMsg->firstArray = (int *) ((char *)newMsg+size); 
    newMsg->secondArray = (double *) ((char *)newMsg + size + 
                                      sizeof(int)*array[0]); 
    return (void *)newMsg; 
  } 

  static void *pack(NewVarsizeMessage *in) 
  { 
    in->firstArray = (int *) ((char *) in->firstArray - 
                              (char *)&in->firstArray); 
    in->secondArray = (double *) ((char *) in->secondArray - 
                                  (char *) &in->secondArray); 
    return in; 
  } 

  static NewVarsizeMessage* unpack(void *in) 
  { 
    NewVarsizeMessage *me = (NewVarsizeMessage *) in; 
    me->firstArray = (int *) ((char *) &(me->firstArray) + 
                              (size_t)(me->firstArray)); 
    me->secondArray = (double *) ((char *) &(me->secondArray) + 
                                  (size_t)(me->secondArray)); 
    return me;
  } 
}; 
\end{verbatim}

The pointers in a varsize message can exist in two states.  
At creation, they are valid \CC\ pointers to the start of the arrays.  
After packing, they become offsets from the address of the pointer variable to 
the start of the pointed-to data.  Unpacking restores them to pointers. 

\subsubsection{Prioritized Execution}
\label{prioritized message passing}
\index{prioritized execution}
\index{prioritized message passing}
\index{priorities}

By default, \charmpp\ will process the messages you send in roughly
FIFO\index{message delivery order} order.  For most programs, this
behavior is fine.  However, some programs need more explicit control
over the order in which messages are processed.  \charmpp\ allows you
to control queueing behavior on a per-message basis.

The simplest call available to change the order in which messages
are processed is \kw{CkSetQueueing}\index{CkSetQueueing}.

\begin{tabbing}
~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \kill
\> \kw{void CkSetQueueing}(\uw{MsgType} {\it message}, \kw{int} {\it
queueingtype}) \\
\end{tabbing}

where {\it queueingtype}\index{queueing types} is one of the following
constants:

\begin{tabbing}
~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \kill
\> \kw{CK\_QUEUEING\_FIFO}\\
\> \kw{CK\_QUEUEING\_LIFO}\\
\> \kw{CK\_QUEUEING\_IFIFO}\\
\> \kw{CK\_QUEUEING\_ILIFO}\\
\> \kw{CK\_QUEUEING\_BFIFO}\\
\> \kw{CK\_QUEUEING\_BLIFO}\\
\index{CK\_QUEUEING\_FIFO}
\index{CK\_QUEUEING\_LIFO}
\index{CK\_QUEUEING\_IFIFO}
\index{CK\_QUEUEING\_ILIFO}
\index{CK\_QUEUEING\_BFIFO}
\index{CK\_QUEUEING\_BLIFO}
\end{tabbing}

The first two options,  \kw{CK\_QUEUEING\_FIFO} and
\kw{CK\_QUEUEING\_LIFO}, are used as follows: 

\begin{verbatim}
  MsgType *msg1 = new MsgType ;
  CkSetQueueing(msg1, CK_QUEUEING_FIFO);

  MsgType *msg2 = new MsgType ;
  CkSetQueueing(msg2, CK_QUEUEING_LIFO);
\end{verbatim}

When message {\tt msg1} arrives at its destination, it will be pushed
onto the end of the message queue as usual.  However, when {\tt msg2}
arrives, it will be pushed onto the {\it front} of the message queue.

The other four options involve the use of
priorities\index{priorities}.  To attach a priority field to a
message, one needs to set aside space in the message's buffer while
allocating the message\index{message priority}.  To achieve this, the
size of the priority field\index{priority field} in bits should be
specified as a placement argument to the \kw{new} operator, as
described in Section \ref{memory allocation}.  Although the size of
the priority field is specified in bits, it is always padded to an
integral number of {\tt int}s.  A pointer to the priority part of the
message buffer can be obtained with these calls:

\begin{tabbing}
~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \=~~~~ \kill
\> \kw{unsigned int} *\kw{CkPriorityPtr}(\uw{MsgType} {\it msg}) \\
\end{tabbing}
\index{CkPriorityPtr}
\index{priority pointer}

There are two kinds of priorities which can be attached to a message:
{\sl integer priorities}\index{integer priorities} and {\sl bitvector
priorities}\index{bitvector priorities}.  Integer priorities are quite
straightforward.  One allocates a message, setting aside enough space
(in bits) in the message to hold the priority, which is an integer.
One then stores the priority in the message.  Finally, one informs the
system that the message contains an integer priority using
\kw{CkSetQueueing}:

\begin{verbatim}
  MsgType *msg = new (8*sizeof(int)) MsgType;
  *CkPriorityPtr(msg) = prio;
  CkSetQueueing(msg, CK_QUEUEING_IFIFO);
\end{verbatim}
\index{CkSetQueueing}

The predefined constant  \kw{CK\_QUEUEING\_IFIFO} indicates that the
message contains an integer priority, and that if there are other
messages of the same priority, they should be sequenced in FIFO order
(relative to each other).  Similarly, a  \kw{CK\_QUEUEING\_ILIFO} is
available.  Note that  \kw{MAXINT} is the lowest priority, and {\bf
NEGATIVE\_MAXINT} is the highest priority\index{integer priority range}.

Bitvector priorities are somewhat more complicated.  Bitvector
priorities are arbitrary-length bit-strings representing fixed-point
numbers in the range 0 to 1.  For example, the bit-string ``001001''
represents the number .001001\raisebox{-.5ex}{\scriptsize binary}.  As
with the simpler kind of priority, higher numbers represent lower
priorities.  Unlike the simpler kind of priority, bitvectors can be of
arbitrary length, therefore, the priority numbers they represent can
be of arbitrary precision.

Arbitrary-precision priorities\index{arbitrary-precision priorities}
are often useful in AI search-tree applications.  Suppose we have a
heuristic suggesting that tree node $N_1$ should be searched before
tree node $N_2$.  We therefore designate that node $N_1$ and its
descendants will use high priorities, and that node $N_2$ and its
descendants will use lower priorities.  We have effectively split the
range of possible priorities in two.  If several such heuristics fire
in sequence, we can easily split the priority range \index{priority
range splitting} in two enough times that no significant bits remain,
and the search begins to fail for lack of meaningful priorities to
assign.  The solution is to use arbitrary-precision priorities,
i.e. bitvector priorities.

To assign a bitvector priority, two methods are available.  The
first is to obtain a pointer to the priority field using  \kw{CkPriorityPtr},
and to then manually set the bits using the bit-setting operations
inherent to C.  To achieve this, one must know the format
\index{bitvector format} of the
bitvector, which is as follows: the bitvector is represented as an
array of unsigned integers.  The most significant bit of the first
integer contains the first bit of the bitvector.  The remaining bits
of the first integer contain the next 31 bits of the bitvector.
Subsequent integers contain 32 bits each.  If the size of the
bitvector is not a multiple of 32, then the last integer contains 0
bits for padding in the least-significant bits of the integer.

The second way to assign priorities is only useful for those who are
using the priority range-splitting\index{priority range splitting}
described above.  The root of the tree is assigned the null
priority-string.  Each child is assigned its parent's priority with
some number of bits concatenated.  The net effect is that the entire
priority of a branch is within a small epsilon of the priority of its
root.

It is possible to utilize unprioritized messages, integer priorities,
and bitvector priorities in the same program.  The messages will be
processed in roughly the following order\index{multiple priority types}:

\begin{itemize}

\item Among messages enqueued with bitvector priorities, the
messages are dequeued according to their priority.  The
priority ``0000...'' is dequeued first, and ``1111...'' is
dequeued last.

\item Unprioritized messages are treated as if they had the
priority ``1000...'' (which is the ``middle'' priority, it
lies exactly halfway between ``0000...'' and ``1111...'').
 
\item Integer priorities are converted to bitvector priorities.  They
are normalized so that the integer priority of zero is converted to
``1000...'' (the ``middle'' priority).  To be more specific, the
conversion is performed by adding 0x80000000 to the integer, and then
treating the resulting 32-bit quantity as a 32-bit bitvector priority.

\item Among messages with the same priority, messages are
dequeued in FIFO order or LIFO order, depending upon which
queuing strategy was used.

\end{itemize} 

A final warning about prioritized execution: \charmpp\ always processes
messages in {\it roughly} the order you specify; it never guarantees to
deliver the messages in {\it precisely} the order\index{message
delivery order} you specify.
However, it makes a serious attempt to be ``close'', so priorities
can strongly affect the efficiency of your program.
