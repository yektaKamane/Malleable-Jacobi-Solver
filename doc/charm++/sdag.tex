\subsection{Structured Control Flow: Structured Dagger}
\label{sec:sdag}

\charmpp\ is based on the message-driven parallel programming paradigm. In
contrast to many other approaches, \charmpp\ programmers encode entry points to
their parallel objects, but do not explicitly wait (i.e. block) on the runtime
to indicate completion of posted `receive' requests. Thus, a \charmpp\ object's
overall flow of control can end up fragmented across a number of separate
methods, obscuring the sequence in which code is expected to
execute. Furthermore, there are often constraints on when different pieces of
code should execute relative to one another, related to data and
synchronization dependencies.

Consider one way of expressing these constraints using flags, buffers, and
counters, as in the following example:
%
%\begin{figure}[ht]
\begin{center}
\begin{alltt}
// in .ci file
chare ComputeObject \{
  entry void ComputeObject();
  entry void startStep();
  entry void firstInput(Input i);
  entry void secondInput(Input j);
\};

// in C++ file
class ComputeObject : public CBase_ComputeObject \{
  int   expectedMessageCount;
  Input first, second;

public:
  ComputeObject() \{
    startStep();
  \}
  void startStep() \{
    expectedMessageCount = 2;
  \}

  void firstInput(Input i) \{
    first = i;
    if (--expectedMessageCount == 0)
      computeInteractions(first, second);
    \}
  void recv_second(Input j) \{
    second = j;
    if (--expectedMessageCount == 0)
      computeInteractions(first, second);
  \}

  void computeInteractions(Input a, Input b) \{
    // do computations using a and b
    . . .
    // send off results
    . . .
    // reset for next step
    startStep();
  \}
\};
\end{alltt}
\end{center}
%\caption{Compute Object in a Molecular Dynamics Application}
%\label{figchareexample}
%\end{figure}
In each step, this object expects pairs of messages, and waits to process the
incoming data until it has both of them. This sequencing is encoded across 4
different functions, which in real code could be much larger and more numerous,
resulting in a spaghetti-code mess.

Instead, it would be preferable to express this flow of control using
structured constructs, such as loops. \charmpp\ provides such constructs for
structured control flow across an object's entry methods in a notation called
Structured Dagger. The basic constructs of Structured Dagger (SDAG) provide for
\emph{program-order execution} of the entry methods and code blocks that they
define. These definitions appear in the {\tt .ci} file definition of the
enclosing chare class as a `body' of an entry method following its signature.

The most basic construct in SDAG is the {\tt atomic} block. Atomic blocks
contain sequential \CC code.  They're called atomic because the code within
them executes without returning control to the \charmpp\ runtime scheduler, and
thus avoiding interruption from incoming messages. The earlier example can be
adapted to use atomic blocks as follows:
\begin{center}
\begin{alltt}
// in .ci file
chare ComputeObject \{
  entry void ComputeObject();
  entry void startStep();
  entry void firstInput(Input i) \{
    atomic \{
      first = i;
      if (--expectedMessageCount == 0)
        computeInteractions(first, second);
    \}
  \};
  entry void secondInput(Input j) \{
    atomic \{
      second = j;
      if (--expectedMessageCount == 0)
        computeInteractions(first, second);
    \}
  \};
\};

// in C++ file
class ComputeObject : public CBase\_ComputeObject \{
  ComputeObject\_SDAG\_Code
  int   expectedMessageCount;
  Input first, second;

public:
  ComputeObject() \{
    __sdag_init();
    startStep();
  \}
  void startStep() \{
    expectedMessageCount = 2;
  \}

  void computeInteractions(Input a, Input b) \{
    // do computations using a and b
    . . .
    // send off results
    . . .
    // reset for next step
    startStep();
  \}
\};
\end{alltt}
\end{center}
Note that chare classes containing SDAG code must make a few additional calls
in addition to inheriting from their {\tt CBase\_Foo} class: incorporate the
{\tt Foo\_SDAG\_CODE} generated-code macro in the class, and call {\tt
  \_\_sdag\_init()} in the class's constructor(s).

Atomic blocks can also specify a textual `label' that will appear in traces, as
follows:
\begin{center}
\begin{alltt}
  entry void firstInput(Input i) \{
    atomic "process first" \{
      first = i;
      if (--expectedMessageCount == 0)
        computeInteractions(first, second);
    \}
  \};
\end{alltt}
\end{center}

In order to control the sequence in which entry methods are processed, SDAG
provides the {\tt when} construct. Entry methods defined by a {\tt when} are
not executed immediately when a message tergeting them is delivered, but
instead are held until control flow in the chare reaches a corresponding {\tt
  when} clause. Conversely, when control flow reaches a {\tt when} clause, the
generated code checks whether a corresponding message has arrived: if one has
arrived, it is processed; otherwise, control is returned to the
\charmpp\ scheduler. 

The use of {\tt when} substantially simplifies the example from above:
\begin{center}
\begin{alltt}
// in .ci file
chare ComputeObject \{
  entry void ComputeObject();
  entry void startStep() \{
    when firstInput(Input first)
      when secondInput(Input second)
        atomic \{
          computeInteractions(first, second);
        \}
  \};
  entry void firstInput(Input i);
  entry void secondInput(Input j);
\};

// in C++ file
class ComputeObject : public CBase_ComputeObject \{
  ComputeObject_SDAG_Code

public:
  ComputeObject() \{
    __sdag_init();
    startStep();
  \}

  void computeInteractions(Input a, Input b) \{
    // do computations using a and b
    . . .
    // send off results
    . . .
    // reset for next step
    startStep();
  \}
\};
\end{alltt}
\end{center}
Like an {\tt if} or {\tt while} in C code, each {\tt when} clause has a body
made up of the statement or block following it. The variables declared as
arguments to the entry method triggering the when are available in the scope of
the body. By using the sequenced execution of SDAG code and the availability of
parameters to when-defined entry methods in their bodies, the counter {\tt
  expectedMessageCount} and the intermediate copies of the received input are
eliminated. Note that the entry methods {\tt firstInput} and {\tt secondInput}
are still declared in the {\tt .ci} file, but their definition is in the SDAG
code. The interface translator generates code to handle buffering and
triggering them appropriately.

For simplicity, {\tt when} constructs can also specify multiple expected entry
methods that all feed into a single body, by separating their prototypes with
commas:
\begin{center}
\begin{alltt}
entry void startStep() \{
  when firstInput(Input first),
       secondInput(Input second)
    atomic \{
      computeInteractions(first, second);
    \}
\};
\end{alltt}
\end{center}

SDAG supports the {\tt for} and {\tt while} loop constructs mostly as if they
appeared in plain C or C++ code. In the running example, {\tt
  computeInteractions()} calls {\tt startStep()} when it is finished to start
the next step. Instead of this arrangement, the loop structure can be made
explicit:
\begin{center}
\begin{alltt}
// in .ci file
chare ComputeObject \{
  entry void ComputeObject();
  entry void runForever() \{
    while(true) \{
      when firstInput(Input first),
           secondInput(Input second) atomic \{
          computeInteractions(first, second);
      \}
    \}
  \};
  entry void firstInput(Input i);
  entry void secondInput(Input j);
\};

// in C++ file
class ComputeObject : public CBase_ComputeObject \{
  ComputeObject_SDAG_Code

public:
  ComputeObject() \{
    __sdag_init();
    runForever();
  \}

  void computeInteractions(Input a, Input b) \{
    // do computations using a and b
    . . .
    // send off results
    . . .
  \}
\};
\end{alltt}
\end{center}
If this code should instead run for a fixed number of iterations, we can
instead use a for loop:
\begin{center}
\begin{alltt}
// in .ci file
chare ComputeObject \{
  entry void ComputeObject();
  entry void runForever() \{
    for(iter = 0; iter < n; ++iter) \{
      when firstInput(Input first),
           secondInput(Input second) atomic \{
        computeInteractions(first, second);
      \}
    \}
  \};
  entry void firstInput(Input i);
  entry void secondInput(Input j);
\};

// in C++ file
class ComputeObject : public CBase_ComputeObject \{
  ComputeObject_SDAG_Code
  int n, iter;

public:
  ComputeObject() \{
    __sdag_init();
    n = 10;
    runForever();
  \}

  void computeInteractions(Input a, Input b) \{
    // do computations using a and b
    . . .
    // send off results
    . . .
  \}
\};
\end{alltt}
\end{center}
Note that {\tt int iter;} is declared in the chare's class definition and not
in the {\tt .ci} file. This is necessary because the \charmpp\ interface
translator does not fully parse the declarations in the {\tt for} loop header,
because of the inherent complexities of C++.

SDAG also supports conditional execution of statements and blocks with {\tt if}
statements. The syntax of SDAG {\tt if} statements matches that of C and
C++. However, if one encounters a parsing error on correct-looking code in a
loop or conditional statement, try assigning the condition expression to a
boolean variable in an atomic preceding the statement and then testing that
boolean's value. This can be necessary because of the complexity of parsing C++
code.

In cases where multiple tasks must be processed before execution continues, but
with no dependencies or interactions among them, SDAG provides the {\tt
  overlap} construct. Overlap blocks contain a series of SDAG statements within
them which can occur in any order. Commonly these blocks are used to hold a
series of {\tt when} triggers which can be received and processed in any
order. Flow of control doesn't leave the overlap block until all the statements
within it have been processed.

In the running example, suppose each input needed to be preprocessed 


 Typically atomic blocks hold
the code that actually deals with incoming messages in a {\tt when} statement,
or to do local operations before a message is sent or after it's received.


Threads are typically used to perform the abovementioned sequencing.
Lets us code our previous example using threads.

%\begin{figure}[ht]
\begin{center}
\begin{alltt}
void compute_thread(int first_index, int second_index)
\{
    getPatch(first_index);
    getPatch(second_index);
    threadId[0] = createThread(recvFirst);
    threadId[1] = createThread(recvSecond);
    threadJoin(2, threadId);
    computeInteractions(first, second);
  \}
  void recvFirst(void)
  \{
    recv(first, sizeof(Patch), ANY_PE, FIRST_TAG);
    filter(first);
  \}
  void recvSecond(void)
  \{
    recv(second, sizeof(Patch), ANY_PE, SECOND_TAG);
    filter(second);
  \}
\end{alltt}
\end{center}
%\caption{Compute Thread in a Molecular Dynamics Application}
%\label{figthreadexample}
%\end{figure}

Contrast the compute chare-object example in figure~\ref{figchareexample} with
a thread-based implementation of the same scheme in
figure~\ref{figthreadexample}. Functions \uw{getFirst}, and \uw{getSecond} send
messages asynchronously to the PatchManager, requesting that the specified
patches be sent to them, and return immediately. Since these messages with
patches could arrive in any order, two threads, \uw{recvFirst} and
\uw{recvSecond}, are created. These threads block, waiting for messages to
arrive. After each message arrives, each thread performs the filtering
operation. The main thread waits for these two threads to complete, and then
computes the pairwise interactions. Though the programming complexity of
buffering the messages and maintaining the counters has been eliminated in this
implementation, considerable overhead in the form of thread creation, and
synchronization in the form of {\em join} has been added. Let us now code the
same example in \sdag. It reduces the parallel programming complexity without
adding any significant overhead.

%\begin{figure}[ht]
\begin{center}
\begin{alltt}
  array[1D] compute_object \{
    entry void recv_first(Patch *first);
    entry void recv_second(Patch *first);
    entry void compute_object(MSG *msg)\{
      atomic \{
         PatchManager->Get(msg->first_index,\dots);
         PatchManager->Get(msg->second_index,\dots);
      \}
      overlap \{
        when recv_first(Patch *first) atomic \{ filter(first); \}
        when recv_second(Patch *second) atomic \{ filter(second); \}
      \}
      atomic \{ computeInteractions(first, second); \}
    \}
  \}
\end{alltt}
\end{center}
%\caption{\sdag\ Implementation of the Compute Object}
%\label{figsdagexample}
%\end{figure}

\sdag\ is a coordination language built on top of \charmpp\ that supports the
sequencing mentioned above, while overcoming limitations of thread-based
languages, and facilitating a clear expression of flow of control within the
object without losing the performance benefits of adaptive message-driven
execution.  In other words, \sdag\ is a structured notation for specifying
intra-process control dependences in message-driven programs. It combines the
efficiency of message-driven execution with the explicitness of control
specification. \sdag\ allows easy expression of dependences among messages and
computations and also among computations within the same object using
when-blocks and various structured constructs.  \sdag\ is adequate for
expressing control-dependencies that form a series-parallel control-flow graph.
\sdag\ has been developed on top of \charmpp\. \sdag\ allows \charmpp\ entry
methods (in chares, groups or arrays) to specify code (a when-block body) to be
executed upon occurrence of certain events.  These events (or guards of a
when-block) are entry methods of the object that can be invoked remotely. While
writing a \sdag\ program, one has to declare these entries in \charmpp\
interface file. The implementation of the entry methods that contain the
when-block is written using the \sdag\ language. Grammar of \sdag\ is given in
the EBNF form below.

\subsubsection{Usage}

You can use SDAG to implement entry methods for any chare, chare array, group,
or nodegroup. Any entry method implemented using SDAG must be implemented in the
interface (.ci) file for its class. An SDAG entry method consists of a series of
SDAG constructs of the following kinds:

\begin{itemize}
    \item {\tt atomic} blocks: Atomic blocks simply contain sequential \CC code.
        They're called atomic because the code within them executes without
        interruption from incoming messages. Typically atomic blocks hold the
        code that actually deals with incoming messages in a {\tt when}
        statement, or to do local operations before a message is sent or after
        it's received.
    \item {\tt overlap} blocks: 
    \item {\tt when} statements: These statement, also called triggers, indicate
        that we expect an incoming message of a particular type, and provide
        code to handle that message when it arrives. They commonly occur inside
        of {\tt overlap} blocks, loops, and other control flow statements.
    \item {\tt forall} loops: These loops are used when each iteration of a loop
        can be performed in parallel. This is in contrast to a regular {\tt for}
        loop, in which each iteration is executed sequentially.
    \item {\tt if}, {\tt for}, and {\tt while} statements: these statements have
        the same meaning as the normal {\tt if}, {\tt for}, and {\tt while}
        loops in sequential \CC programs. This allows the programmer to use
        common control flow constructs outside the context of atomic blocks.
\end{itemize}

\sdag{} code can be inserted into the .ci file for any array, group, or chare's entry methods.

If you've added \sdag\ code to your class, you must link in the code by:
\begin{itemize}
  \item Adding ``{\it className}\_SDAG\_CODE'' inside the class declaration
     in the .h file.  This macro defines the entry points and support
     code used by \sdag{}.  Forgetting this results in a compile error
     (undefined sdag entry methods referenced from the .def file).
  \item Adding a call to the routine ``\_\_sdag\_init();'' from every constructor,
     including the migration constructor.  Forgetting this results in
     using uninitalized data, and a horrible runtime crash.
  \item Adding a call to the pup routine ``\_\_sdag\_pup(p);'' from your pup routine.
     Forgetting this results in failure after migration.
\end{itemize}

For example, an array named ``Foo'' that uses sdag code might contain:

\begin{alltt}
class Foo : public CBase_Foo \{
public:
    Foo_SDAG_CODE
    Foo(...) \{
       __sdag_init();
       ...
    \}
    Foo(CkMigrateMessage *m) \{
       __sdag_init();
    \}
    
    void pup(PUP::er &p) \{
       CBase_Foo::pup(p);
       __sdag_pup(p);
    \}
\};
\end{alltt}

For more details regarding \sdag{}, look at the example located in the 
{\tt examples/charm++/hello/sdag} directory in the \charmpp\ distribution.


\subsubsection{Grammar}

\paragraph{Tokens}

\begin{alltt}
  <ident> = Valid \CC{} identifier 
  <int-expr> = Valid \CC{} integer expression 
  <\CC{}-code> = Valid \CC{} code 
\end{alltt}

\paragraph{Grammar in EBNF Form}

\begin{alltt}
<sdag> := <class-decl> <sdagentry>+ 

<class-decl> := "class" <ident> 

<sdagentry> := "sdagentry" <ident> "(" <ident> "*" <ident> ")" <body> 

<body> := <stmt> 
        | "\{" <stmt>+ "\}" 

<stmt> := <overlap-stmt> 
        | <when-stmt> 
        | <atomic-stmt> 
        | <if-stmt> 
        | <while-stmt> 
        | <for-stmt> 
        | <forall-stmt> 

<overlap-stmt> := "overlap" <body> 

<atomic-stmt> := "atomic" "\{" <\CC-code> "\}" 

<if-stmt> := "if" "(" <int-expr> ")" <body> [<else-stmt>] 

<else-stmt> := "else" <body> 

<while-stmt> := "while" "(" <int-expr> ")" <body> 

<for-stmt> := "for" "(" <c++-code> ";" <int-expr> ";" <c++-code> ")" <body> 

<forall-stmt> := "forall" "[" <ident> "]" "(" <range-stride> ")" <body> 

<range-stride> := <int-expr> ":" <int-expr> "," <int-expr> 

<when-stmt> := "when" <entry-list>  <body> 

<entry-list> := <entry> 
              | <entry> [ "," <entry-list> ] 

<entry> := <ident> [ "[" <int-expr> "]" ] "(" <ident> "*" <ident> ")" 
  
\end{alltt}

