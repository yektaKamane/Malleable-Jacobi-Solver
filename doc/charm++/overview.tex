\section{\charmpp{} Overview}

We think that \charmpp\ is easy to use if you are familiar with object-based
programming. (But of course that is our opinion, if your opinion differs,
you are encouraged to let us know the reasons, and features that you would
like to see in \charmpp.) Object-based programming is built around the
concept of ``encapsulation'' of data. As implemented in \CC, data
encapsulation is achieved by grouping together data and methods (also known
as functions, subroutines, or procedures) inside of an object.

A class is a blueprint for an object.  The encapsulated data is said to be
``private'' to the object, and only the methods of that class can manipulate
that data. A method that has the same name as the class is a ``blessed''
method, called a ``Constructor'' for that class.  A constructor method is
typically responsible for initializing the encapsulated data of an object.
Each method, including the constructor can optionally be supplied data in
the form of parameters (or arguments). In \CC, one can create objects with
the {\tt new} operator that returns a pointer to the object. This pointer
can be used to refer to the object, and call methods on that object.

\charmpp{} is built on top of \CC, and also based on ``encapsulation''.
Similar to \CC, \charmpp\ entities can contain private data, and public
methods. The major difference is that these methods can be invoked from
remote processors asynchronously.  Asynchronous method invocation means that
the caller does not wait for the method to be actually executed and does not
wait for the method's return value. Therefore, \charmpp\ methods (called
entry methods) do not have a return value\footnote{Asynchronous remote
method invocation is the core of \charmpp. However, to simplify programming,
\charmpp\ makes use of the interoperable nature of its runtime system, and
combines seamlessly with user-level threads to also support synchronous
method execution, albeit with a slight overhead of thread creation and
scheduling.}. Since the actual \charmpp\ object on which the method is being
invoked may be on a remote processor\footnote{With its own, different address
space}, the \CC\ way of referring to an object, via a pointer, is not valid
in \charmpp.  Instead, we refer to a remote chare via a ``proxy''.

Those familiar with various component models\footnote{Such as CORBA} in the
distributed computing world will recognize ``proxy'' to be a dummy, standin
entity that refers to an actual entity.  For each chare type, a ``proxy''
class exists\footnote{The proxy class is generated by the ``interface
translator'' based on a description of the entry methods}.  The methods of
this ``proxy'' class correspond to the remote methods of actual class, and
act as ``forwarders''. That is, when one invokes a method on a proxy to a
remote object, the proxy forwards this method invocation to the actual
remote object. All entities that are created and manipulated remotely in
\charmpp\ have such proxies. Proxies for each type of entity in \charmpp\
have some differences among the features they support, but the basic syntax
and semantics remains the same-- that of invoking methods on the remote
object by invoking methods on proxies.


\subsection{\charmpp\ Execution Model}

A \charmpp\ program consists of a number of \charmpp\ objects distributed
across the available number of processors. Thus, the basic unit of parallel
computation in \charmpp\ programs is the {\em chare}\index{chare}, a \charmpp\
object that can be created on any available processor and can be accessed from
remote processors.  A \index{chare}chare is similar to a process, an actor, an
ADA task, etc.  \index{chare}Chares are created dynamically, and many chares
may be active simultaneously.  Chares send \index{message}{\em messages} to one
another to invoke methods asynchronously.  Conceptually, the system maintains a
``work-pool'' consisting of seeds for new \index{chare}chares, and
\index{message}messages for existing chares. The runtime system (called {\em
Charm Kernel}) may pick multiple items, non-deterministically, from this pool
and execute them.  

Methods of a \index{chare}chare that can be remotely invoked are called
\index{entry method}{\em entry} methods.  Entry methods may take marshalled
paramters, or a pointer to a message object.  Since \index{chare}chares can
be created on remote processors, obviously some constructor of a chare needs
to be an entry method.  Ordinary entry methods\footnote{``Threaded'' or
``synchronous'' methods are different.} are completely non-preemptive--
\charmpp\ will never interrupt an executing method to start any other work,
and all calls made are asynchronous.

\charmpp\ provides dynamic seed-based load balancing. Thus location (processor
number) need not be specified while creating a remote \index{chare}chare. The
Charm Kernel will then place the remote chare on a least loaded processor. Thus
one can imagine chare creation as generating only a seed for the new chare,
which may {\em take root} on the most {\em fertile} processor. Charm Kernel
identifies a \index{chare}chare by a {\em ChareID}.  Since user code does not
need to name a chares' processor, chares can potentially migrate from one
processor to another.  (This behaviour is used by the dynamic load-balancing
framework for chare containers, such as arrays.)

Other \charmpp\ objects are collections of chares. They are: {\em
chare-arrays}, \index{group}{\em chare-groups}, and \index{nodegroup}{\em
chare-nodegroups}, referred to as {\em arrays}, {\em groups}, and {\em
nodegroups} throughout this manual. An array is a collection of arbitrary
number of migratable chares, indexed by some index type, and mapped to
processors according to a user-defined map group. A group (nodegroup) is a
collection of chares, one per processor (SMP node), that is addressed using
a unique system-wide name.

Every \charmpp\ program must have at least one \kw{mainchare}.  Each
\kw{mainchare} is created by the system on processor 0 when the \charmpp\
program starts up.  Execution of a \charmpp\ program begins with the Charm
Kernel constructing all the designated \kw{mainchare}s.  Typically, the
\kw{mainchare} constructor starts the computation by creating arrays, other
chares, and groups.  It can also be used to initialize shared \kw{readonly}
objects.

The only method of communication between processors in \charmpp\ is
asynchronous \index{entry method} entry method invocation on remote chares.
For this purpose, Charm Kernel needs to know the types of
\index{chare}chares in the user program, the methods that can be invoked on
these chares from remote processors, the arguments these methods take as
input etc. Therefore, when the program starts up, these user-defined
entities need to b registered with Charm Kernel, which assigns a unique
identifier to each of them. While invoking a method on a remote object,
these identifiers need to be specified to Charm Kernel. Registration of
user-defind entities, and maintaining these identifiers can be cumbersome.
Fortunately, it is done automatically by the \charmpp\ interface translator.
The \charmpp\ interface translator generates definitions for {\em proxy}
objects. A proxy object acts as a {\em handle} to a remote chare. One
invokes methods on a proxy object, which in turn carries out remote method
invocation on the chare.

In addition, the \charmpp\ interface translator provides ways to enhance the
basic functionality of Charm Kernel using user-level threads and futures. These
allow entry methods to be executed in separate user-level threads.  These
\index{threaded} {\em threaded} entry methods may block waiting for data by
making {\em synchronous} calls to remote object methods that return results in
messages.

\charmpp\ program execution is terminated by the \kw{CkExit} call.  Like the
\kw{exit} system call, \kw{CkExit} never returns. The Charm Kernel ensures
that no more messages are processed and no entry methods are called after a
\kw{CkExit}. \kw{CkExit} need not be called on all processors; it is enough
to call it from just one processor at the end of the computation.


\subsection{Entities in \charmpp\ programs}

This section describes various entities in a typical \charmpp\ program.

\subsubsection{Sequential Objects}

A \charmpp\ program typically consists mostly of ordinary sequential \CC
code and objects. Such entities are only accessible locally, are not known
to the \charmpp\ runtime system, and thus need not be mentioned in the
module interface files. 

\charmpp\ does not affect the syntax or semantics of such \CC\ entities,
except that changes to global variables (or static data members of a class)
on one node will not be visible on other nodes.  Global data changes
must be explicitly sent between processors.  For processor- and
thread-private storage, refer to the ``Global Variables'' section
of the Converse manual.


\subsubsection{Messages}

Messages supply data arguments to the asynchronous remote method invocation.
These objects are treated differently from other objects in \charmpp\ by the
runtime system, and therefore they must be specified in the interface file
of the module.  With parameter marshalling, the system creates and handles
the message completely internally. Other messages are instances of \CC\
classes that are subclassed from a special class that is generated by the
\charmpp\ interface translator.  Another variation of communication objects
is conditionally packed and unpacked. This variation should be used when one
wants to send messages that contain pointers to the data rather than the
actual data to other processors. This type of communication objects contains
two static methods: \kw{pack}, and \kw{unpack}. The third variation of
communication objects is called {\em varsize} messages. Varsize messages is
an effective optimization on conditionally packed messages, and can be
declared with special syntax in the interface file.

\subsubsection{Chares}

Chares are the most important entities in a \charmpp\ program. These concurrent
objects are different from sequential \CC\ objects in many ways. Syntactically,
Chares are instances of \CC\  classes that are derived from a system-provided
class called \kw{Chare}. Also, in addition to the usual \CC\ private and public
data and method members, they contain some public methods called {\em entry
methods}. These entry methods do not return anything (they are {\tt void}
methods), and take at most one argument, which is a pointer to a message.
Chares are {\em accessed} using a proxy (an object of a specialized class
generated by the \charmpp\ interface translator) or using a handle (a \kw{
CkChareID} structure defined in \charmpp), rather than a pointer as in \CC.
Semantically, they are different from \CC\ objects because they can be created
asynchronously from remote processors, and their entry methods also could be
invoked asynchronously from the remote processors. Since the constructor method
is invoked from remote processor (while creating a chare), every chare should
have its constuctors as entry methods (with at most one message pointer
parameter). These chares and their entry methods have to be specified in the
interface file.

\subsubsection{Chare Arrays}

Chare arrays are collections of chares. However, unlike chare groups or
nodegroups, arrays are not constrained by characteristics of the underlying
parallel machine such as number of processors or nodes. Thus, chare arrays
can have any number of {\em elements}. The array elements themselves are
chares, and methods can be invoked on individual array elements as usual.  
Each element of an array has a globally unique index, and messages are
addressed to that index.

Unlike other entities in \charmpp\, the dynamic load balancing framework (LB
Framework) treats array elements as objects that can be migrated across
processors. Thus, the runtime system keeps track of computational load
across the system, and also the time spent in execution of entry methods on
array elements, and then employs one of several strategies to redistribute
array elements across the available processors.

\subsubsection{Chare Groups}

Chare Groups\footnote{ These were called Branch Office Chares (BOC) in earlier
version of Charm.} are a special type of concurrent objects.  Each chare group
is a collection of chares, with one representative (group member) on each
processor. All the members of a chare group share a globally unique name
(handle, defined by Charm kernel to be of type \kw{CkGroupID}). An entire chare
group could be addressed using this global handle, and an individual member of
a chare group can be addressed using the global handle, and a processor number.
Chare groups are instances of \CC\ classes subclassed from a system-provided
class called \kw{Group}. The Charm kernel has to be notified that these chares
are semantically different, and therefore chare groups have a different
declaration in the interface specification file.

\subsubsection{Chare Nodegroups}

Chare nodegroups are very similar to chare groups except that instead of having
one groupmember on each processor, the nodegroup has one member on each shared
memory multiprocessor node. Note that \charmpp\ (and its underlying runtime
system Converse) distinguish between processors and nodes. A node consists of
one or more processors that share an address space. The last few years have
seen emergence of fast SMP systems of small (2-4 processors) to large (32-64
processors) number of processors per node. A network of such SMP nodes is the
most general model of parallel computers, making pure distributed and pure
shared memory systems mere special cases. \charmpp\ is built on top of this
machine abstraction, and Chare nodegroups embody this abstraction in a higher
level language construct. Sematically, methods invoked on a nodegroup member
could be executed on any processor within that node. This fact can be utilized
for supporting load balance across processors within a node. However, this also
means that different processors within a node could be executing methods of the
same nodegroup member simultaneously, thus leading to common problems
associated with shared address space programming. However, \charmpp\ eases such
problems by allowing the programmer to specify an entry method of a nodegroup
to be {\em exclusive}, thus guaranteeing that no other {\em exclusive} method
of that nodegroup member can execute simultaneously within the node.

