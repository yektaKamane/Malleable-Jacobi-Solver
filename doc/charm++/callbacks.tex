\subsection{Callbacks}
\label{callbacks}

A callback is a generic way to transfer control back to a client
after a library has finished.  For example, after finishing a reduction,
you might want the results passed to some chare's entry method.
To do this, you create an object of type \kw{CkCallback} with
the chare's \kw{CkChareID} and entry method index, then pass the
callback object to the reduction library.


\subsubsection{Client Interface}
\index{CkCallback}

You can create a \kw{CkCallback} object in a number of ways,
depending on what you want to have happen when the callback is
finally invoked.  The callback will be invoked with a \charmpp{}
message; but the message type will depend on the library that 
actually invokes the callback.  Check the library documentation
to see what kind of message the library will send to your callback.
In any case, you are required to free the message passed to you via
the callback.

The callbacks that go to chares require an ``entry method index'',
an integer that identifies which entry method will be called.
You can get an entry method index using the syntax:

\begin{alltt}
\kw{myIdx}=CkIndex_\uw{ChareName}::\uw{EntryMethod}(\uw{parameters});
\end{alltt}

Here, \uw{ChareName} is the name of the chare (group, or array) containing
the desired entry method, \uw{EntryMethod} is the name of that entry method,
and \uw{parameters} are the parameters taken by the method.
These parameters are only used to resolve the proper \uw{EntryMethod};
they are otherwise ignored.  An entry method index is the \charmpp{}
version of a function pointer.


There are a number of ways to build callbacks, depending on what you
want to have happen when the callback is invoked:

\begin{enumerate}
\item \kw{CkCallback(CkCallbackFn fn,void *param)} When invoked, the
callback will pass \uw{param} and the result message to the given C function,
which should have a prototype like:

\begin{alltt}
void \uw{myCallbackFn}(void *param,void *message)
\end{alltt}

This function will be called on the processor where the callback was created,
so \uw{param} is allowed to point to heap-allocated data.  Of course, you
are required to free any storage referenced by \uw{param}.

\item \kw{CkCallback(CkCallback::ignore)} When invoked, the callback
will do nothing.  This can be useful if the library requires a callback,
but you don't care when it finishes, or will find out some other way.

\item \kw{CkCallback(CkCallback::ckExit)} When invoked, the callback
will call CkExit(), ending the Charm++ program.

\item \kw{CkCallback(int ep,const CkChareID \&id)} When invoked, the 
callback will send its message to the given entry method of the given
Chare.  Note that a chare proxy will also work in place of a chare id:

\begin{alltt}
	CkCallback myCB(CkIndex_myChare::myEntry(NULL),myChareProxy);
\end{alltt}

\item \kw{CkCallback(int ep,const CkArrayID \&id)} 
When invoked,
the callback will broadcast its message to the given entry method
of the given array.  As usual, an array proxy will work just as well
as an array id.

\item \kw{CkCallback(int ep,const CkArrayIndex \&idx,const CkArrayID \&id)}
When invoked,
the callback will send its message to the given entry method
of the given array element. 

\item \kw{CkCallback(int ep,const CkGroupID \&id)} 
When invoked,
the callback will broadcast its message to the given entry method
of the given group.

\item \kw{CkCallback(int ep,int onPE,const CkGroupID \&id)}
When invoked,
the callback will send its message to the given entry method
of the given group member. 

\end{enumerate}

One final type of callback, a \kw{CkCallback(CkCallback::resumeThread)}, 
can only be used from within threaded entry methods.  This type of callback
is typically hidden within a thread-capable library, so is discussed further
in the library section.


\subsubsection{Library Interface}

Here, a ``library'' is simply any code which can be called from several
different places.  From the point of view of a library, a \kw{CkCallback}
is a destination for the library's result.  \kw{CkCallback} objects can
be freely copied, marshalled, or even sent in messages.

Postponing threads for a moment, the only thing you can do 
with a CkCallback is to move it around or send a message to it:

\begin{alltt}
//Main library entry point, called by asynchronous users:
void myLibrary(...library parameters...,const CkCallback \&cb) 
\{
  ..start some parallel computation, dragging cb along...
\}

//Internal library routine, called when computation is done
void myLibraryDone(...parameters...,const CkCallback \&cb)
\{
  ...prepare a return message...
  cb.send(msg);
\}
\end{alltt}

A \kw{CkCallback} will accept any message type, or even NULL.  The
message is immediately sent to the user's client function or entry point,
so you {\em do} need to document the type of message you will send to the 
callback so the user knows what to expect.

Threaded clients are a bit more complicated-- you need to suspend the
calling thread using ``thread\_delay'' which, after the corresponding
``send'', returns the sent message to its caller.  For example:

\begin{alltt}
//Main library entry point, called by threaded users:
myLibMsg *myThreadedLibrary(...library parameters...) 
\{
  CkCallback cb(CkCallback::resumeThread);
  myLibrary(...,cb); //Just call normal library with new cb
  return cb.thread\_delay(); //Will suspend until cb.send() is called
\}
\end{alltt}

``thread\_delay'' just immediately returns NULL for non-threaded callbacks,
so you can even combine the threaded and non-threaded interfaces
using C++'s default parameters.  For example:

\begin{alltt}
//Main library entry point, called by threaded users:
myLibMsg *myGenericLibrary(...library parameters...,
  CkCallback cb=CkCallback(CkCallback::resumeThread)) 
\{
  myLibrary(...,cb);
  //For threaded clients, suspends until cb.send, then returns message;
  // for non-threaded clients, just returns NULL:
  return cb.thread\_delay(); 
\}
\end{alltt}










