\subsection{Modules}

\subsubsection{Structure of a \charmpp\ Program}

A \charmpp\ program is structurally similar to a C++ program.  Most of
a \charmpp\ program {\em is} C++ code
\footnote{\bf Constraint: The C++ code cannot, however,
contain global or static variables.}. The main syntactic units in a
\charmpp\ program are class definitions. A \charmpp\ program can
be distributed across several source code files.

There are five disjoint categories of objects (classes) in \charmpp:
\begin{itemize}
\item Sequential objects: as in C++
\item Chares (concurrent objects) \index{chare}
\item Chare Groups \index{chare groups} (a form of replicated objects)
\index{group}
\item Chare Arrays \index{chare arrays} (an indexed collection of chares)
\index{array}
\item Messages (communication objects)\index{message}
\end{itemize}

The user's code is written in C++ and interfaces with the \charmpp\
system as if it were a library containing base classes, functions, etc.
A translator is used to generate the special code needed to handle
\charmpp\ constructs.  This translator generates C++ code that needs
to be compiled with the user's code.

Interfaces to the \charmpp\ objects (such as messages, chares, readonly 
variable etc.) \index{message}\index{chare}\index{readonly}
have to be declared in \charmpp\ interface files. Typically, such entities 
are grouped \index{module}
into {\em modules}. A \charmpp\ program may consists of multiple modules. 
One of these modules
is declared to be a \kw{mainmodule}. All the modules that are
``reachable'' from the \kw{mainmodule} via the \kw{extern} construct
are included in a \charmpp\ program.

The \charmpp\ interface file as the suffix ``.ci''. 
The \charmpp\ interface translator parses this file and produces two files 
(with suffixes ``.decl.h'' and ``.def.h'') that contain declarations 
(interface) and definitions (implementation)
of various translator-generated entities. If the name of a
module is \uw{MOD}, then the files produced by the \charmpp\ interface translator 
are named \uw{MOD.decl.h} and \uw{MOD.def.h}\footnote{Note that the interface 
file for module \uw{MOD} need not be named \uw{MOD.ci}. Indeed one ``.ci'' 
file may contain interface declarations for multiple modules, and the 
translator will produce one pair of declaration and definition files for each 
module.}.  We recommend that the declarations header file be included at the 
top of the header file (\uw{MOD.h}) for module \uw{MOD}, and the definitions 
file be included at the bottom of the code for module (\uw{MOD.C})
\footnote{In the earlier version of interface translator, these files used to 
be suffixed with ``.top.h'' and ``.bot.h'' for this reason.}.

A simple \charmpp\ program is given below:

\begin{verbatim}
///////////////////////////////////////
// File: pgm.ci

module Hello {
  mainchare HelloMain {
    entry HelloMain(); // implicit CkArgMsg * as argument
    entry [threaded] void Wait(void);
  };
  group HelloGroup {
    entry HelloGroup(void);
  } 
};

////////////////////////////////////////
// File: pgm.h
#include "Hello.decl.h" // Note: not pgm.decl.h

class HelloMain: public Chare {
  HelloMain(CkArgMsg *);
  void Wait(void);
};

class HelloGroup: public Group {
  HelloGroup(void);
};

/////////////////////////////////////////
// File: pgm.C
#include "pgm.h"

HelloMain::HelloMain(CkArgMsg *msg) {
  delete msg;
  CProxy_HelloGroup::ckNew(); //Create a new ``HelloGroup''
  CProxy_HelloMain pself(thishandle);
  pself.Wait();
}

void HelloMain::Wait(void) {
  CkWaitQD(); //Waits for ``quiescence''
  CkExit();
}

HelloGroup::HelloGroup(void) {
  ckout << "Hello World from processor " << CkMyPe() << endl;
}

#include "Hello.def.h" //Include the Charm++ object implementations

/////////////////////////////////////////
// File: Makefile

pgm: pgm.ci pgm.h pgm.C
      charmc -c pgm.ci
      charmc -c pgm.C
      charmc -o pgm pgm.o -language charm++

\end{verbatim}

\uw{HelloMain} is designated a \kw{mainchare}. Thus the Charm Kernel starts 
execution of this program by creating an instance of \uw{HelloMain} on 
processor 0. The HelloMain constructor creates a chare group \uw{HelloGroup}, and 
calls \uw{Wait} on itself asynchronously.  Both these calls return immediately
after directing Charm Kernel to perform the actual creation and invocation. 
Shortly after, the Charm Kernel will create an object of type
\uw{HelloGroup} on each processor, which will print out 
``Hello World...''.  The \uw{Wait} method 
of \uw{HelloMain} may simultainously be invoked, which  
will wait for quiescence (no activity in 
the program) and then it will exit the program.







