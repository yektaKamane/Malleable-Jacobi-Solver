\section{Completion Detection}

Completion detection is a method for automatically detecting
completion of a distributed process within an application. It is a
module, and therefore is only included when ``-module completion'' is
specified when linking your application.

Completion is reached within a distributed process when the
participating objects have produced and consumed an equal number of
events globally. The number of global events that will be produced and
consumed does not need to be known, just the number of producers is
required.

First, the detector should be constructed. This call would typically
belong in application startup code (it initializes the group that
keeps track of completion):

\begin{alltt}
CProxy_CompletionDetector detector = CProxy_CompletionDetector::ckNew();
\end{alltt}

When it is time to start completion detection, make the following call to the
library:

\begin{alltt}
void start_detection(int num_producers, CkCallback start, CkCallback finish,
int prio_)
\end{alltt}

\begin{alltt}
detector.start_detection(10, CkCallback(CkIndex_chare1::start_test(0),
                                       thisProxy),
                             CkCallback(CkIndex_chare2::finish_test(0),
                                       thisProxy), 0);
\end{alltt}

The \verb|num_producers| parameter is the number of objects (chares)
that will produce elements. So if every array element will produce one
event, then it would be the size of the array.

The \verb|start| callback notifies your program that it is safe to
begin producing and consuming (this state is reached when the module
has finished its internal initialization).

The \verb|finish| callback is instigated when completion has been
detected (all objects participating have produced and consumed an
equal number of elements globally).

The \verb|prio| parameter is the priority that the detector will run
at. This is still under development, but it should be set below the
application's priority if possible.

Once initialization is complete (the ``start'' callback is triggered),
make the following call to the library:

\begin{alltt}
void CompletionDetector::produce(int events_produced)
void CompletionDetector::produce() // 1 by default
\end{alltt}

\begin{alltt}
detector.ckLocalBranch()->produce(4);
\end{alltt}

Once all the ``events'' that this chare is going to produce have been sent out,
make the following call:

\begin{alltt}
void CompletionDetector::done(int producers_done)
void CompletionDetector::done() // 1 by default
\end{alltt}

\begin{alltt}
detector.ckLocalBranch()->done();
\end{alltt}

The application can now start consuming elements, using the following calls:

\begin{alltt}
void CompletionDetector::consume(int events_consumed)
void CompletionDetector::consume() // 1 by default
\end{alltt}

\begin{alltt}
detector.ckLocalBranch()->consume();
\end{alltt}

At some point, when everyone is consuming elements, completion will be
reached. The system will detect that state and will trigger the \verb|finish|
callback. At that point, \verb|start_detection| can be called again to restart
the process.

\section{Quiescence Detection}
\label{sec:qd}

In \charmpp, \index{quiescence}quiescence is defined as the state in which no
processor is executing an entry point, and no messages are awaiting processing.

\charmpp\ provides two facilities for detecting quiescence: \kw{CkStartQD} and
\kw{CkWaitQD}.

\kw{CkStartQD} registers with the system a callback that should be made the
next time \index{quiescence}quiescence is detected.  \kw{CkStartQD} has two
variants which expect the following arguments: 
\begin{enumerate}
\item An index corresponding to the entry function that is to be called,
and a handle to the chare on which that entry function should be called.  The
syntax of this call looks like this:

\begin{alltt}
 CkStartQD(int Index,const CkChareID* chareID);
\end{alltt}

To retrieve the corresponding index of a particular \index{entry method}entry
method, you must use a static method contained within the \uw{CkIndex} object
corresponding to the \index{chare}chare containing that entry method.  The
syntax of this call is as follows:

\begin{alltt}
\kw{myIdx}=CkIndex_\uw{ChareClass}::\uw{EntryMethod}(\uw{parameters});
\end{alltt}

where \uw{ChareClass} is the C++ class of the chare containing
the desired entry method, \uw{EntryMethod} is the name of that entry method,
and \uw{parameters} are the parameters taken by the method.
These parameters are only used to resolve the proper \uw{EntryMethod};
they are otherwise ignored.

\item 
A \uw{CkCallback} object. The syntax of this call looks like:
\begin{alltt}
  CkStartQD(const CkCallback& cb);
\end{alltt}

Upon quiescence detection, specified callback is called with no parameters.

\end{enumerate}


\kw{CkWaitQD}, by contrast, does not register a callback.  Rather,
\kw{CkWaitQD} blocks and does not return until \index{quiescence}quiescence is
detected.  It takes no parameters and returns no value.  A call to
\kw{CkWaitQD} simply looks like this: 

\begin{alltt}
  CkWaitQD();
\end{alltt}

Keep in mind that \kw{CkWaitQD} should only be called from threaded
\index{entry method}entry methods because a call to \kw{CkWaitQD} suspends the
current thread of execution, and if it were called outside of a threaded entry
method it would suspend the main thread of execution of the processor from
which \kw{CkWaitQD} was called and the entire program would come to a grinding
halt on that processor.

\function{void CkExitAfterQuiescence()} \index{CkExitAfterQuiescence}
\desc{This call informs the Charm RTS that computation on all processors
should terminate as soon as the machine becomes completely idle--that is,
after all messages and entry methods are finished.  This is the state of 
quiescence, as described further in Section~\ref{sec:qd}.
This routine returns immediately.}

