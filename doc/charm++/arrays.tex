\subsection{Basic Arrays}

\label{basic arrays}

Arrays \index{arrays} are arbitrarily-sized collections of chares.  The
entire array has a globally unique identifier of type \kw{CkArrayID}, and
each element has a unique index of type \kw{CkArrayIndex}.  A \kw{CkArrayIndex}
can be a single integer (i.e. 1D array), several integers (i.e. a
multidimensional array), or an arbitrary string of bytes (e.g. a binary tree
index).

Array elements can be dynamically created and destroyed on any processor,
and messages for the elements will still arrive properly.
Array elements can be migrated at any time, allowing arrays to be efficiently
load balanced.  Array elements can also receive array broadcasts and
contribute to array reductions.

\subsubsection{Declaring a 1D Array}

You can declare a one-dimensional \index{array}\index{chare array}chare array
as:

\begin{alltt}
//In the .ci file:
array [1D] A \{
  entry A(\uw{parameters1});
  entry void someEntry(\uw{parameters2});
\};
\end{alltt}

Just as every Chare inherits from the system class \kw{CBase}\_\uw{ClassName}, every 
array element inherits from the system class \kw{CBase}\_\uw{ClassName}.
Just as a Chare inherits ``thishandle'', each
array element inherits ``thisArrayID'', the \kw{CkArrayID} of its array,
and ``thisIndex'', the element's array index.
As well as chares are allowed to inherit directly from class \kw{Chare},
array elements are allowed to inherit from \kw{ArrayElement1D} if 1D array,
\kw{ArrayElement2D} if 2D array, and so on up to 6D.

\begin{alltt}
class A : public CBase\_A \{
  public:
    A(\uw{parameters1});
    A(CkMigrateMessage *);

    void someEntry(\uw{parameters2});
\};
\end{alltt}

Note \uw{A}'s odd migration constructor, which is normally empty:

\begin{alltt}
//In the .C file:
A::A(void)
\{
  //...your constructor code...
\}
A::A(CkMigrateMessage *m) \{ \}
\end{alltt}

Read the section ``Migratable Array Elements'' for more
information on the \kw{CkMigrateMessage} constructor. 


\subsubsection{Creating a Simple Array}

\label{basic array creation}

You always create an array using the \kw{CProxy\_Array::ckNew}
routine.  This returns a proxy object, which can
be kept, copied, or sent in messages.
To create a 1D \index{array}array containing elements indexed 
(0, 1, ..., \uw{num\_elements}-1), use:

\begin{alltt}
CProxy_A1 a1 = CProxy_A1::ckNew(\uw{parameters},num_elements);
\end{alltt}

The constructor is invoked on each array element.
For creating higher-dimensional arrays, or for more options
when creating the array, see section~\ref{advanced array create}.


\subsubsection{Messages}

An array proxy responds to the appropriate index call--
for 1D arrays, use [i] or (i); for 2D use (x,y); for 3D
use (x,y,z); and for user-defined types use [f] or (f).

To send a \index{Array message} message to an array element, index the proxy 
and call the method name:

\begin{alltt}
a1[i].doSomething(\uw{parameters});
a3(x,y,z).doAnother(\uw{parameters});
aF[CkArrayIndexFoo(...)].doAgain(\uw{parameters});
\end{alltt}

You may invoke methods on array elements that have not yet
been created-- by default, the system will buffer the message until the
element is created\footnote{However, the element must eventually be 
created-- i.e., within a 3-minute buffering period.}.

Messages are not guarenteed to be delivered in order.
For example, if I invoke a method A, then method B;
it is possible for B to be executed before A.

\begin{alltt}
a1[i].A();
a1[i].B();
\end{alltt}

Messages sent to migrating elements will be delivered after
the migrating element arrives.  It is an error to send 
a message to a deleted array element.


\subsubsection{Broadcasts}

To \index{Array broadcast} broadcast a message to all the current elements of an array, 
simply omit the index, as:

\begin{alltt}
a1.doIt(\uw{parameters}); //<- invokes doIt on each array element
\end{alltt}

The broadcast message will be delivered to every existing array 
element exactly once.  Broadcasts work properly even with ongoing
migrations, insertions, and deletions.


\subsubsection{Reductions on Chare Arrays}

A \index{array reduction}reduction applies a single operation (e.g. add,
max, min, ...) to data items scattered across many processors and
collects the result in one place.  \charmpp{} supports reductions on the
elements of a Chare array.

The data to be reduced comes from each array element, 
which must call the \kw{contribute} method:

\begin{alltt}
ArrayElement::contribute(int nBytes,const void *data,CkReduction::reducerType type);
\end{alltt}

Reductions are described in more detail in Section~\ref{reductions}.


\subsubsection{Destroying Arrays}

To destroy an array element-- detach it from the array,
call its destructor, and release its memory--invoke its 
\kw{Array destroy} method, as:

\begin{alltt}
a1[i].ckDestroy();
\end{alltt}

You must ensure that no messages are sent to a deleted element. 
After destroying an element, you may insert a new element at
its index.




\subsection{Advanced Arrays}

\label{advanced arrays}

The basic array features described above (creation, messaging,
broadcasts, and reductions) are needed in almost every
\charmpp{} program.  The more advanced techniques that follow
are not universally needed; but are still often useful.


\subsubsection{Declaring Multidimensional, or User-defined Index Arrays}

\charmpp{} contains direct support for multidimensional and
even user-defined index arrays.  These arrays can be declared as:

\begin{alltt}
//In the .ci file:
message MyMsg;
array [1D] A1 \{ entry A1(); entry void e(\uw{parameters});\}
array [2D] A2 \{ entry A2(); entry void e(\uw{parameters});\}
array [3D] A3 \{ entry A3(); entry void e(\uw{parameters});\}
array [4D] A4 \{ entry A4(); entry void e(\uw{parameters});\}
array [5D] A5 \{ entry A5(); entry void e(\uw{parameters});\}
array [6D] A6 \{ entry A6(); entry void e(\uw{parameters});\}
array [Foo] AF \{ entry AF(); entry void e(\uw{parameters});\}
\end{alltt}

The last declaration expects an array index of type \kw{CkArrayIndex}\uw{Foo},
which must be defined before including the \texttt{.decl.h} file 
(see ``User-defined array index type'' below).  

\begin{alltt}
//In the .h file:
class A1 : public CBase\_A1 \{ public: A1()\{\} ...\};
class A2 : public CBase\_A2 \{ public: A2()\{\} ...\};
class A3 : public CBase\_A3 \{ public: A3()\{\} ...\};
class A4 : public CBase\_A4 \{ public: A4()\{\} ...\};
class A5 : public CBase\_A5 \{ public: A5()\{\} ...\};
class A6 : public CBase\_A6 \{ public: A6()\{\} ...\};
class AF : public CBase\_AF \{ public: AF()\{\} ...\};
\end{alltt}

A 1D array element can access its index via its inherited ``thisIndex''
field; a 2D via ``thisIndex.x'' and ``thisIndex.y'', and a 3D via
``thisIndex.x'', ``thisIndex.y'', and ``thisIndex.z''. The subfields
of 4D, 5D, and 6D are respectively \{w,x,y,z\}, \{v,w,x,y,z\}, and 
\{x1,y1,z1,x2,y2,z2\}.
A user-defined index array can access its index as ``thisIndex''.


Likewise, you can create a dense multidimensional array by passing the 
extents at creation time to \kw{ckNew}.

\begin{alltt}
CProxy_A1 a1 = CProxy_A1::ckNew(parameters, num_elements);
CProxy_A2 a2 = CProxy_A2::ckNew(parameters, num_rows, num_colums);
CProxy_A3 a3 = CProxy_A3::ckNew(parameters, num_rows, num_columns, num_depth);
\end{alltt}

For 4D, 5D, 6D and user-defined arrays, this functionality cannot be used. 
You need to insert the array elements individually (Section~\ref{dynamic_insertion}).

\subsubsection{Advanced Array Creation}

\label{advanced array create}
There are several ways to control the array creation process.
You can adjust the map and bindings before creation, change
the way the initial array elements are created, create elements
explicitly during the computation, and create elements implicitly,
``on demand''.  

You can create all your elements using any one of these methods,
or create different elements using different methods.  
An array element has the same syntax and semantics no matter
how it was created.


\subsubsection{Advanced Array Creation: CkArrayOptions}

\index{CkArrayOptions}
\label{CkArrayOptions}

The array creation method \kw{ckNew} actually takes a parameter
of type \kw{CkArrayOptions}.  This object describes several
optional attributes of the new array.

The most common form of \kw{CkArrayOptions} is to set the number
of initial array elements.  A \kw{CkArrayOptions} object will be 
constructed automatically in this special common case.  Thus
the following code segments all do exactly the same thing:

\begin{alltt}
//Implicit CkArrayOptions
  a1=CProxy_A1::ckNew(\uw{parameters},nElements);

//Explicit CkArrayOptions
  a1=CProxy_A1::ckNew(\uw{parameters},CkArrayOptions(nElements));

//Separate CkArrayOptions
  CkArrayOptions opts(nElements);
  a1=CProxy_A1::ckNew(\uw{parameters},opts);
\end{alltt}

Note that the ``numElements'' in an array element is simply the
numElements passed in when the array was created.  The true number of
array elements may grow or shrink during the course of the
computation, so numElements can become out of date.  This ``bulk''
constructor approach should be preferred where possible, especially
for large arrays.  Bulk construction is handled via a broadcast which
will be significantly more efficient in the number of messages
required than inserting each element individually which will require
one message send per element.

\kw{CkArrayOptions} contains a few flags that the runtime can use to
optimize handling of a given array. If the array elements will only
migrate at controlled points (such as periodic load balancing with
{\tt AtASync()}), this is signalled to the runtime by calling {\tt
  opts.setAnytimeMigration(false)}\footnote{At present, this optimizes
broadcasts to not save old messages for immigrating chares.}. If all
array elements will be inserted by bulk creation or by {\tt
  fooArray[x].insert()} calls, signal this by calling {\tt
  opts.setStaticInsertion(true)} \footnote{This can enable a slightly
  faster default mapping scheme.}.

\subsubsection{Advanced Array Creation: Map Object}

\index{array map}
\label{array map}

You can use \kw{CkArrayOptions} to specify a ``map object''
for an array.  The map object is used by the array manager
to determine the ``home'' processor of each element.  The
home processor is the processor responsible for maintaining
the location of the element.

There is a default map object, which maps 1D array indices
in a round-robin fashion to processors, and maps other array
indices based on a hash function.

A custom map object is implemented as a group which inherits from
\kw{CkArrayMap} and defines these virtual methods:

\begin{alltt}
class CkArrayMap : public Group
\{
public:
  //...
  
  //Return an ``arrayHdl'', given some information about the array
  virtual int registerArray(CkArrayIndexMax& numElements,CkArrayID aid);
  //Return the home processor number for this element of this array
  virtual int procNum(int arrayHdl,const CkArrayIndex &element);
\}
\end{alltt}

For example, a simple 1D blockmapping scheme.  Actual mapping is
handled in the procNum function.

\begin{alltt}
class BlockMap : public CkArrayMap 
\{
 public:
  BlockMap(void) \{\}
  BlockMap(CkMigrateMessage *m)\{\}
  int registerArray(CkArrayIndexMax& numElements,CkArrayID aid) \{
    return 0;
  \}
  int procNum(int /*arrayHdl*/,const CkArrayIndex &idx) \{
    int elem=*(int *)idx.data();
    int penum =  (elem/(32/CkNumPes()));
    return penum;
  \}
\};

\end{alltt}
Once you've instantiated a custom map object, you can use it to
control the location of a new array's elements using the
\kw{setMap} method of the \kw{CkArrayOptions} object described above.
For example, if you've declared a map object named ``blockMap'':

\begin{alltt}
//Create the map group
  CProxy_blockMap myMap=CProxy_blockMap::ckNew();
//Make a new array using that map
  CkArrayOptions opts(nElements);
  opts.setMap(myMap);
  a1=CProxy_A1::ckNew(\uw{parameters},opts);
\end{alltt}



\subsubsection{Advanced Array Creation: Initial Elements}

\index{array initial}
\label{array initial}

The map object described above can also be used to create
the initial set of array elements in a distributed fashion.
An array's initial elements are created by its map object,
by making a call to \kw{populateInitial} on each processor.

You can create your own set of elements by creating your
own map object and overriding this virtual function of \kw{CkArrayMap}:

\begin{alltt}
  virtual void populateInitial(int arrayHdl,int numInitial,
	void *msg,CkArrMgr *mgr)
\end{alltt}

In this call, \kw{arrayHdl} is the value returned by \kw{registerArray},
\kw{numInitial} is the number of elements passed to \kw{CkArrayOptions},
\kw{msg} is the constructor message to pass, and \kw{mgr} is the
array to create.

\kw{populateInitial} creates new array elements using the method
\kw{void CkArrMgr::insertInitial(CkArrayIndex idx,void *ctorMsg)}.
For example, to create one row of 2D array elements on each processor,
you would write:

\begin{alltt}
void xyElementMap::populateInitial(int arrayHdl,int numInitial,
	void *msg,CkArrMgr *mgr)
\{
  if (numInitial==0) return; //No initial elements requested
	
  //Create each local element
  int y=CkMyPe();
  for (int x=0;x<numInitial;x++) \{
    mgr->insertInitial(CkArrayIndex2D(x,y),CkCopyMsg(&msg));
  \}
  mgr->doneInserting();
  CkFreeMsg(msg);
\}
\end{alltt}

Thus calling \kw{ckNew(10)} on a 3-processor machine would result in
30 elements being created.


\subsubsection{Advanced Array Creation: Bound Arrays}

\experimental{}
\index{bound arrays} \index{bindTo}
\label{bound arrays}
You can ``bind'' a new array to an existing array
using the \kw{bindTo} method of \kw{CkArrayOptions}.  Bound arrays
act like separate arrays in all ways except for migration--
corresponding elements of bound arrays always migrate together.
For example, this code creates two arrays A and B which are
bound together-- A[i] and B[i] will always be on the same processor.

\begin{alltt}
//Create the first array normally
  aProxy=CProxy_A::ckNew(\uw{parameters},nElements);
//Create the second array bound to the first
  CkArrayOptions opts(nElements);
  opts.bindTo(aProxy);
  bProxy=CProxy_B::ckNew(\uw{parameters},opts);
\end{alltt}

An arbitrary number of arrays can be bound together--
in the example above, we could create yet another array
C and bind it to A or B.  The result would be the same
in either case-- A[i], B[i], and C[i] will always be
on the same processor.

There is no relationship between the types of bound arrays--
it is permissible to bind arrays of different types or of the
same type.  It is also permissible to have different numbers
of elements in the arrays, although elements of A which have
no corresponding element in B obey no special semantics.
Any method may be used to create the elements of any bound
array.

Bound arrays are often useful if A[i] and B[i] perform different 
aspects of the same computation, and thus will run most efficiently 
if they lie on the same processor.  Bound array elements are guaranteed
to always be able to interact using \kw{ckLocal} (see 
section~\ref{ckLocal for arrays}), although the local pointer must
be refreshed after any migration. This should be done during the \kw{pup}
routine. When migrated, all elements that are bound together will be created
at the new processor before \kw{pup} is called on any of them, ensuring that
a valid local pointer to any of the bound objects can be obtained during the
\kw{pup} routine of any of the others.

For example, an array {\it Alibrary} is implemented as a library module.
It implements a certain functionality by operating on a data array {\it dest}
which is just a pointer to some user provided data.
A user defined array {\it UserArray} is created and bound to 
the array {\it Alibrary} to take advanatage of the functionality provided 
by the library.
When bound array element migrated, the {\it data} pointer in {\it UserArray}
is re-allocated in {\it pup()}, thus {\it UserArray} is responsible to refresh
the pointer {\it dest} stored in {\it Alibrary}.

\begin{alltt}
class Alibrary: public CProxy_Alibrary \{
public:
  ...
  void set_ptr(double *ptr) \{ dest = ptr; \}
  virtual void pup(PUP::er &p);
private:
  double *dest;           // point to user data in user defined bound array
\};

class UserArray: public CProxy_UserArray \{
public:
  virtual void pup(PUP::er &p) \{
                p|len;
                if(p.isUnpacking()) \{ 
                  data = new double[len];
                  Alibrary *myfellow = AlibraryProxy(thisIndex).ckLocal();
                  myfellow->set_ptr(data);    // refresh data in bound array
                \}
                p(data, len);
  \}
private:
  CProxy_Alibrary  AlibraryProxy;   // proxy to my bound array
  double *data;          // user allocated data pointer
  int len;
\};
\end{alltt}


\subsubsection{Advanced Array Creation: Dynamic Insertion}

\label{dynamic_insertion}

In addition to creating initial array elements using ckNew,
you can also
create array elements during the computation.

You insert elements into the array by indexing the proxy
and calling insert.  The insert call optionally takes 
parameters, which are passed to the constructor; and a
processor number, where the element will be created.
Array elements can be inserted in any order from 
any processor at any time.  Array elements need not 
be contiguous.

If using \kw{insert} to create all the elements of the array,
you must call \kw{CProxy\_Array::doneInserting} before using
the array.

\begin{alltt}
//In the .C file:
int x,y,z;
CProxy_A1 a1=CProxy_A1::ckNew();  //Creates a new, empty 1D array
for (x=...) \{
   a1[x  ].insert(\uw{parameters});  //Bracket syntax
   a1(x+1).insert(\uw{parameters});  // or equivalent parenthesis syntax
\}
a1.doneInserting();

CProxy_A2 a2=CProxy_A2::ckNew();   //Creates 2D array
for (x=...) for (y=...)
   a2(x,y).insert(\uw{parameters});  //Can't use brackets!
a2.doneInserting();

CProxy_A3 a3=CProxy_A3::ckNew();   //Creates 3D array
for (x=...) for (y=...) for (z=...)
   a3(x,y,z).insert(\uw{parameters});
a3.doneInserting();

CProxy_AF aF=CProxy_AF::ckNew();   //Creates user-defined index array
for (...) \{
   aF[CkArrayIndexFoo(...)].insert(\uw{parameters}); //Use brackets...
   aF(CkArrayIndexFoo(...)).insert(\uw{parameters}); //  ...or parenthesis
\}
aF.doneInserting();

\end{alltt}

The \kw{doneInserting} call starts the reduction manager (see ``Array
Reductions'') and load balancer (see ~\ref{lbFramework})-- since
these objects need to know about all the array's elements, they
must be started after the initial elements are inserted.
You may call \kw{doneInserting} multiple times, but only the first
call actually does anything.  You may even \kw{insert} or \kw{destroy}
elements after a call to \kw{doneInserting}, with different semantics-- 
see the reduction manager and load balancer sections for details.

If you do not specify one, the system will choose a procesor to 
create an array element on based on the current map object.



\subsubsection{Advanced Array Creation: Demand Creation}

Normally, invoking an entry method on a nonexistant array
element is an error.  But if you add the attribute
\index{createhere} \index{createhome}
\kw{[createhere]} or \kw{[createhome]} to an entry method,
 the array manager will 
``demand create'' a new element to handle the message.  

With \kw{[createhome]}, the new element
will be created on the home processor, which is most efficient when messages for
the element may arrive from anywhere in the machine. With \kw{[createhere]},
the new element is created on the sending processor, which is most efficient
if when messages will often be sent from that same processor.

The new element is created by calling its default (taking no
paramters) constructor, which must exist and be listed in the .ci file.
A single array can have a mix of demand-creation and
classic entry methods; and demand-created and normally 
created elements.



\subsubsection{User-defined array index type}

\index{Array index type, user-defined}
\charmpp{} array indices are arbitrary collections of integers.
To define a new array index, you create an ordinary C++ class 
which inherits from \kw{CkArrayIndex} and sets the ``nInts'' member
to the length, in integers, of the array index.

For example, if you have a structure or class named ``Foo'', you 
can use a \uw{Foo} object as an array index by defining the class:

\begin{alltt}
#include <charm++.h>
class CkArrayIndexFoo:public CkArrayIndex \{
    Foo f;
public:
    CkArrayIndexFoo(const Foo \&in) 
    \{
        f=in;
        nInts=sizeof(f)/sizeof(int);
    \}
    //Not required, but convenient: cast-to-foo operators
    operator Foo &() \{return f;\}
    operator const Foo &() const \{return f;\}
\};
\end{alltt}

Note that \uw{Foo}'s size must be an integral number of integers--
you must pad it with zero bytes if this is not the case.
Also, \uw{Foo} must be a simple class-- it cannot contain 
pointers, have virtual functions, or require a destructor.
Finally, there is a \charmpp\ configuration-time option called
CK\_ARRAYINDEX\_MAXLEN \index{CK\_ARRAYINDEX\_MAXLEN} 
which is the largest allowable number of 
integers in an array index.  The default is 3; but you may 
override this to any value by passing ``-DCK\_ARRAYINDEX\_MAXLEN=n'' 
to the \charmpp\ build script as well as all user code. Larger 
values will increase the size of each message.

You can then declare an array indexed by \uw{Foo} objects with

\begin{alltt}
//in the .ci file:
array [Foo] AF \{ entry AF(); ... \}

//in the .h file:
class AF : public CBase\_AF
\{ public: AF() \{\} ... \}

//in the .C file:
    Foo f;
    CProxy_AF a=CProxy_AF::ckNew();
    a[CkArrayIndexFoo(f)].insert();
    ...
\end{alltt}

Note that since our CkArrayIndexFoo constructor is not declared
with the explicit keyword, we can equivalently write the last line as:

\begin{alltt}
    a[f].insert();
\end{alltt}

When you implement your array element class, as shown above you 
can inherit from \kw{CBase}\_\uw{ClassName}, 
a class templated by the index type \uw{Foo}. In the old syntax,
you could also inherit directly from \kw{ArrayElementT}.
The array index (an object of type \uw{Foo}) is then accessible as 
``thisIndex''. For example:

\begin{alltt}

//in the .C file:
AF::AF()
\{
    Foo myF=thisIndex;
    functionTakingFoo(myF);
\}
\end{alltt}


\subsubsection{Migratable Array Elements}

\label{arraymigratable}
Array objects can \index{migrate}migrate from one PE to another.
For example, the load balancer (see section~\ref{lbFramework})
might migrate array elements to better balance the load between
processors.  For an array element to migrate, it must implement
a pack/unpack or ``pup'' method:

\begin{alltt}
//In the .h file:
class A2 : public CBase\_A2 \{
private: //My data members:
    int nt;
    unsigned char chr;
    float flt[7];
    int numDbl;
    double *dbl;
public:	
    //...other declarations

    virtual void pup(PUP::er \&p);
\};

//In the .C file:
void A2::pup(PUP::er \&p)
\{
    CBase\_A2::pup(p); //<- MUST call superclass's pup routine
    p|nt;
    p|chr;
    p(flt,7);
    p|numDbl;
    if (p.isUnpacking()) dbl=new double[numDbl];
    p(dbl,numDbl);
\}
\end{alltt}

Please note that if your object contains Structured Dagger code (see section ``Structured Dagger'') you must use the following syntax to correctly pup the object:

\begin{alltt}
class bar: public CBase\_bar \{
 private:
    int a,b;
 public:
    bar_SDAG_CODE 
    ...other methods...

    virtual void pup(PUP::er& p) \{
      __sdag_pup(p);
      ...pup other data here...
    \}
\};
\end{alltt}

See the \index{PUP} section ``PUP'' for more details on pup routines
and the \kw{PUP::er} type.

The system uses one pup routine to do both packing and unpacking by
passing different types of \kw{PUP::er}s to it.  You can determine
what type of \kw{PUP::er} has been passed to you with the
\kw{isPacking()}, \kw{isUnpacking()}, and \kw{isSizing()} calls.

An array element can migrate by calling the \kw{migrateMe}(\uw{destination
processor}) member function-- this call must be the last action
in an element entry point.  The system can also migrate array elements
for load balancing (see the section~\ref{lbarray}).

To migrate your array element to another processor, the \charmpp{}
runtime will:

\begin{itemize}
\item Call your \kw{ckAboutToMigrate} method
\item Call your \uw{pup} method with a sizing \kw{PUP::er} to determine how 
big a message it needs to hold your element.
\item Call your \uw{pup} method again with a packing \kw{PUP::er} to pack 
your element into a message.
\item Call your element's destructor (killing off the old copy).
\item Send the message (containing your element) across the network.
\item Call your element's migration constructor on the new processor.
\item Call your \uw{pup} method on with an unpacking \kw{PUP::er} to unpack 
the element.
\item Call your \kw{ckJustMigrated} method
\end{itemize}

Migration constructors, then, are normally empty-- all the unpacking
and allocation of the data items is done in the element's \uw{pup} routine.
Deallocation is done in the element destructor as usual.


\subsubsection{Load Balancing Chare Arrays}

see section~\ref{lbFramework}


\subsubsection{Local Access}

\experimental{}
\index{ckLocal for arrays}
\label{ckLocal for arrays}
You can get direct access to a local array element using the
proxy's \kw{ckLocal} method, which returns an ordinary \CC\ pointer
to the element if it exists on the local processor; and NULL if
the element does not exist or is on another processor.

\begin{alltt}
A1 *a=a1[i].ckLocal();
if (a==NULL) //...is remote-- send message
else //...is local-- directly use members and methods of a
\end{alltt}

Note that if the element migrates or is deleted, any pointers 
obtained with \kw{ckLocal} are no longer valid.  It is best,
then, to either avoid \kw{ckLocal} or else call \kw{ckLocal} 
each time the element may have migrated; e.g., at the start 
of each entry method.


\subsubsection{Array Section}

\experimental{}
\label{array section}

\charmpp{} supports array section which is a subset of array 
elements in a chare array. \charmpp{} also supports array sections
which are a subset of array elements in multiple chare arrays of the
same type \ref{cross array section}.
A special proxy for an array section can be created given a list of array
indexes of elements.
Multicast operations are directly supported in array section proxy with
an unoptimized direct-sending implementation.
Section reduction is not directly supported by the section proxy. 
However, an optimized section multicast/reduction 
library called ''CkMulticast'' is provided as a separate library module,
which can be plugged in as a delegation of a section proxy for performing
section-based multicasts and reductions. 

For each chare array "A" declared in a ci file, a section proxy 
of type "CProxySection\_A" is automatically generated in the decl and def 
header files. 
In order to create an array section, a user needs to provide array indexes 
of all the array section members.
You can create an array section proxy in your application by 
invoking ckNew() function of the CProxySection.
For example, for a 3D array:

\begin{alltt}
  CkVec<CkArrayIndex3D> elems;    // add array indices
  for (int i=0; i<10; i++)
    for (int j=0; j<20; j+=2)
      for (int k=0; k<30; k+=2)
         elems.push_back(CkArrayIndex3D(i, j, k));
  CProxySection_Hello proxy = CProxySection_Hello::ckNew(helloArrayID, elems.getVec(), elems.size());
\end{alltt}

Alternatively, one can do the same thing by providing [lbound:ubound:stride] 
for each dimension:

\begin{alltt}
  CProxySection_Hello proxy = CProxySection_Hello::ckNew(helloArrayID, 0, 9, 1, 0, 19, 2, 0, 29, 2);
\end{alltt}

The above codes create a section proxy that contains array elements of 
[0:9, 0:19:2, 0:29:2].

For user-defined array index other than CkArrayIndex1D to CkArrayIndex6D,
one needs to use the generic array index type: CkArrayIndexMax.

\begin{alltt}
  CkArrayIndexMax *elems;    // add array indices
  int numElems;
  CProxySection_Hello proxy = CProxySection_Hello::ckNew(helloArrayID, elems, numElems);
\end{alltt}

Once you have the array section proxy, you can do multicast to all the 
section members, or send messages to one member using its index that
is local to the section, like these:

\begin{alltt}
  CProxySection_Hello proxy;
  proxy.someEntry(...)          // multicast
  proxy[0].someEntry(...)       // send to the first element in the section.
\end{alltt}

You can move the section proxy in a message to another processor, and still 
safely invoke the entry functions to the section proxy.

In the multicast example above, for a section with k members, total number 
of k messages will be sent to all the memebers, which is considered 
inefficient when several members are on a same processor, in which 
case only one message needs to be sent to that processor and delivered to
all section members on that processor locally. To support this optimization,
a separate library called CkMulticast is provided. This library also supports
section based reduction.

Note: Use of the bulk array constructor (dimensions given in the CkNew
or CkArrayOptions rather than individual insertion) will allow
construction to race ahead of several other startup procedures, this
creates some limitation on the construction delegation and use of
array section proxies.  For safety, array sections should be
created in a post constructor entry method.


\label {array_section_multicast}


To use the library, you need to compile and install CkMulticast library and 
link your applications against the library using -module:

\begin{alltt}
  # compile and install the CkMulticast library, do this only once
  cd charm/net-linux/tmp
  make multicast

  # link CkMulticast library using -module when compiling application
  charmc  -o hello hello.o -module CkMulticast -language charm++ 
\end{alltt}

CkMulticast library is implemented using delegation(Sec. ~\ref{delegation}). 
A special ''CkMulticastMgr'' Chare Group is created as a 
deletegation for section multicast/reduction - all the messages sent
by the section proxy will be passed to the local delegation branch.

To use the CkMulticast delegation, one needs to create the CkMulticastMgr Group 
first, and then setup the delegation relationship between the section proxy and 
CkMulticastMgr Group. 
One only needs to create one CkMulticastMgr Group globally.
CkMulticastMgr group can serve all multicast/reduction delegations
for different array sections in an application:

\begin{alltt}
  CProxySection_Hello sectProxy = CProxySection_Hello::ckNew(...);
  CkGroupID mCastGrpId = CProxy_CkMulticastMgr::ckNew();
  CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(mCastGrpId).ckLocalBranch();

  sectProxy.ckSectionDelegate(mCastGrp);  // initialize section proxy

  sectProxy.someEntry(...)           //multicast via delegation library as before
\end{alltt}

By default, CkMulticastMgr group builds a spanning tree for multicast/reduction
with a factor of 2 (binary tree).
One can specify a different factor when creating a CkMulticastMgr group.
For example,

\begin{alltt}
  CkGroupID mCastGrpId = CProxy_CkMulticastMgr::ckNew(3);   // factor is 3
\end{alltt}

Note, to use CkMulticast library, all multicast messages must inherit from 
CkMcastBaseMsg, as the following.
Note that CkMcastBaseMsg must come first, this is IMPORTANT for CkMulticast 
library to retrieve section information out of the message.


\begin{alltt}
class HiMsg : public CkMcastBaseMsg, public CMessage_HiMsg
\{
public:
  int *data;
\};
\end{alltt}

Due to this restriction, you need to define message explicitly for multicast 
entry functions and no parameter marshalling can be used for multicast with 
CkMulticast library.

\paragraph{Array Section Reduction} 

Since an array element can be members for multiple array sections, 
there has to be a way for each array element to tell for which array
section it wants to contribute. For this purpose, a data structure 
called ''CkSectionInfo'' is created by CkMulticastMgr for each 
array section that the array element belongs to.
When doing section reduction, the array element needs to pass the 
\kw{CkSectionInfo} as a parameter in the \kw{contribute()}. 
The \kw{CkSectionInfo} can be retrieved
from a message in a multicast entry function using function call 
\kw{CkGetSectionInfo}:

\begin{alltt}
  CkSectionInfo cookie;

  void SayHi(HiMsg *msg)
  \{
    CkGetSectionInfo(cookie, msg);     // update section cookie every time
    int data = thisIndex;
    mcastGrp->contribute(sizeof(int), &data, CkReduction::sum_int, cookie);
  \}
\end{alltt}

Note that the cookie cannot be used as a one-time local variable in the 
function, the same cookie is needed for the next contribute. This is 
because cookie includes some context sensive information for example the 
reduction counter. Function \kw{CkGetSectionInfo()} only update some part 
of the data in cookie, not creating a brand new one.

Similar to array reduction, to use section based reduction, a reduction
client CkCallback object need to be created. You may pass the client callback 
as an additional parameter to \kw{contribute}. If different contribute calls 
pass different callbacks, some (unspecified, unreliable) callback will be 
chosen for use. See the followin example:

\begin{alltt}
    CkCallback cb(CkIndex_myArrayType::myReductionEntry(NULL),thisProxy); 
    mcastGrp->contribute(sizeof(int), &data, CkReduction::sum_int, cookie, cb);
\end{alltt}

If no member passes a callback to contribute, the reduction will use the 
default callback. You set the default callback for an array section using the 
\kw{setReductionClient} call by the section root member. A 
{\bf CkReductionMsg} message will be passed to this callback, which 
must delete the message when done.

\begin{alltt}
  CProxySection_Hello sectProxy;
  CkMulticastMgr *mcastGrp = CProxy_CkMulticastMgr(mCastGrpId).ckLocalBranch();
  mcastGrp->setReductionClient(sectProxy, new CkCallback(...));
\end{alltt}

Same as in array reduction, users can use built-in reduction 
types(Section~\ref{builtin_reduction}) or define his/her own reducer functions
(Section~\ref{new_type_reduction}).

\paragraph{Array section multicast/reduction when migration happens}

Using multicast/reduction, you don't need to worry about array migrations.
When migration happens, array element in the array section can still use 
the \kw{CkSectionInfo} it stored previously for doing reduction. 
Reduction messages will be correctly delivered but may not be as efficient 
until a new multicast spanning tree is rebuilt internally 
in \kw{CkMulticastMgr} library. 
When a new spanning tree is rebuilt, a updated \kw{CkSectionInfo} is 
passed along with a multicast message, 
so it is recommended that 
\kw{CkGetSectionInfo()} function is always called when a multicast 
message arrives (as shown in the above SayHi example).

In case when a multicast root migrates, one needs to reconstruct the 
spanning tree to get optimal performance. One will get the following
warning message if not doing so:
"Warning: Multicast not optimized after multicast root migrated."
In current implementation, user needs to initiate the rebuilding process
like:

\begin{alltt}
void Foo::pup(PUP::er & p) {
    // if I am multicast root and it is unpacking
   if (ismcastroot && p.isUnpacking()) {
      CProxySection_Foo   fooProxy;    // proxy for the section
      CkMulticastMgr *mg = CProxy_CkMulticastMgr(mCastGrpId).ckLocalBranch();
      mg->resetSection(fooProxy);
        // you may want to reset reduction client to root
      CkCallback *cb = new CkCallback(...);
      mg->setReductionClient(mcp, cb);
   }
}
\end{alltt}

\paragraph{Cross Array Sections}


\experimental{}
\label{cross array section}

Cross array sections contain elements from multiple arrays.
Construction and use of cross array sections is similar to normal
array sections with the following restrictions.  

\begin{itemize}

\item Arrays in a section my all be of the same type.

\item Each array must be enumerated by array ID

\item The elements within each array must be enumerated explicitly

\item No existing modules currently support delegation of cross
  section proxies.  Therefore reductions are not currently supported.

\end{itemize}

Note: cross section logic also works for groups with analogous characteristics.

Given three arrays declared thusly:

\begin{alltt}
	  CkArrayID *aidArr= new CkArrayID[3];
	  CProxy\_multisectiontest\_array1d *Aproxy= new CProxy\_multisectiontest\_array1d[3];
	  for(int i=0;i<3;i++)
	    \{
	      Aproxy[i]=CProxy\_multisectiontest\_array1d::ckNew(masterproxy.ckGetGroupID(),ArraySize);	  
	      aidArr[i]=Aproxy[i].ckGetArrayID();
	    \}
\end{alltt}

One can make a section including the  lower half elements of all three
arrays as follows:

\begin{alltt}
	  int aboundary=ArraySize/2;
	  int afloor=aboundary;
	  int aceiling=ArraySize-1;
	  int asectionSize=aceiling-afloor+1;
	  // cross section lower half of each array
	  CkArrayIndexMax **aelems= new CkArrayIndexMax*[3];
	  aelems[0]= new CkArrayIndexMax[asectionSize];
	  aelems[1]= new CkArrayIndexMax[asectionSize];
	  aelems[2]= new CkArrayIndexMax[asectionSize];
	  int *naelems=new int[3];
	  for(int k=0;k<3;k++)
	    \{
	      naelems[k]=asectionSize;
	      for(int i=afloor,j=0;i<=aceiling;i++,j++)
	        aelems[k][j]=CkArrayIndex1D(i);
	    \}
	  CProxySection\_multisectiontest\_array1d arrayLowProxy(3,aidArr,aelems,naelems);
\end{alltt}



The resulting cross section proxy, as in the example \uw{arrayLowProxy},
can then be used for multicasts in the same way as a normal array
section.

Note: For simplicity the example has all arrays and sections of uniform
size.  The size of each array and the number of elements in each array
within a section can all be set independently.


