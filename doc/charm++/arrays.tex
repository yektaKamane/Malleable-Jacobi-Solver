\subsection{Basic Arrays}

Arrays \index{arrays} are arbitrarily-sized collections of chares.  The
entire array has a globally unique identifier of type \kw{CkArrayID}, and
each element has a unique index of type \kw{CkArrayIndex}.  A \kw{CkArrayIndex}
can be a single integer (i.e. 1D array), several integers (i.e. a
multidimentional array), or an arbitrary string of bytes (e.g. a binary tree
index).

Array elements can be dynamically created and destroyed on any processor,
and messages for the elements will still arrive properly.
Array elements can be migrated at any time, allowing arrays to be efficiently
load balanced.  Array elements can also receive array broadcasts and
contribute to array reductions.

\subsubsection{Declaring a 1D Array}

You can declare a one-dimentional \index{array}\index{chare array}chare array
as:

\begin{alltt}
//In the .ci file:
array [1D] A \{
  entry A(\uw{parameters1});
  entry void someEntry(\uw{parameters2});
\};
\end{alltt}

Just as every Chare inherits from the system class \kw{Chare}, every 
array element inherits from the system class \kw{ArrayElement} (or one
of its subclasses, \kw{ArrayElement1D}, \kw{ArrayElement2D}, or 
\kw{ArrayElement3D}). Just as a Chare inherits ``thishandle'', each
array element inherits ``thisArrayID'', the \kw{CkArrayID} of its array,
and ``thisIndex'', the element's array index.

\begin{alltt}
class A : public ArrayElement1D \{
  public:
    A(\uw{parameters1});
    A(CkMigrateMessage *);

    void someEntry(\uw{parameters2});
\};
\end{alltt}

Note \uw{A}'s odd migration constructor, which is normally empty:

\begin{alltt}
//In the .C file:
A::A(void)
\{
  //...your constructor code...
\}
A::A(CkMigrateMessage *m) \{ \}
\end{alltt}

Read the section ``Migratable Array Elements'' for more
information on the \kw{CkMigrateMessage} constructor. 


\subsubsection{Creating a Simple Array}

You always create an array using the \kw{CProxy\_Array::ckNew}
routine.  This returns a proxy object, which can
be kept, copied, or sent in messages.
To create a 1D \index{array}array containing elements indexed 
(0, 1, ..., \uw{num\_elements}-1), use:

\begin{alltt}
CProxy_A1 a1 = CProxy_A1::ckNew(\uw{parameters},num_elements);
\end{alltt}

For creating higher-dimensional arrays, or for more options
when creating the array, see section~\ref{advanced array create}.


\subsubsection{Messages}

An array proxy responds to the appropriate index call--
for 1D arrays, use [i] or (i); for 2D use (x,y); for 3D
use (x,y,z); and for user-defined types use [f] or (f).

To send a \index{Array message} message to an array element, index the proxy 
and call the method name:

\begin{alltt}
a1[i].doSomething(\uw{parameters});
a3(x,y,z).doAnother(\uw{parameters});
aF[CkArrayIndexFoo(...)].doAgain(\uw{parameters});
\end{alltt}

You may invoke methods on array elements that have not yet
been created-- by default, the system will buffer the message until the
element is created\footnote{However, the element must eventually be 
created-- i.e., within a 3-minute buffering period.}.

Messages are not guarenteed to be delivered in order.
For example, if I invoke a method A, then method B;
it is possible for B to be executed before A.

\begin{alltt}
a1[i].A();
a1[i].B();
\end{alltt}

Messages sent to migrating elements will be delivered after
the migrating element arrives.  It is an error to send 
a message to a deleted array element.


\subsubsection{Broadcasts}
To \index{Array broadcast} broadcast a message to all the current elements of an array, 
simply omit the index, as:

\begin{alltt}
a1.doIt(\uw{parameters}); //<- invokes doIt on each array element
\end{alltt}

The broadcast message will be delivered to every existing array 
element exactly once.  Broadcasts work properly even with ongoing
migrations, insertions, and deletions.


\subsubsection{Reductions on Chare Arrays}
A \index{array reduction}reduction applies a single operation (e.g. add,
max, min, ...) to data items scattered across many processors and
collects the result in one place.  \charmpp{} supports reductions on the
elements of a Chare array.

The data to be reduced comes from each array element, 
which must call the \kw{contribute} method:

\begin{alltt}
ArrayElement::contribute(int nBytes,const void *data,CkReduction::reducerType type);
\end{alltt}

Reductions are described in more detail in Section~\ref{reductions}.


\subsubsection{Destroying Arrays}
To destroy an array element-- detach it from the array,
call its destructor, and release its memory--invoke its 
\kw{Array destroy} method, as:

\begin{alltt}
a1[i].destroy();
\end{alltt}

You must ensure that no messages are sent to a deleted element. 
After destroying an element, you may insert a new element at
its index.




\subsection{Advanced Arrays}

The basic array features described above (creation, messaging,
broadcasts, and reductions) are needed in almost every
\charmpp{} program.  The more advanced techniques that follow
are not universally needed; but are still often useful.


\subsubsection{Declaring 2D, 3D, or User-defined Index Arrays}

\charmpp{} contains direct support for multidimentional and
even user-defined index arrays.  These arrays can be declared as:

\begin{alltt}
//In the .ci file:
message MyMsg;
array [1D] A1 \{ entry A1(); entry void e(\uw{parameters});\}
array [2D] A2 \{ entry A2(); entry void e(\uw{parameters});\}
array [3D] A3 \{ entry A3(); entry void e(\uw{parameters});\}
array [Foo] AF \{ entry AF(); entry void e(\uw{parameters});\}
\end{alltt}

The last declaration expects an array index of type \kw{CkArrayIndex}\uw{Foo},
which must be defined before including the \texttt{.decl.h} file 
(see ``User-defined array index type'' below).  

\begin{alltt}
//In the .h file:
class A1:public ArrayElement1D \{ public: A1()\{\} ...\};
class A2:public ArrayElement2D \{ public: A2()\{\} ...\};
class A3:public ArrayElement3D \{ public: A3()\{\} ...\};
class AF:public ArrayElementT<Foo> \{ public: AF()\{\} ...\};
\end{alltt}

A 1D array element can access its index via its inherited ``thisIndex''
field; a 2D via ``thisIndex.x'' and ``thisIndex.y'', and a 3D via
``thisIndex.x'', ``thisIndex.y'', and ``thisIndex.z''.  A user-defined
index array can access its index as ``thisIndex''.


\subsubsection{Advanced Array Creation}
\label{advanced array create}
There are several ways to control the array creation process.
You can adjust the map and bindings before creation, change
the way the initial array elements are created, create elements
explicitly during the computation, and create elements implicitly,
``on demand''.  

You can create all your elements using any one of these methods,
or create different elements using different methods.  
An array element has the same syntax and semantics no matter
how it was created.


\subsubsection{Advanced Array Creation: CkCreateOptions}
\index{CkCreateOptions}
\label{CkCreateOptions}

The array creation method \kw{ckNew} actually takes a parameter
of type \kw{CkCreateOptions}.  This object describes several
optional attributes of the new array.

The most common form of \kw{CkCreateOptions} is to set the number
of initial array elements.  A \kw{CkCreateOptions} object will be 
constructed automatically in this special common case.  Thus
the following code segments all do exactly the same thing:

\begin{alltt}
//Implicit CkCreateOptions
  a1=CProxy_A1::ckNew(\uw{parameters},nElements);

//Explicit CkCreateOptions
  a1=CProxy_A1::ckNew(\uw{parameters},CkCreateOptions(nElements));

//Separate CkCreateOptions
  CkCreateOptions opts(nElements);
  a1=CProxy_A1::ckNew(\uw{parameters},opts);
\end{alltt}

Note that the ``numElements'' in an array element is simply
the numElements passed in when the array was created.
The true number of array elements may grow or shrink during 
the course of the computation, so numElements can become 
out of date. 


\subsubsection{Advanced Array Creation: Map Object}
\index{array map}
\label{array map}

You can use \kw{CkCreateOptions} to specify a ``map object''
for an array.  The map object is used by the array manager
to determine the ``home'' processor of each element.  The
home processor is the processor responsible for maintaining
the location of the the element.

There is a default map object, which maps 1D array indices
in a round-robin fashion to processors, and maps other array
indices based on a hash function.

A custom map object is implemented as a group which inherits from
\kw{CkArrayMap} and defines these virtual methods:

\begin{alltt}
class CkArrayMap : public Group
\{
public:
  //...
  
  //Return an ``arrayHdl'', given some information about the array
  virtual int registerArray(int numInitialElements,CkArrayID aid);
  //Return the home processor number for this element of this array
  virtual int procNum(int arrayHdl,const CkArrayIndex &element);
\}
\end{alltt}

Once you've instantiated a custom map object, you can use it to
control the location of a new array's elements using the
\kw{setMap} method of the \kw{CkCreateOptions} object described above.
For example, if you've declared a map object named ``blockMap'':

\begin{alltt}
//Create the map group
  CProxy_blockMap myMap=CProxy_blockMap::ckNew();
//Make a new array using that map
  CkCreateOptions opts(nElements);
  opts.setMap(myMap);
  a1=CProxy_A1::ckNew(\uw{parameters},opts);
\end{alltt}



\subsubsection{Advanced Array Creation: Initial Elements}
\index{array initial}
\label{array initial}

The map object described above can also be used to create
the initial set of array elements in a distributed fashion.
An array's initial elements are created by its map object,
by making a call to \kw{populateInitial} on each processor.

You can create your own set of elements by creating your
own map object and overriding this virtual function of \kw{CkArrayMap}:

\begin{alltt}
  virtual void populateInitial(int arrayHdl,int numInitial,
	void *msg,CkArrMgr *mgr)
\end{alltt}

In this call, \kw{arrayHdl} is the value returned by \kw{registerArray},
\kw{numInitial} is the number of elements passed to \kw{CkCreateOptions},
\kw{msg} is the constructor message to pass, and \kw{mgr} is the
array to create.

\kw{populateInitial} creates new array elements using the method
\kw{void CkArrMgr::insertInitial(CkArrayIndex idx,void *ctorMsg)}.
For example, to create one row of 2D array elements on each processor,
you would write:

\begin{alltt}
void xyElementMap::populateInitial(int arrayHdl,int numInitial,
	void *msg,CkArrMgr *mgr)
\{
  if (numInitial==0) return; //No initial elements requested
	
  //Create each local element
  int y=CkMyPe();
  for (int x=0;x<numInitial;x++) \{
    mgr->insertInitial(CkArrayIndex2D(x,y),CkCopyMsg(&msg));
  \}
  mgr->doneInserting();
  CkFreeMsg(msg);
\}
\end{alltt}

Thus calling \kw{ckNew(10)} on a 3-processor machine would result in
30 elements being created.


\subsubsection{Advanced Array Creation: Bound Arrays}
\experimental{}
\index{bound arrays} \index{bindTo}
\label{bound arrays}
You can ``bind'' a new array to an existing array
using the \kw{bindTo} method of \kw{CkCreateOptions}.  Bound arrays
act like separate arrays in all ways except for migration--
corresponding elements of bound arrays always migrate together.
For example, this code creates two arrays A and B which are
bound together-- A[i] and B[i] will always be on the same processor.

\begin{alltt}
//Create the first array normally
  aProxy=CProxy_A::ckNew(\uw{parameters},nElements);
//Create the second array bound to the first
  CkCreateOptions opts(nElements);
  opts.bindTo(aProxy);
  bProxy=CProxy_B::ckNew(\uw{parameters},opts);
\end{alltt}

Bound arrays are often useful if A[i] and B[i] perform different 
aspects of the same computation, and thus will run most efficiently 
if they lie on the same processor.  Bound array elements are guarenteed
to always be able to interact using \kw{ckLocal} (see 
section~\ref{ckLocal for arrays}), although the local pointer must
be refreshed after any migration.

An arbitrary number of arrays can be bound together--
in the example above, we could create yet another array
C and bind it to A or B.  The result would be the same
in either case-- A[i], B[i], and C[i] will always be
on the same processor.

There is no relationship between the types of bound arrays--
it is permissible to bind arrays of different types or of the
same type.  It is also permissible to have different numbers
of elements in the arrays, although elements of A which have
no corresponding element in B obey no special semantics.
Any method may be used to create the elements of any bound
array.


\subsubsection{Advanced Array Creation: Dynamic Insertion}

In addition to creating initial array elements using ckNew,
you can also
create array elements during the computation.

You insert elements into the array by indexing the proxy
and calling insert.  The insert call optionally takes 
parameters, which are passed to the constructor; and a
processor number, where the element will be created.
Array elements can be inserted in any order from 
any processor at any time.  Array elements need not 
be contiguous.

If using \kw{insert} to create all the elements of the array,
you must call \kw{CProxy\_Array::doneInserting} before using
the array.

\begin{alltt}
//In the .C file:
int x,y,z;
CProxy_A1 a1=CProxy_A1::ckNew();  //Creates a new, empty 1D array
for (x=...) \{
   a1[x  ].insert(\uw{parameters});  //Bracket syntax
   a1(x+1).insert(\uw{parameters});  // or equivalent parenthesis syntax
\}
a1.doneInserting();

CProxy_A2 a2=CProxy_A2::ckNew();   //Creates 2D array
for (x=...) for (y=...)
   a2(x,y).insert(\uw{parameters});  //Can't use brackets!
a2.doneInserting();

CProxy_A3 a3=CProxy_A3::ckNew();   //Creates 3D array
for (x=...) for (y=...) for (z=...)
   a3(x,y,z).insert(\uw{parameters});
a3.doneInserting();

CProxy_AF aF=CProxy_AF::ckNew();   //Creates user-defined index array
for (...) \{
   aF[CkArrayIndexFoo(...)].insert(\uw{parameters}); //Use brackets...
   aF(CkArrayIndexFoo(...)).insert(\uw{parameters}); //  ...or parenthesis
\}
aF.doneInserting();

\end{alltt}

The \kw{doneInserting} call starts the the reduction manager (see ``Array
Reductions'') and load balancer (see ``Load Balancer'')-- since
these objects need to know about all the array's elements, they
must be started after the initial elements are inserted.
You may call \kw{doneInserting} multiple times, but only the first
call actually does anything.  You may even \kw{insert} or \kw{destroy}
elements after a call to \kw{doneInserting}, with different semantics-- 
see the reduction manager and load balancer sections for details.

If you do not specify one, the system will choose a procesor to 
create an array element on based on the current map object.



\subsubsection{Advanced Array Creation: Demand Creation}

Normally, invoking an entry method on a nonexistant array
element is an error.  But if you add the attribute
\index{createhere} \index{createhome}
\kw{[createhere]} or \kw{[createhome]} to an entry method,
 the array manager will 
``demand create'' a new element to handle the message.  

With \kw{[createhome]}, the new element
will be created on the home processor, which is most efficient when messages for
the element may arrive from anywhere in the machine. With \kw{[createhere]},
the new element is created on the sending processor, which is most efficient
if when messages will often be sent from that same processor.

The new element is created by calling its default (taking no
paramters) constructor, which must exist and be listed in the .ci file.
A single array can have a mix of demand-creation and
classic entry methods; and demand-created and normally 
created elements.



\subsubsection{User-defined array index type}

\index{Array index type, user-defined}
\charmpp{} array indices are arbitrary collections of integers.
To define a new array index, you create an ordinary C++ class 
which inherits from \kw{CkArrayIndex} and sets the ``nInts'' member
to the length, in integers, of the array index.

For example, if you have a structure or class named ``Foo'', you 
can use a \uw{Foo} object as an array index by defining the class:

\begin{alltt}
#include <charm++.h>
class CkArrayIndexFoo:public CkArrayIndex \{
    Foo f;
public:
    CkArrayIndexFoo(const Foo \&in) 
    \{
        f=in;
        nInts=sizeof(f)/sizeof(int);
    \}
    //Not required, but convenient: cast-to-foo operators
    operator Foo &() \{return f;\}
    operator const Foo &() const \{return f;\}
\};
\end{alltt}

Note that \uw{Foo}'s size must be an integral number of integers--
you must pad it with zero bytes if this is not the case.
Also, \uw{Foo} must be a simple class-- it cannot contain 
pointers, have virtual functions, or require a destructor.
Finally, there is a \charmpp\ configuration-time option called
CK\_ARRAYINDEX\_MAXLEN \index{CK\_ARRAYINDEX\_MAXLEN} 
which is the largest allowable number of 
integers in an array index.  The default is 3; but you may 
override this to any value by passing ``-DCK\_ARRAYINDEX\_MAXLEN=n'' 
to the \charmpp\ build script as well as all user code. Larger 
values will increase the size of each message.

You can then declare an array indexed by \uw{Foo} objects with

\begin{alltt}
//in the .ci file:
array [Foo] AF \{ entry AF(); ... \}

//in the .h file:
class AF:public ArrayElementT<Foo>
\{ public: AF() \{\} ... \}

//in the .C file:
    Foo f;
    CProxy_AF a=CProxy_AF::ckNew();
    a[CkArrayIndexFoo(f)].insert();
    ...
\end{alltt}

Note that since our CkArrayIndexFoo constructor is not declared
with the explicit keyword, we can equivalently write the last line as:

\begin{alltt}
    a[f].insert();
\end{alltt}

When you implement your array element class, as shown above you 
can inherit from
\kw{ArrayElementT}, a class templated by the index type \uw{Foo}.
The array index (an object of type \uw{Foo}) is then accessible as 
``thisIndex''. For example:

\begin{alltt}

//in the .C file:
AF::AF()
\{
    Foo myF=thisIndex;
    functionTakingFoo(myF);
\}
\end{alltt}


\subsubsection{Migratable Array Elements}
Array objects can \index{migrate}migrate from one PE to another.
For example, the load balancer (see section ``Load Balancing Chare Arrays'')
might migrate array elements to better balance the load between
processors.  For an array element to migrate, it must implement
a pack/unpack or ``pup'' method:

\begin{alltt}
//In the .h file:
class A2:public ArrayElement2D \{
private: //My data members:
    int nt;
    unsigned char chr;
    float flt[7];
    int numDbl;
    double *dbl;
public:	
    //...other declarations

    virtual void pup(PUP::er \&p);
\};

//In the .C file:
void A2::pup(PUP::er \&p)
\{
    ArrayElement2D::pup(p); //<- MUST call superclass's pup routine
    p(nt);
    p(chr);
    p(flt,7);
    p(numDbl);
    if (p.isUnpacking()) dbl=new double[numDbl];
    p(dbl,numDbl);
\}
\end{alltt}

Please note that if your object contains Structured Dagger code (see section ``Structured Dagger'') you must use the following syntax to correctly pup the object:

\begin{alltt}
class bar: public ArrayElement3D \{
 private:
    int a,b;
 public:
    bar_SDAG_CODE 
    ...other methods...

    virtual void pup(PUP::er& p) \{
      __sdag_pup(p);
      ...pup other data here...
    \}
\};
\end{alltt}

See the \index{PUP} section ``PUP'' for more details on pup routines
and the \kw{PUP::er} type.

The system uses one pup routine to do both packing and unpacking by
passing different types of \kw{PUP::er}s to it.  You can determine
what type of \kw{PUP::er} has been passed to you with the
\kw{isPacking()}, \kw{isUnpacking()}, and \kw{isSizing()} calls.

An array element can migrate by calling the \kw{migrateMe}(\uw{destination
processor}) member function-- this call must be the last action
in an element entry point.  The system can also migrate array elements
for load balancing (see the ``Load Balancing Chare Arrays'' chapter).

To migrate your array element to another processor, the \charmpp{}
runtime will:

\begin{itemize}
\item Call your \kw{ckAboutToMigrate} method
\item Call your \uw{pup} method with a sizing \kw{PUP::er} to determine how 
big a message it needs to hold your element.
\item Call your \uw{pup} method again with a packing \kw{PUP::er} to pack 
your element into a message.
\item Call your element's destructor (killing off the old copy).
\item Send the message (containing your element) across the network.
\item Call your element's migration constructor on the new processor.
\item Call your \uw{pup} method on with an unpacking \kw{PUP::er} to unpack 
the element.
\item Call your \kw{ckJustMigrated} method
\end{itemize}

Migration constructors, then, are normally empty-- all the unpacking
and allocation of the data items is done in the element's \uw{pup} routine.
Deallocation is done in the element destructor as usual.


\subsubsection{Load Balancing Chare Arrays}
\charmpp{} includes a run-time load balancer which works
on array elements.  The idea is to run programs more efficiently
by migrating array elements away from overloaded processors.
To use the load balancer, you must make your elements migratable
(see migration section above) and choose a load balancing 
``strategy'' (see the load balancing section for a description
of load balancing strategy routines).

There are three ways to use the load balancer-- 
\begin{itemize}

\item Method 1: By default, the array elements may be asked to migrate at any time
provided they are not in the middle of executing an entry method. 
The array element's variable \kw{usesAtSync} being false attributes
to this default behaviour. 

\item  Method 2: Using the AtSync method, elements can be migrated at certain
times.  For the AtSync method, set \kw{usesAtSync} to true in your 
array element constructor.  When an element is ready to migrate,
call \kw{ArrayElement::AtSync}.  
After the first \kw{doneInserting} call (which starts the load balancer)
and once all elements have reached \kw{AtSync},
the load balancer runs and migrates elements.  Once
all migrations are complete, the load balancer calls the 
virtual function \kw{ArrayElement::ResumeFromSync} for each of the
array element.  One must ensure that no messages are
sent to an array element between its calls to \kw{AtSync} and
\kw{ResumeFromSync}. \kw{AtSync}/\kw{ResumeFromSync} is currently
implemented as a global barrier.

Note: Setting usesAtSync to true makes it mandatory for the array
element to call \kw{AtSync} and implement the \kw{ResumeFromSync}
 function.

\item Method 3: The load balancer can be programmed to be started
manually. 
 To use this feature, the LBDatabase object
can be got explicitly by making the call \kw{LBDatabase::Object()}
For example, 

\begin{alltt}
LBDatabase * myLbdb = LBDatabase::Object()
\end{alltt}

\kw{myLbdb->TurnManualLBOn()} will enable the manual switching on of
the Load Balancer, so that no Load Balancer will be started automatically.
\kw{TurnManualLBOn()} should be called as early as possible in the
program. It must be ideally called in the constructor of a static array and
definitely before the doneInserting call for a dynamic array.  This call has to be made on all processors. It can be called multiple times on one pe, but the last one takes effect.   
The function call \kw{myLbdb->StartLB()} will start the load balancer. This call can be made on only one pe as the start message is broadcast to all processors. The load balancing happens in the background and won't stop the chares from functioning. 
\kw{myLbdb->TurnManualLBOff()} turns off manual load balancing and switches back to the automatic Load balancing mode (using or not using AtSync). 

\end{itemize}

\subsubsection{Local Access}
\experimental{}
\index{ckLocal for arrays}
\label{ckLocal for arrays}
You can get direct access to a local array element using the
proxy's \kw{ckLocal} method, which returns an ordinary \CC\ pointer
to the element if it exists on the local processor; and NULL if
the element does not exist or is on another processor.

\begin{alltt}
A1 *a=a1[i].ckLocal();
if (a==NULL) //...is remote-- send message
else //...is local-- directly use members and methods of a
\end{alltt}

Note that if the element migrates or is deleted, any pointers 
obtained with \kw{ckLocal} are no longer valid.  It is best,
then, to either avoid \kw{ckLocal} or else call \kw{ckLocal} 
each time the element may have migrated; e.g., at the start 
of each entry method.


\subsubsection{Array Section}
\experimental{}

\charmpp{} now supports array section. Array section is a subset of array 
elements in a chare array. You can build a special proxy for a section and do 
multicast via the proxy. Section reduction is not directly supported in the 
section proxy. However, an optimized section multicast/reduction library called 
CkMulticast is provided as a separate library module. 

For each chare array "A" declared in a ci file, the definition of section proxy 
of type "CProxySection\_A" is automatically generated. You can create an array 
section proxy in your application by invoking ckNew() to CProxySection:

\begin{alltt}
  CkArrayIndexMax *elems;    // add array indices
  int numElems;
  CProxySection_Hello proxy = CProxySection_Hello::ckNew(helloArrayID, elems, numElems);
\end{alltt}

Once you have the array section proxy, you can do multicast to all the 
section members, or send messages to one member using its index that
is local to the section, like these:

\begin{alltt}
  CProxySection_Hello proxy;
  proxy.someEntry(...)          // multicast
  proxy[0].someEntry(...)       // send to the first element in the section.
\end{alltt}

You can move the section proxy in a message to another processor, and still 
safely invoke the entry functions in the section proxy.

In the multicast example above, for a section with k members, total number 
of k messages will be sent to all the memebers separately, which is considered 
inefficient when multiple section members are at same processor, in which case 
the messages can be combined into one. To optimize the communication and in 
order to support the section reduction, a separate library called CkMulticast 
is provided.

To use the library, you need to compile and install CkMulticast library and 
link your applications against the library using -module:

\begin{alltt}
  # compile and install the CkMulticast library, do this only once
  cd charm/net-linux/tmp/libs/ck-libs/multicast
  make

  # link CkMulticast library using -module
  charmc  -o hello hello.o -module CkMulticast -language charm++ 
\end{alltt}

CkMulticast library is implemented as a delegation of communication for a 
section proxy. Once an array section proxy is delegated, all the messages sent
from the section proxy will be routed to the local delegation branch and 
handled by it. 

To use the CkMulticast delegation, you need to create the CkMulticastMgr Group 
first, and setup the delegation relationship between the section proxy and 
CkMulticastMgr Group. You only need to create one CkMulticastMgr Group though,
it can serve as multicast/reduction delegation for all array sections you 
create:

\begin{alltt}
  CProxySection_Hello sectProxy = CProxySection_Hello::ckNew(...);
  CkGroupID mCastGrpId = CProxy_CkMulticastMgr::ckNew();
  CkMulticastMgr *mcastGrp = CProxy_CkMulticastMgr(mCastGrpId).ckLocalBranch();

  sectProxy.ckDelegate(mCastGrpId);  //section proxy knows who is the delegation
  mcastGrp->setSection(sectProxy);   //delegation knows whom to delegate

  sectProxy.someEntry(...)           //multicast via delegation library as before
\end{alltt}

Note, to use CkMulticast library, all multicast messages must inherit from 
CkMcastBaseMsg, as following:

\begin{alltt}
class HiMsg : public CkMcastBaseMsg, public CMessage_HiMsg
\{
public:
  int *data;
\};
\end{alltt}

Due to this restriction, you need to define message explicitly for multicast 
entry functions and no parameter marshalling can be used for multicast with 
CkMulticast library.

To use section reduction, the root of the reduction array element need to 
 register a reduction callback function to the CkMulticastMgr delegation:

\begin{alltt}
  CProxySection_Hello sectProxy;
  CkMulticastMgr *mcastGrp = CProxy_CkMulticastMgr(mCastGrpId).ckLocalBranch();
  mcastGrp->setReductionClient(sectProxy, callback, userData);
\end{alltt}

When an array element in a section contributes to the reduction, it needs to 
retrieve the section cookie from the multicast message received, and use the 
cookie when talking to the delegation:

\begin{alltt}
  CkSectionCookie cookie;

  void SayHi(HiMsg *msg)
  \{
    CkGetSectionCookie(cookie, msg);     // update section cookie every time
    int data = thisIndex;
    mcastGrp->contribute(sizeof(int), &data, CkReduction::sum_int, cookie);
  \}
\end{alltt}

Note, cookie is retrieved from the multicast message and contains information
about the multicast spanning tree information and reduction counter.
You need to keep this cookie for next uses(i.e. define cookie outside of the 
entry function instead of a local variable). Using multicast/reduction, you
don't need to worry about array migrations, the CkMulticast library can 
automatically update multicast spanning tree for efficient communication.

