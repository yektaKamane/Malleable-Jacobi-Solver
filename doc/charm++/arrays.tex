\subsection{Basic Arrays}

\label{basic arrays}

Arrays \index{arrays} are arbitrarily-sized collections of chares.  The
entire array has a globally unique identifier of type \kw{CkArrayID}, and
each element has a unique index of type \kw{CkArrayIndex}.  A \kw{CkArrayIndex}
can be a single integer (i.e. 1D array), several integers (i.e. a
multidimensional array), or an arbitrary string of bytes (e.g. a binary tree
index).

Array elements can be dynamically created and destroyed on any processor,
and messages for the elements will still arrive properly.
Array elements can be migrated at any time, allowing arrays to be efficiently
load balanced.  Array elements can also receive array broadcasts and
contribute to array reductions.

\subsubsection{Declaring a 1D Array}

You can declare a one-dimensional \index{array}\index{chare array}chare array
as:

\begin{alltt}
//In the .ci file:
array [1D] A \{
  entry A(\uw{parameters1});
  entry void someEntry(\uw{parameters2});
\};
\end{alltt}

Just as every Chare inherits from the system class \kw{CBase}\_\uw{ClassName}, every 
array element inherits from the system class \kw{CBase}\_\uw{ClassName}.
Just as a Chare inherits ``thishandle'', each
array element inherits ``thisArrayID'', the \kw{CkArrayID} of its array,
and ``thisIndex'', the element's array index.
As well as chares are allowed to inherit directly from class \kw{Chare},
array elements are allowed to inherit from \kw{ArrayElement1D} if 1D array,
\kw{ArrayElement2D} if 2D array, and so on up to 6D.

\begin{alltt}
class A : public CBase\_A \{
  public:
    A(\uw{parameters1});
    A(CkMigrateMessage *);

    void someEntry(\uw{parameters2});
\};
\end{alltt}

Note \uw{A}'s odd migration constructor, which is normally empty:

\begin{alltt}
//In the .C file:
A::A(void)
\{
  //...your constructor code...
\}
A::A(CkMigrateMessage *m) \{ \}
\end{alltt}

Read the section ``Migratable Array Elements'' for more
information on the \kw{CkMigrateMessage} constructor. 

\subsubsection{Declaring Multidimensional Arrays}

\charmpp{} contains direct support for multidimensional and
even user-defined index arrays.  These arrays can be declared as:

\begin{alltt}
//In the .ci file:
message MyMsg;
array [1D] A1 \{ entry A1(); entry void e(\uw{parameters});\}
array [2D] A2 \{ entry A2(); entry void e(\uw{parameters});\}
array [3D] A3 \{ entry A3(); entry void e(\uw{parameters});\}
array [4D] A4 \{ entry A4(); entry void e(\uw{parameters});\}
array [5D] A5 \{ entry A5(); entry void e(\uw{parameters});\}
array [6D] A6 \{ entry A6(); entry void e(\uw{parameters});\}
array [Foo] AF \{ entry AF(); entry void e(\uw{parameters});\}
\end{alltt}

The last declaration expects an array index of type \kw{CkArrayIndex}\uw{Foo},
which must be defined before including the \texttt{.decl.h} file 
(see ``User-defined array index type'' below).  

\begin{alltt}
//In the .h file:
class A1 : public CBase\_A1 \{ public: A1()\{\} ...\};
class A2 : public CBase\_A2 \{ public: A2()\{\} ...\};
class A3 : public CBase\_A3 \{ public: A3()\{\} ...\};
class A4 : public CBase\_A4 \{ public: A4()\{\} ...\};
class A5 : public CBase\_A5 \{ public: A5()\{\} ...\};
class A6 : public CBase\_A6 \{ public: A6()\{\} ...\};
class AF : public CBase\_AF \{ public: AF()\{\} ...\};
\end{alltt}

A 1D array element can access its index via its inherited ``thisIndex''
field; a 2D via ``thisIndex.x'' and ``thisIndex.y'', and a 3D via
``thisIndex.x'', ``thisIndex.y'', and ``thisIndex.z''. The subfields
of 4D, 5D, and 6D are respectively \{w,x,y,z\}, \{v,w,x,y,z\}, and 
\{x1,y1,z1,x2,y2,z2\}.
A user-defined index array can access its index as ``thisIndex''.


Likewise, you can create a dense multidimensional array by passing the 
extents at creation time to \kw{ckNew}.

\begin{alltt}
CProxy_A1 a1 = CProxy_A1::ckNew(parameters, num_elements);
CProxy_A2 a2 = CProxy_A2::ckNew(parameters, num_rows, num_colums);
CProxy_A3 a3 = CProxy_A3::ckNew(parameters, num_rows, num_columns, num_depth);
\end{alltt}

For 4D, 5D, 6D and user-defined arrays, this functionality cannot be used. 
You need to insert the array elements individually (Section~\ref{dynamic_insertion}).


\subsubsection{Creating a Simple Array}

\label{basic array creation}

You always create an array using the \kw{CProxy\_Array::ckNew}
routine.  This returns a proxy object, which can
be kept, copied, or sent in messages.
To create a 1D \index{array}array containing elements indexed 
(0, 1, ..., \uw{num\_elements}-1), use:

\begin{alltt}
CProxy_A1 a1 = CProxy_A1::ckNew(\uw{parameters},num_elements);
\end{alltt}

The constructor is invoked on each array element.
For creating higher-dimensional arrays, or for more options
when creating the array, see section~\ref{advanced array create}.


\subsubsection{Entry Method Invocation}

An array proxy responds to the appropriate index call--
for 1D arrays, use [i] or (i); for 2D use (x,y); for 3D
use (x,y,z); and for user-defined types use [f] or (f).

To send a \index{Array message} message to an array element, index the proxy 
and call the method name:

\begin{alltt}
a1[i].doSomething(\uw{parameters});
a3(x,y,z).doAnother(\uw{parameters});
aF[CkArrayIndexFoo(...)].doAgain(\uw{parameters});
\end{alltt}

You may invoke methods on array elements that have not yet
been created-- by default, the system will buffer the message until the
element is created\footnote{However, the element must eventually be 
created-- i.e., within a 3-minute buffering period.}.

Messages are not guarenteed to be delivered in order.
For example, if I invoke a method A, then method B;
it is possible for B to be executed before A.

\begin{alltt}
a1[i].A();
a1[i].B();
\end{alltt}

Messages sent to migrating elements will be delivered after
the migrating element arrives.  It is an error to send 
a message to a deleted array element.


\subsubsection{Broadcasts}

To \index{Array broadcast} broadcast a message to all the current elements of an array, 
simply omit the index, as:

\begin{alltt}
a1.doIt(\uw{parameters}); //<- invokes doIt on each array element
\end{alltt}

The broadcast message will be delivered to every existing array 
element exactly once.  Broadcasts work properly even with ongoing
migrations, insertions, and deletions.


\subsubsection{Reductions on Chare Arrays}
\label{reductions}

A \index{array reduction}reduction applies a single operation (e.g. add,
max, min, ...) to data items scattered across many processors and
collects the result in one place.  \charmpp{} supports reductions
over the members of an array or group.

The data to be reduced comes from a call to the member \kw{contribute} 
method:
\begin{alltt}
void contribute(int nBytes, const void *data, CkReduction::reducerType type);
\end{alltt}

This call contributes \kw{nBytes} bytes starting at \kw{data} to the
reduction \kw{type} (see Section~\ref{builtin_reduction}).  Unlike sending a
message, you may use \kw{data} after the call to \kw{contribute}.  All
members of the chare array or group must call \kw{contribute}, 
and all of them must use the same reduction type.  

When you create a new chare array element, it is expected
to contribute to the next reduction not already in progress on that
processor.  The reduction will complete properly even if elements are migrated
or deleted during the reduction. 

For example, if we want to sum each array/group member's single integer myInt, 
we would use:

\begin{alltt}
    // Inside any member method
    int myInt=get_myInt();
    contribute(sizeof(int),\&myInt,CkReduction::sum_int);
\end{alltt}

The built-in reduction types (see below) can also handle arrays of
numbers.  For example, if each element of a chare array has a pair of
doubles \uw{forces}[2], the corresponding elements of which are to be added across
all elements, from each element call:

\begin{alltt}
    double forces[2]=get_my_forces();
    contribute(2*sizeof(double),forces,CkReduction::sum_double);
\end{alltt}

This will result in a {\tt double} array of 2 elements, the first of which
contains the sum of all \uw{forces}[0] values, with the second element 
holding the sum of all \uw{forces}[1] values of the chare array elements.

Note that since C++ arrays (like \uw{forces}[2]) are already pointers, we 
don't use \&\uw{forces}.

Reductions do not have to specify commutative-associative operations on data;
they can also be used to signal the fact that all array/group members
have reached a certain synchronization point. In this case, a simpler version
of contribute may be used:

%Sometimes it is not important the data to be reduced, but only the fact that all
%elements have reached a synchronization point. In this case a simpler version of
%contribute can be used:

\begin{alltt}
    contribute();
\end{alltt}

In all cases, the result of the reduction operation is passed to the {\em reduction
client}.  Many different kinds of reduction clients can be used, as
explained in Section~\ref{reductionClients}.

\paragraph{Typed Reductions}

\label{typed_reductions}

Typically the client entry method of a reduction takes a single argument of
type CkReductionMsg. However, by giving an entry method the
\kw{reductiontarget} attribute in the {\tt .ci} file, you can instead use entry methods that take
arguments of the same type as specified by the {\em contribute} call.  
When creating a callback to the
reduction target, the entry method index is generated by 
{\tt CkReductionTarget(ChareClass, method\_name)} 
instead of {\tt CkIndex\_ChareClass::method\_name(...)}.
For example,
the code for a typed reduction that yields an {\tt int}, would look like this:

\begin{alltt}
  // In the .ci file...
  entry [reductiontarget] void done(int result);

  // In some .cc file: 
  // Create a callback that invokes the typed reduction client
  CkCallback cb(CkReductionTarget(Driver,done), driverProxy);

  // Contribution to the reduction...
  contribute(sizeof(int), &intData, CkReduction::sum_int, cb);

  // Definition of the reduction client...
  void Driver::done(int result) 
  \{
    CkPrintf("Reduction value: \%d", result);
  \}
\end{alltt}

This will also work for arrays of data elements, and for any user-defined type with a PUP method
(see ~\ref{sec:pup}). If you know that the reduction will yield a particular
number of elements, say 3 {\tt int}s, you can also specify a reduction target which
takes 3 {\tt int}s and it will be invoked correctly. 

\subsubsection{Built-in Reduction Types}
\label{builtin_reduction}

\charmpp{} includes several built-in reduction types, used to combine 
individual contributions.  Any of them may be passed as an argument of type
\kw{CkReduction::reducerType} to \kw{contribute}.

The first four operations ({\tt sum}, {\tt product}, {\tt max}, and {\tt min}) work on {\tt int},
{\tt float}, or {\tt double} data as indicated by the suffix.  The logical
reductions ({\tt and}, {\tt or}) only work on integer data.  All the built-in
reductions work on either single numbers (pass a pointer) or arrays-- just
pass the correct number of bytes to \kw{contribute}.

\begin{enumerate}

\item \kw{CkReduction::nop}-- no operation performed.

\item \kw{CkReduction::sum\_int}, \kw{sum\_float}, \kw{sum\_double}-- the
result will be the sum of the given numbers.

\item \kw{CkReduction::product\_int}, \kw{product\_float},
\kw{product\_double}-- the result will be the product of the given numbers.

\item \kw{CkReduction::max\_int}, \kw{max\_float}, \kw{max\_double}-- the
result will be the largest of the given numbers.

\item \kw{CkReduction::min\_int}, \kw{min\_float}, \kw{min\_double}-- the
result will be the smallest of the given numbers.

\item \kw{CkReduction::logical\_and}-- the result will be the logical AND of the given
integers.  0 is false, nonzero is true.

\item \kw{CkReduction::logical\_or}-- the result will be the logical OR of the given
integers.

\item \kw{CkReduction::bitvec\_and}-- the result will be the bitvector AND of the given numbers (represented as integers).

\item \kw{CkReduction::bitvec\_or}-- the result will be the bitvector OR of the given numbers (represented as integers).

\item \kw{CkReduction::set}-- the result will be a verbatim concatenation of
all the contributed data, separated into \kw{CkReduction::setElement} records.
The data contributed can be of any length, and can vary across array elements
or reductions.  To extract the data from each element, see the description
below.

\item \kw{CkReduction::concat}-- the result will be a byte-by-byte
concatentation of all the contributed data.  The contributed elements
are not delimiter-separated. 

\end{enumerate}


\kw{CkReduction::set} returns a collection of \kw{CkReduction::setElement}
objects, one per contribution.  This class has the definition:

\begin{alltt}
class CkReduction::setElement 
\{
public:
  int dataSize;//The length of the data array below
  char data[];//The (dataSize-long) array of data
  CkReduction::setElement *next(void);
\};
\end{alltt}

To extract the contribution of each array element from a reduction set, use the
\uw{next} routine repeatedly:

\begin{alltt}
  //Inside a reduction handler-- 
  //  data is our reduced data from CkReduction_set
  CkReduction::setElement *cur=(CkReduction::setElement *)data;
  while (cur!=NULL)
  \{
    ... //Use cur->dataSize and cur->data
    //Now advance to the next element's contribution
    cur=cur->next();
  \}
\end{alltt}

The reduction set order is undefined.  You should add a source field to the
contributed elements if you need to know which array element gave a particular
contribution.  Additionally, if the contributed elements are of a complex 
data type, you will likely have to supply code for 
%serialize/unserialize operation on your element structure if your
%reduction element data is complex.  
serializing/deserializing them.
Consider using the \kw{PUP}
interface see ~\ref{sec:pup} to simplify your object serialization
needs.

If the outcome of your reduction is dependent on the order in which 
data elements are processed, or if your data is just too
heterogenous to be handled elegantly by the predefined types and you
don't want to undertake multiple reductions, it may be best to define
your own reduction type.  See the next section
(Section~\ref{new_type_reduction}) for details.

\subsubsection{Destroying Arrays}

To destroy an array element-- detach it from the array,
call its destructor, and release its memory--invoke its 
\kw{Array destroy} method, as:

\begin{alltt}
a1[i].ckDestroy();
\end{alltt}

You must ensure that no messages are sent to a deleted element. 
After destroying an element, you may insert a new element at
its index.
