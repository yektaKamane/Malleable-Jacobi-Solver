\subsection{Basic Arrays}

\label{basic arrays}

Arrays \index{arrays} are arbitrarily-sized collections of chares.  The
entire array has a globally unique identifier of type \kw{CkArrayID}, and
each element has a unique index of type \kw{CkArrayIndex}.  A \kw{CkArrayIndex}
can be a single integer (i.e. 1D array), several integers (i.e. a
multidimensional array), or an arbitrary string of bytes (e.g. a binary tree
index).

Array elements can be dynamically created and destroyed on any processor,
and messages for the elements will still arrive properly.
Array elements can be migrated at any time, allowing arrays to be efficiently
load balanced.  Array elements can also receive array broadcasts and
contribute to array reductions.

\subsubsection{Declaring a 1D Array}

You can declare a one-dimensional \index{array}\index{chare array}chare array
as:

\begin{alltt}
//In the .ci file:
array [1D] A \{
  entry A(\uw{parameters1});
  entry void someEntry(\uw{parameters2});
\};
\end{alltt}

Just as every Chare inherits from the system class \kw{CBase}\_\uw{ClassName}, every 
array element inherits from the system class \kw{CBase}\_\uw{ClassName}.
Just as a Chare inherits ``thishandle'', each
array element inherits ``thisArrayID'', the \kw{CkArrayID} of its array,
and ``thisIndex'', the element's array index.
As well as chares are allowed to inherit directly from class \kw{Chare},
array elements are allowed to inherit from \kw{ArrayElement1D} if 1D array,
\kw{ArrayElement2D} if 2D array, and so on up to 6D.

\begin{alltt}
class A : public CBase\_A \{
  public:
    A(\uw{parameters1});
    A(CkMigrateMessage *);

    void someEntry(\uw{parameters2});
\};
\end{alltt}

Note \uw{A}'s odd migration constructor, which is normally empty:

\begin{alltt}
//In the .C file:
A::A(void)
\{
  //...your constructor code...
\}
A::A(CkMigrateMessage *m) \{ \}
\end{alltt}

Read the section ``Migratable Array Elements'' for more
information on the \kw{CkMigrateMessage} constructor. 

\subsubsection{Declaring Multidimensional Arrays}

\charmpp{} contains direct support for multidimensional and
even user-defined index arrays.  These arrays can be declared as:

\begin{alltt}
//In the .ci file:
message MyMsg;
array [1D] A1 \{ entry A1(); entry void e(\uw{parameters});\}
array [2D] A2 \{ entry A2(); entry void e(\uw{parameters});\}
array [3D] A3 \{ entry A3(); entry void e(\uw{parameters});\}
array [4D] A4 \{ entry A4(); entry void e(\uw{parameters});\}
array [5D] A5 \{ entry A5(); entry void e(\uw{parameters});\}
array [6D] A6 \{ entry A6(); entry void e(\uw{parameters});\}
array [Foo] AF \{ entry AF(); entry void e(\uw{parameters});\}
\end{alltt}

The last declaration expects an array index of type \kw{CkArrayIndex}\uw{Foo},
which must be defined before including the \texttt{.decl.h} file 
(see ``User-defined array index type'' below).  

\begin{alltt}
//In the .h file:
class A1 : public CBase\_A1 \{ public: A1()\{\} ...\};
class A2 : public CBase\_A2 \{ public: A2()\{\} ...\};
class A3 : public CBase\_A3 \{ public: A3()\{\} ...\};
class A4 : public CBase\_A4 \{ public: A4()\{\} ...\};
class A5 : public CBase\_A5 \{ public: A5()\{\} ...\};
class A6 : public CBase\_A6 \{ public: A6()\{\} ...\};
class AF : public CBase\_AF \{ public: AF()\{\} ...\};
\end{alltt}

A 1D array element can access its index via its inherited ``thisIndex''
field; a 2D via ``thisIndex.x'' and ``thisIndex.y'', and a 3D via
``thisIndex.x'', ``thisIndex.y'', and ``thisIndex.z''. The subfields
of 4D, 5D, and 6D are respectively \{w,x,y,z\}, \{v,w,x,y,z\}, and 
\{x1,y1,z1,x2,y2,z2\}.
A user-defined index array can access its index as ``thisIndex''.


Likewise, you can create a dense multidimensional array by passing the 
extents at creation time to \kw{ckNew}.

\begin{alltt}
CProxy_A1 a1 = CProxy_A1::ckNew(parameters, num_elements);
CProxy_A2 a2 = CProxy_A2::ckNew(parameters, num_rows, num_colums);
CProxy_A3 a3 = CProxy_A3::ckNew(parameters, num_rows, num_columns, num_depth);
\end{alltt}

For 4D, 5D, 6D and user-defined arrays, this functionality cannot be used. 
You need to insert the array elements individually (Section~\ref{dynamic_insertion}).


\subsubsection{Creating a Simple Array}

\label{basic array creation}

You always create an array using the \kw{CProxy\_Array::ckNew}
routine.  This returns a proxy object, which can
be kept, copied, or sent in messages.
To create a 1D \index{array}array containing elements indexed 
(0, 1, ..., \uw{num\_elements}-1), use:

\begin{alltt}
CProxy_A1 a1 = CProxy_A1::ckNew(\uw{parameters},num_elements);
\end{alltt}

The constructor is invoked on each array element.
For creating higher-dimensional arrays, or for more options
when creating the array, see section~\ref{advanced array create}.


\subsubsection{Entry Method Invocation}

An array proxy responds to the appropriate index call--
for 1D arrays, use [i] or (i); for 2D use (x,y); for 3D
use (x,y,z); and for user-defined types use [f] or (f).

To send a \index{Array message} message to an array element, index the proxy 
and call the method name:

\begin{alltt}
a1[i].doSomething(\uw{parameters});
a3(x,y,z).doAnother(\uw{parameters});
aF[CkArrayIndexFoo(...)].doAgain(\uw{parameters});
\end{alltt}

You may invoke methods on array elements that have not yet
been created-- by default, the system will buffer the message until the
element is created\footnote{However, the element must eventually be 
created-- i.e., within a 3-minute buffering period.}.

Messages are not guarenteed to be delivered in order.
For example, if I invoke a method A, then method B;
it is possible for B to be executed before A.

\begin{alltt}
a1[i].A();
a1[i].B();
\end{alltt}

Messages sent to migrating elements will be delivered after
the migrating element arrives.  It is an error to send 
a message to a deleted array element.


\subsubsection{Broadcasts}

To \index{Array broadcast} broadcast a message to all the current elements of an array, 
simply omit the index, as:

\begin{alltt}
a1.doIt(\uw{parameters}); //<- invokes doIt on each array element
\end{alltt}

The broadcast message will be delivered to every existing array 
element exactly once.  Broadcasts work properly even with ongoing
migrations, insertions, and deletions.


\subsubsection{Reductions on Chare Arrays}

A \index{array reduction}reduction applies a single operation (e.g. add,
max, min, ...) to data items scattered across many processors and
collects the result in one place.  \charmpp{} supports reductions on the
elements of a Chare array.

The data to be reduced comes from each array element, 
which must call the \kw{contribute} method:

\begin{alltt}
ArrayElement::contribute(int nBytes,const void *data,CkReduction::reducerType type);
\end{alltt}

Reductions are described in more detail in Section~\ref{reductions}.


\subsubsection{Destroying Arrays}

To destroy an array element-- detach it from the array,
call its destructor, and release its memory--invoke its 
\kw{Array destroy} method, as:

\begin{alltt}
a1[i].ckDestroy();
\end{alltt}

You must ensure that no messages are sent to a deleted element. 
After destroying an element, you may insert a new element at
its index.

\subsubsection{Array Reductions}

\label{reductions}

A \index{array reduction}reduction applies a single operation (e.g. add,
max, min, ...) to data items scattered across many processors and
collects the result in one place.  \charmpp{} supports reductions
over the members of an array or group.

The data to be reduced comes from a call to the member \kw{contribute} 
method:
\begin{alltt}
void contribute(int nBytes, const void *data, CkReduction::reducerType type);
\end{alltt}

This call contributes \kw{nBytes} bytes starting at \kw{data} to the
reduction \kw{type} (see reduction types, below).  Unlike sending a
message, you may use \kw{data} after the call to \kw{contribute}.  All
members of the chare array or group must call \kw{contribute}, and all of them must use the same
reduction type.  

When you create a new chare array element, it is expected
to contribute to the next reduction not already in progress on that
processor.  The
reduction will complete properly even if elements are migrated
or deleted during the reduction. 

For example, if we want to sum each array/group member's single integer myInt, 
we would use:

\begin{alltt}
    // Inside any member method
    int myInt=get_myInt();
    contribute(sizeof(int),\&myInt,CkReduction::sum_int);
\end{alltt}

The built-in reduction types (see below) can also handle arrays of
numbers.  For example, if each element of a chare array has a pair of
doubles \uw{forces}[2], the corresponding elements of which are to be added across
all elements, from each element call:

\begin{alltt}
    double forces[2]=get_my_forces();
    contribute(2*sizeof(double),forces,CkReduction::sum_double);
\end{alltt}

This will result in a {\tt double} array of 2 elements, the first of which
contains the sum of all \uw{forces}[0] values, with the second element 
holding the sum of all \uw{forces}[1] values of the chare array elements.

Note that since C++ arrays (like \uw{forces}[2]) are already pointers, we 
don't use \&\uw{forces}.

Reductions do not have to specify commutative-associative operations on data;
they can also be used to signal the fact that all array/group members
have reached a certain synchronization point. In this case, a simpler version
of contribute may be used:

%Sometimes it is not important the data to be reduced, but only the fact that all
%elements have reached a synchronization point. In this case a simpler version of
%contribute can be used:

\begin{alltt}
    contribute();
\end{alltt}

In all cases, the result of the reduction operation is passed to the {\em reduction
client}.  Many different kinds of reduction clients can be used, as
explained below (Section~\ref{reductionClients}).

\paragraph{Typed Reductions}

\label{typed_reductions}

Typically the client entry method of a reduction takes a single argument of
type CkReductionMsg. However, by giving an entry method the
\kw{reductiontarget} attribute in the {\tt .ci} file, you can instead use entry methods that take
arguments of the same type as specified by the {\em contribute} call.  
When creating a callback to the
reduction target, the entry method index is generated by 
{\tt CkReductionTarget(ChareClass, method\_name)} 
instead of {\tt CkIndex\_ChareClass::method\_name(...)}.
For example,
the code for a typed reduction that yields an {\tt int}, would look like this:

\begin{alltt}
  // In the .ci file...
  entry [reductiontarget] void done(int result);

  // In some .cc file: 
  // Create a callback that invokes the typed reduction client
  CkCallback cb(CkReductionTarget(Driver,done), driverProxy);

  // Contribution to the reduction...
  contribute(sizeof(int), &intData, CkReduction::sum_int, cb);

  // Definition of the reduction client...
  void Driver::done(int result) 
  \{
    CkPrintf("Reduction value: \%d", result);
  \}
\end{alltt}

This will also work for arrays of data elements, and for any user-defined type with a PUP method
(see ~\ref{sec:pup}). If you know that the reduction will yield a particular
number of elements, say 3 {\tt int}s, you can also specify a reduction target which
takes 3 {\tt int}s and it will be invoked correctly. 

