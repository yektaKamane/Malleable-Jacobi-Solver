\subsection{Checkpoint/Restart}
\index{Checkpoint/Restart}
\label{sec:checkpoint}

\charmpp{} offers basic fault tolerance capabilities through its 
checkpoint/restart mechanism. Usual Chare array-based \charmpp{} application 
can be checkpointed to disk files and later on restarting from the files.

The basic idea behind this is straightforward: Checkpointing an 
application is like migrating its parallel objects from the processors
onto disks, and restarting is the reverse. Thanks to the migration 
utilities like PUP'ing(Section~\ref{sec:pup}), users can decide what 
data to save in checkpoints and how to save them.

\subsubsection{Checkpointing}
	The API to checkpoint the application is:

\begin{alltt} 
  void CkStartCheckpoint(char* dirname,const CkCallback& cb);
\end{alltt}

The string {\it dirname} is the destination directory where the checkpoint
files will be stored, and {\it cb} is the callback function which will be
invoked after the checkpoint is done, as well as when the restart is
complete. Here is an example of a typical use:

\begin{alltt} 
  . . .
  CkCallback cb(CkIndex_Hello::SayHi(),helloProxy);
  CkStartCheckpoint("log",cb);
\end{alltt}

A chare array usually has a PUP routine for the sake of migration. 
The PUP routine is also used in the checkpointing and restarting process.
Therefore, it is up to the programmer what to save and restore for
the application. One illustration of this flexbility is a complicated
scientific computation application with 9 matrices, 8 of which holding 
the intermediate results and 1 holding the final results of each timestep.
To save resource, the PUP routine can well omit the 8 intermediate matrices
and checkpoint the matrix with final results of each timestep. 

Group and nodegroup objects(Section~\ref{sec:group}) are normally not 
meant to be migrated. In order to checkpoint them, however, the user 
wants to write PUP routines for the groups and declare them as 
{\tt [migratable]} in the .ci file. Some programs use {\it mainchares}
to hold key control data like global object counts, and thus needs
mainchares be checkpointed too. To do this, the programmer should write
a PUP routine for the mainchare and declare them as {\tt [migratable]} 
in the .ci file, just as in the case of Group and Nodegroup. In addition,
the programmer also needs to put the proxy to the mainchare (usually 
noted as mainproxy) as a read-only data in the code, and make sure 
processor 0, which holds the mainchare, initiates the checkpoint.

After {\tt CkStartCheckpoint} is executed, a directory of the designated
name is created and a collection of checkpoint files are written into it. 

\subsubsection{Restarting}

The user can choose to run the \charmpp{} application in restart mode, i.e.,
restarting execution from last checkpoint. The command line option {\tt
-restart DIRNAME} is required to invoke this mode. For example:

\begin{alltt}
  > ./charmrun hello +p4 +restart log
\end{alltt}

Restarting is the reverse process of checkpointing. \charmpp{} allows 
restarting the old checkpoint on different number of physical processor.
This provides the flexibility to expand or shrink your application when
the availability of computing resource changes. 

Note that on restart, if the old reduction client was set to a static 
function, the function pointer might be lost and the user needs to register
it again. A better alternative is to always use entry method of a chare
object. Since all the entry methods are registered inside \charmpp{} system,
in restart phase, the reduction client will be automatically restored.

After a failure, the system may consist less number of processors. After
a problem fixed, some processors may become available again. Therefore,
the user may need to flexibility to restart on different number of processors
than in the checkpointing phase. This is allowable by giving different 
{\tt +pN} option at runtime. One thing to note is that the new load 
distribution might differ from the previous one at checkpoint time,
so running a load balancing (See Section~\ref{loadbalancing}) is suggested. 

If restart is not done on the same number of processors, the processor-specific
data in a group/nodegroup branch cannot (and usually should not) be 
restored individually. A copy from processor 0 will be propagate to all 
the processors.

\subsubsection{Choosing What to Save}
In your programs, you may use chare groups for different types of purposes. 
For example, groups holding read-only data can avoid excessive data copying,
while groups maintaining processor-specific information is used as a local
manager of the processor. In the latter situation, the data is sometimes
too complicated to save and restore but easy to re-compute. For the read-only
data, you want to save and restore it in the PUP'er routing and leave empty
the migration constructor, via which the new object is created during restart.
For the easy-to-recompute type of data, we just omit the PUP'er routine and
do the data reconstruction in the group's migration constructor.

A similar example is the program mentioned above, where there aree two 
types of chare arrays, one maintaining intermediate results while the 
other type holding the final result for each timestep. The programmer 
can take advantage of the flexibility by omitting PUP'er routine empty
for intermediate objects, and do save/restore only for the important 
objects. 

