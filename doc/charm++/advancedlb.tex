
\subsection{Advanced Load Balancing}

\label{advancedlb}

\subsubsection{Control CPU Load Statistics}

Charm++ programmers can control CPU load data in the load balancing database
before a load balancing phase is started (which is the time when load balancing
database is collected and used by load balancing strategies).

In an array element, the following function can be invoked to overwrite the 
CPU load that is measured by load balancing framework.

\begin{alltt}
   double newTiming;
   setObjTime(newTiming);
\end{alltt}

{\em setObjTime()} is defined as a method of class {\em CkMigratable}, which is
the superclass of all array elements.

The users can also retrieve the current timing that the load balancing runtime
has measured for the current array element. 
 
\begin{alltt} 
   double measuredTiming; 
   measuredTiming = getObjTime(); 
\end{alltt}

This is useful when the users want to derive a new CPU load based on the 
existing one.

\subsubsection{Model-based Load Balancing}

Charm++ programmers can also choose to feed load balancer with their own CPU
timing of each Chare based on certain computational model of the applications.

To do so, first turn off automatic CPU load measurement completely
by setting:

\begin{alltt}
   usesAutoMeasure = CmiFalse;
\end{alltt}

in array element's constructor.

Then the users need to implement the following function to the chare array
classes:

\begin{alltt}
   virtual void CkMigratable::UserSetLBLoad();      // defined in base class
\end{alltt}

This function served as a callback that is called on each chare object when
{\em AtSync()} is called and ready to do load balancing. The implementation of
{\em UserSetLBLoad()} is simply to set the current chare object's CPU load to
load balancer framework. {\em setObjTime()} described above can be used for
this.

\subsubsection{Write a Measurement-based Object Migration Strategy}
\label{writelb}

Charm++ programmers can pick load balancing strategy from Charm++'s built-in
strategies(see ~\ref{lbStrategy}) for the best performance based on the 
characteristics of their applications, they can also choose to write their 
own load balancing strategies.

Charm++ load balancing framework provides a simple scheme to incorporate new 
load balancing strategies. To write a new load balancing strategy
involves the following steps (We use an example of writing a centralized
load balancer {\em fooLB} to illustrate the steps).

\begin{enumerate}
\item Create files named {\em fooLB.ci, fooLB.h and fooLB.C}. One can choose to
copy and rename the files RandCentLB (a random centralized load balancer) and 
rename the class name in those files.

\item Implement the {\em fooLB} class method --- 
{\bf fooLB::work(CentralLB::LDStats* stats, int count)} 
This method takes the load balancing database ({\em stats}) as an input,
and output the new mapping of objects to processors in {\em stats->to\_proc} array.

\item To compile the strategy files, first add {\em fooLB} into the load 
balancer list in charm/tmp/Makefile\_lb.sh. Run the script in charm/tmp, 
which creates the new Makefile named ``Make.lb''.

\item Run ``make depends'' to update dependence rule of Charm++ files.
   And run ``make charm++'' to compile Charm++ which includes the new 
load balancing strategy files.
\end{enumerate}


\subsubsection{Understand Load Balancing Database Data Structure}

\label{lbdatabase}

To write a load balancing strategy, one may want to know 
what information is measured during the runtime and how it is represented in
the load balancing database data structure?

There are mainly 3 categories of information: a) processor information including processor speed, background load; b) object information including per object
cpu/wallclock compute time and c) communication information .

The database data structure named {\kw LDStats} is defined in {\em CentralLB.h}:

\begin{verbatim}

  struct ProcStats {  // per processor
    double total_walltime;
    double total_cputime;
    double idletime;
    double bg_walltime;
    double bg_cputime;
    int pe_speed;
    double utilization;
    CmiBool available;
    int   n_objs;
  }

  struct LDStats { // load balancing database
    ProcStats  *procs;
    int count;

    int   n_objs;
    int   n_migrateobjs;
    LDObjData* objData;

    int   n_comm;
    LDCommData* commData;

    int  *from_proc, *to_proc;
  }

\end{verbatim}

\begin{enumerate}
\item {\em procs} array defines processor attributes and usage data for each
processor;
\item {\em objData} array records per object information, {\em LDObjData} is defined in {\em lbdb.h};
\item {\em commData} array records per communication information. {\em LDCommData} is defined in {\em lbdb.h}.
\end{enumerate}

