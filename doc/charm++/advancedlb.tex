
\subsection{Advanced Load Balancing}
\label{advancedlb}

\subsubsection{Write a Measurement-based Object Migration Strategy}
\label{writelb}

Charm++ programmers can pick load balancing strategy from Charm++'s built-in
strategies(see ~\ref{lbStrategy}) for the best performance based on the 
characteristics of their applications, they can also choose to write their 
own load balancing strategies.

Charm++ load balancing framework provides a simple scheme to incorporate new 
load balancing strategies. To write a new load balancing strategy
involves the following steps (We use an example of writing a centralized
load balancer {\em fooLB} to illustrate the steps).

\begin{enumerate}
\item Create files named {\em fooLB.ci, fooLB.h and fooLB.C}. One can choose to
copy and rename the files RandCentLB (a random centralized load balancer) and 
rename the class name in those files.

\item Implement the {\em fooLB} class method --- 
{\bf fooLB::work(CentralLB::LDStats* stats, int count)} 
This method takes the load balancing database ({\em stats}) as an input,
and output the new mapping of objects to processors in {\em stats->to\_proc} array.

\item To compile the strategy files, first add {\em fooLB} into the load 
balancer list in charm/tmp/Makefile\_lb.sh. Run the script in charm/tmp, 
which creates the new Makefile namded ``Make.lb''.

\item Run ``make depends'' to update dependence rule of Charm++ files.
   And run ``make charm++'' to compile Charm++ which includes the new 
load balancing strategy files.
\end{enumerate}


\subsubsection{Understand Load Balancing Database Data Structure}
\label{lbdatabase}

To write a load balancing strategy, one may want to know 
what information is measured during the runtime and how it is represented in
the load balancing database data structure?

There are mainly 3 categories of information: a) processor information including processor speed, background load; b) object information including per object
cpu/wallclock compute time and c) communication information .

The database data structure named {\kw LDStats} is defined in {\em CentralLB.h}:

\begin{verbatim}

  struct ProcStats {  // per processor
    double total_walltime;
    double total_cputime;
    double idletime;
    double bg_walltime;
    double bg_cputime;
    int pe_speed;
    double utilization;
    CmiBool available;
    int   n_objs;
  }

  struct LDStats { // load balancing database
    ProcStats  *procs;
    int count;

    int   n_objs;
    int   n_migrateobjs;
    LDObjData* objData;

    int   n_comm;
    LDCommData* commData;

    int  *from_proc, *to_proc;
  }

\end{verbatim}

\begin{enumerate}
\item {\em procs} array defines processor attributes and usage data for each
processor;
\item {\em objData} array records per object information, {\em LDObjData} is defined in {\em lbdb.h};
\item {\em commData} array records per communication information. {\em LDCommData} is defined in {\em lbdb.h}.
\end{enumerate}

