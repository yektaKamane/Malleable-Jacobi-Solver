\subsection{Communication Optimizations Framework}

The communications framework in Charm++/converse is aimed at
optimizing certain communication patterns. Currently the programmer
has to specify the communication pattern. The communications library
uses the delegation framework. This is done to make access to the
communication library transparent to the programmer.

To access the communication framework you first need to create an
instance of the Communication Framework which will work with your
messages and optimize that pattern. Each communication framework
instance needs to know how to manage the messages. Hence a Strategy
needs to be initialized and passed to the instance of the
Communication Library framework.

Each strategy inherits from the class {\em Strategy} and implements
its entry methods.  Each strategy has its own set of options passed to
its constructor. There are two types of strategies in our framework.

\begin{itemize}

\item Bracketed Strategies. In bracketed strategies each source Chare
(which could be an array element or a group) deposits its entries and
then the strategy performs the communication optimization. For example
the EachToManyMulticastStrategy is a bracketed strategy. For bracketed
strategies a beginIteration and an endIteration must be called before
and after making the deposits respectively. 

\item Streaming Strategies. Streaming strategies perform communication
optimizations in the background and do not need beginIteration and
endIteration to start processing. They usually combine and process
the messages after every few ms (a parameter to the strategy) or after
certain number of messages have been deposited.

\end{itemize}

The communications library currently has the following strategies
implemented.

\begin{itemize} 

\item EachToManyMulticastStrategy. EachToManyMulticastStrategy optimizes 
collective personalized communication and collective multicast or a
combination of both. In collective personalized communication
operation each array element sends a distinct message to many other
array elements. The sending and receiving elements need not belong to
the same array.  Collective multicast is a special case of collective
personalized communication where each array element sends the same
message to the destination array elements.

Strategy * strategy = new EachToManyMulticastStrategy(topology,
src\_array, dest\_array);

if the entire arrays are participating in the strategies. If only
sections of the source and destination arrays are participating in the
collective operation the following constructor could also be used.

EachToManyMulticastStrategy(int topology, CkArrayID srcarray, CkArrayID destarray,
int nsrc, 
CkArrayIndexMax *indices, int ndest, 
CkArrayIndexMax  *destelements);

Setting nsrc to 0 or ndest to 0 would make the strategy use the entire
source or destination array respectively.

The header file for this strategy is EachToManyMulticastStrategy.h
which needs to be included in the user program.

The constructor also takes an integer parameter {\em topology}. This
tells the strategy how to optimize the collective personalized
communication pattern. The options for topology are USE\_DIRECT,
USE\_MESH, USE\_HYPERCBE, USE\_GRID. USE\_DIRECT sends the message
directly. USE\_MESH imposes a 2d Mesh virtual topology on the
processors so now each processor sends messages to its neighbors in
its row and column of the mesh which forward the messages to their
correct destinations. USE\_HYPERCUBE and USE\_GRID impose a hypercube
and a 3d Grid topologies on the processors. USE\_HYPERCUBE will do
best for very small messages and small number of processors, 3d has
better performance for slightly higher message sizes and then Mesh
starts performing best. The programmer is encouraged to try out all
the topologies.

To send a multicast message, the multicast message should inherit from
CkMcastBaseMsg as mentioned in section \ref{array_section_multicast}
about Array Section Multicast. To send the multicast message create
the appropriate array section proxy. On the array section proxy call
the appropriate entry method with this message. This will be explained
in detail later.

\item StreamingStrategy. In this communication optimization strategy 
each array element sends many small messages to other array elements
but these sends are not synchronized and the library periodically
collects messages (or collects when a certain number of messages have
been deposited) and sends them to their destinations. The period is a
parameter to the StreamingStrategy. It needs to be specified in Milli
seconds. 10ms is the default

Strategy * strategy = new StreamingStrategy(period\_in\_ms, int nmsgs);

The header file is StreamingStrategy.h.

\end{itemize}

The following are the steps to use the communication library 
in a user program.

\subsubsection{Compiling User Code}

All user programs that use the communcation library should use the
linker option -module comlib.For Example \\ 
charmc -o pgm pgm.o -module comlib

\subsubsection {Calling the Library from User Code}
Calls to the communication library have to be made at two places in
the user program. They are :

\begin{enumerate}
\item main.C 
\begin{verbatim}
//Include the appropriate header file
#include <EachToManyMulticastStrategy.h>

//In main::main() 
//Create a Communication Library Instance
ComlibInstanceHandle cinst = CkGetComlibInstance();
//For bracketed strategies this instance should be sent to 
//all source array elements through a broadcast or as a readonly variable

//Create your strategy
Strategy *strategy = new EachToManyStrategy(USE_MESH, srcarray, destarray);
//or
Strategy *strategy = new StreamingStrategy(10,10);

//Register the strategy
cinst.setStrategy(strategy);

\end{verbatim}

\item In the array element 
\begin{verbatim}

//Before calling an entry method whose message should go thorough the
//library the proxy has to be delegated. Create a new copy of the
//proxy and delegate it before using it.

CProxy_Hello dproxy = array_proxy;
ComlibDelegateProxy(&dproxy);
cinst.beginIteration();  //Only for bracketed strategies
dproxy[index].entry();   
.....
.....
cinst.endIteration();    //Only for bracketed strategies
//Now all calls to proxy will go through the library.
//So non library calls should use another proxy!
//The begin and end calls do not have to be called for the streaming strategy.

//To send a section multicast
CProxySection_Hello dsec_proxy = CProxySection_Hello::ckNew(arrayid, nelements, indices);
ComlibDelegateProxy(&dsec_proxy);
cinst.beginIteration();  //Only for bracketed strategies
.....
dsec_proxy.entry();
.....
cinst.endIteration();    //Only for bracketed strategies

\end{verbatim}
\end{enumerate}

NOTE: Any number of communication framework instances can be
created. Each of them should have a strategy registered. For bracketed
strategies the instance handles should be remembered and
beginIteration and endIteration should be called.
