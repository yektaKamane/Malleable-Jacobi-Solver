\subsection{Communication Optimizations Framework}

The communications framework in Charm++/Converse is aimed at optimizing certain
communication patterns. Currently the programmer has to specify the
communication pattern it intends to optimize, together with the strategy to be
used. The communications library uses the delegation framework in order too
enable easy and transparent access to the framework by the programmer.

For \ampi{} programs, the communication optimization is done by the \ampi{}
layer, so that the user does not need to worry about that. In Charm++, however,
the user must create the strategies in the program explicitly. Charm++ programs
are normally based on communicating arrays of chares, that compute and then
invoke entry methods on local or remote chares by sending them messages. These
array elements send messages to each other through proxies. The messages are
passed to the Charm++ runtime which calls lower level network APIs to
communicate. To optimize communication in Charm++, the user can redirect a
communication {\em call} to go through an instance of a strategy.

To access the communication framework, the user first creates and initializes a
communication library strategy. He then needs to make a copy of the array proxy
and associate it with that strategy. The user can create several instances of
the same strategy, to optimize different communication calls in his application.
Each communication operation is now associated with a proxy. There exist two
interfaces, which need to keep different information in every chare. The first
one is suggested to be used, as it is newer and simpler. The second one is
mainly for reference on older codes.

The information to be kept can be either stored as a readonly variable, or
internally as a private variable of each chare using it.

\subsubsection{Proxy interface}

A proxy containing the delegation should be kept, and reused every time the
associated stragety wants to be used.

\begin{enumerate}
\item main.C global
\begin{verbatim}
// Include the appropriate header file
#include <EachToManyMulticastStrategy.h>
#include <StreamingStrategy.h>

// Declare the global variable
CProxy_MyArray aproxy;
CProxy_MyArray dproxy;
\end{verbatim}

\item main.C:main()
\begin{verbatim}
// Create the array
aproxy = CProxy_Hello::ckNew();

// Create the strategy
Strategy *strategy = new EachToManyStrategy(USE_MESH, srcarray, destarray);
//or
Strategy *strategy = new StreamingStrategy(10,10);

// Register the strategy to a new proxy, so that aproxy is without commlib,
// while dproxy uses it
dproxy = aproxy;
ComlibAssociateProxy(dproxy, strategy);
\end{verbatim}

\item In the array element
\begin{verbatim}
// First proxy should be delegated
ComlibBeginIteration(aproxy);   // Only for bracketed strategies
dproxy[index].entry(message);   // Sending a message
.....     //sending more messages
.....
aproxy[index].entry2{message2); // Send a message without commlib
ComlibEndIteration(aproxy);     // Only for bracketed strategies
\end{verbatim}
\end{enumerate}

The above example shows the usage of EachToManyStrategy. Notice the
ComlibBeginIteration and ComlibEndIteration calls, needed for bracketed
strategies. The construction of the strategies has been done in tha main::main,
from where they are broadcasted and initialized in every processor before being
used.

\subsubsection{Instance interface}

In this interface, the chares need to keep information about the commlib instance.

\begin{enumerate}
\item main.C global
\begin{verbatim}
// Include the appropriate header file
#include <EachToManyMulticastStrategy.h>
#include <StreamingStrategy.h>

// Declare the global variable
CProxy_MyArray aproxy;
ComlibInstanceHandle cinst;
\end{verbatim}

\item main.C:main()
\begin{verbatim}
// Create the array
aproxy = CProxy_Hello::ckNew();

// Create your strategy
Strategy *strategy = new EachToManyStrategy(USE_MESH, srcarray, destarray);
//or
Strategy *strategy = new StreamingStrategy(10,10);

// Create a Communication Library Instance
cinst = CkGetComlibInstance();

// Register the strategy
cinst.setStrategy(strategy);
\end{verbatim}

\item In the array element 
\begin{verbatim}
// Before calling an entry method whose message should go thorough the
// library the proxy has to be delegated. Create a new copy of the
// proxy and delegate it before using it.
CProxy_Hello dproxy = aproxy;
ComlibDelegateProxy(&dproxy); //Now all calls to dproxy will go through the library.

cinst.beginIteration();       // Only for bracketed strategies
dproxy[index].entry();        // Send a message
.....
.....
aproxy[index].entry2();       // Send a message without commlib
cinst.endIteration();         // Only for bracketed strategies
\end{verbatim}
\end{enumerate}

\subsubsection{Sections}

In order to multicast only to a part of the array instead of the entire array,
it is necessary to create a {\textrm{CProxySection\_class}} of the desired
portion of the destination array, delegate it with either
{\textrm{ComlibAssociateProxy()}} or {\textrm{ComlibDelegateProxy}}, and send a
broadcast to it. This broadcast on the section will result in the desired
multicast on the global array.

\subsubsection{Loadbalancing and Migration support}

The Communication optimization framework supports both loadbalancing and array
migration. It enables migration through message forwarding. Messages sent by a
migrated array are forwarded to the processor where it is mapped to, and from
here they get accounted. Messages sent to migrated arrays are forwarded from the
processor where they are mapped to to their current destination.

This mapping of array elements to processors can be updated by the user by
calling {\textrm{ComlibResetProxy}} for array proxies, and
{\textrm{ComlibResetSectionProxy}} for section proxies. This should be done
especially during load-balancing, where most of the migrations happen. As shown
in the following example, these calls should be made inside the
{\textrm{resumeFromSync}} method.

At {\em load-balancing} time the user should make comlib remap the array
element. This can be done by calling ComlibResetProxy for array proxies and
ComlibResetSectionProxy for section proxies. This calls need to be made in
resumeFromSync.

\begin{verbatim}
  void arrayelement::resumeFromSync() {
      .......
      .......
      ComlibResetProxy(aproxy);  // Proxy interface
      cinst.setSourcePe();       // Instance interface

      ComlibResetSectionProxy(sproxy);  // Both interfaces
  }
\end{verbatim}

A migrating array element containing {\em associated proxies} or {\em
instances} should pup them all at the source and destination.

\begin{verbatim}
  void arrayelement::pup(PUP::er &p){
      ..........
      ..........
      p | aproxy;
      p | cinst;
  }
\end{verbatim}

\subsubsection{Compiling User Code}

All user programs that use the communcation library should use the
linker option {\textrm{-module comlib}. For example,
\begin{verbatim}
charmc -o pgm pgm.o -module comlib
\end{verbatim}

\subsubsection{Supported Operations and Strategies}

The communication framework now supports four different communication
operations:
\begin{enumerate}
\item many-to-many communication,
\item array and group broadcast,
\item section multicast,
\item streaming.
\end{enumerate}
Table~\ref{tbl:com_operation} shows the different strategies that optimize these
communication operations. Some of these are converse strategies while others are
charm strategies. In the following paragraphs, we present in detail the
strategies optimizing the above mentioned operations.


\begin{table}[h]
\begin{center}
\begin{small}
\begin{tabular}{|c|c|c|}
\hline
{\bf Operation} & {\bf Object Strategy} & {\bf Processor Strategy} \\
\hline
Many-to-many  personalized & EachToManyStrategy & Mesh, Grid, Hypercube, Direct \\
Many-to-many  multicast    & EachToManyMulticastStrategy & Mesh, Grid, Hypercube, Direct \\
Broadcast  & BroadcastStrategy, PipeBroadcastStrategy & Binomial tree, Binary tree\\
Section Multicast & DirectSection, RingSection, TreeSection & \\
Streaming  & Streaming, MeshStreaming, PrioStreaming & \\
\hline
\end{tabular}
\end{small}
\end{center}
\caption{Communication Operations supported in the Framework}
\label{tbl:com_operation}
\end{table}

There are two types of strategies in the communication framework :

\begin{itemize}

\item Bracketed Strategies. In bracketed strategies each source Chare
(which could be an array element or a group) deposits its entries and then the
strategy performs the communication optimization. For example the
EachToManyMulticastStrategy is a bracketed strategy. For bracketed strategies a
beginIteration and an endIteration must be called before and after making the
deposits respectively.

\item Non-Bracketed Strategies. Non-bracketed strategies perform communication
optimizations without needing calls to beginIteration and endIteration to start
processing. Non-bracketed strategies either immediately process messages or
after a timeout, and, in both cases, it's not triggered from the application.

\end{itemize}

\subsubsection{Many-to-many Strategies}

The class {\em EachToManyStrategy} optimizes all-to-all personalized
communication using several virtual topologies like 2-D Mesh, 3-D Mesh and
Hypercube. This communications happen when a processor sends a different message
to each other processor. EachToManyStrategy manages the charm level
communication by first combining all messages being sent to the same processor
into one message, and then calling the {\em routers} to optimize the lower level
processor-to-processor communication. The {\em routers} implement the different
virtual topologies.

%For example, with the mesh router, the strategy on each processor
%first sends messages to its row neighbors. After having received its row
%messages each processor sends the column messages. After having received the
%column messages an iteration of the strategy finishes. All local messages are
%delivered as soon they are received.

{\em EachToManyMulticastStrategy} is a variant of the EachToManyStrategy, and is
used to optimize all-to-all multicast communication, where a processor sends the
same message to all others. This strategy also uses the same virtual topologies
at the lower level.

EachToManyStrategy requires that all local messages have been deposited before
they can be packed into single messages. Hence it needs to be a {\em bracketed}
strategy (see before).

%Bracketed strategies require each of the participating objects to deposit their
%intended messages within brackets. Calls to {\em ComlibBeginIteration} and {\em
%ComlibEndIteration} create a bracket. The call ComlibBeginIteration sets up the
%delegation framework to forward user messages to the correct strategy instance.
%User messages then get passed to the insertMessage entry function of the
%strategy. When all local objects have called ComlibEndIteration, doneInserting
%is invoked on the strategy.

%Bracketed strategies are typically needed when the communication
%optimization requires local source objects to reach a barrier. At this
%local barrier the communication framework invokes doneInserting on
%that strategy, which the calls the converse level strategy.

%Non-bracketed strategies have no such restriction. They process
%messages as soon as they arrive. so, non-bracketed strategies should
%not expect a doneInserting to be invoked on them. They must all
%process messages in the insertMessage call itself.

Both strategies also optimize the many-to-many operation, where the source and
destination is not a whole array, but only a subset. Moreover, the sending and
receiving elements need noot belong to the same array.

As for the constructors to be used in the main, the two prototypes follow. They
are for EachToManyMulticastStrategy, but are the same for EachToManyStrategy.
The first one is for the all-to-all communication, the second one is for the
many-to-many communication, as it allows to specify a list of chares for both
source and destination. (Setting nsrc to 0 or ndest to 0 would make the strategy
use the entire source or destination array respectively)


\begin{verbatim}
EachToManyMulticastStrategy(int topology, CkArrayID src\_array, CkArrayID dest\_array);

EachToManyMulticastStrategy(int topology, CkArrayID src\_array, CkArrayID dest\_array,
              int nsrc, CkArrayIndexMax *indices, int ndest, CkArrayIndexMax  *destelements);
\end{verbatim}

Both have as first parameter the virtual topology that the strategy will use for
the low level optimization. The possible values are:

\begin{description}
\item[USE\_DIRECT] to send messages directly;
\item[USE\_MESH] to send messages across a 2D Mesh;
\item[USE\_GRID] to send messages across a 3D Grid;
\item[USE\_HYPERCUBE] to send messages across a Hypercube.
\end{description}

USE\_HYPERCUBE will do best for very small messages and small number of
processors, 3d has better performance for slightly higher message sizes and then
Mesh starts performing best. The programmer is encouraged to try out all the
topologies.

The header file to include is {\textrm{EachToManyMulticastStrategy.h}}.









\subsubsection{Streaming Strategies}

This strategy optimizes the scenario where chares send several small messages to
other chares. The StreamingStrategy collects messages destined to the same
processor and, after a timeout or when a certain number of messages have been
collected, it sends them as a single message. This result in sending fewer
messages of larger size. The timeout is a floating-point parameter to the
StreamingStrategy. It needs to be specified in milliseconds, with a default
value of 1ms. Micro-second timeouts can also be specified by passing values less
than 1. For example, $0.1$ represents $100\mu s$.

The Streaming Strategy is a non-bracketed strategy, so there is no need to call
for {\textrm{beginIteration}} and {\textrm{endIteration}}. Since messages and be
delayed due to the timeout present, it is possible to call
{\textrm{endIteration}} to flush all the messages to be sent immediately.

The prototype of the constructor is:

\begin{verbatim}
Strategy * strategy = new StreamingStrategy(float period\_in\_ms, int nmsgs);
\end{verbatim}

The header file to include is {\textrm{StreamingStrategy.h}}.

\subsubsection{Section Multicast and Broadcast Strategies}

The DirectMulticastStrategy and its subclasses can multicast a message to the entire
array or a section of array elements. The direct multicast strategies
are non-bracketed, and the message is processed when the application
deposits is. These strategies do not combine messages, but they may
sequence the destinations of the multicast to minimize contention on a
network. For example, the RingMulticastStrategy sends the messages
along ring resulting in good throughput as the ring permutation is
contention free on many communication topologies.

For section multicast, the user must create a section proxy and
delegate it to the communication library. Invocations on section
proxies are passed on to the section multicast strategy.

The following are the steps to use the communication library 
in a user program.







\subsubsection{Communication Optimization Strategy}

Optimization algorithms are implemented as Strategies in the
communication library. Strategies can be implemented at the Object
(Charm++) level or the processor (Converse) level. Code reuse is
possible by having a few object managers perform object level
optimizations and then call several other processor level optimization
schemes. For example, to optimize all-to-all communication the
processor level strategies could use the different virtual topologies.

All processor (Converse) level strategies inherit from the {\em
class~Strategy} defined below and override its virtual methods.

\begin{verbatim}
//Converse or Processor level strategy
class Strategy : public PUP::able{
public:
    //Called for each message
    virtual void insertMessage(MessageHolder *msg);
    //Called after all chares and groups have finished depositing their
    //messages on that processor.
    virtual void doneInserting();
    virtual void beginProcessing(int nelements);
};
\end{verbatim}

The class method {\em insertMessage} is called to deposit messages
with the strategy. MessageHolder is a wrapper for converse
messages. When a processor has sent all its messages, {\em
doneInserting} is invoked on the strategy.

\begin{verbatim}
//Charm++ or Object level strategy
class CharmStrategy : public Strategy{
 protected:
    int isArray;
    int isGroup;
    int isStrategyBracketed;
    ............   
    ............   
public:
    //Called for each message
    virtual void insertMessage(CharmMessageHolder *msg);
    //Called after all chares and groups have finished depositing their
    //messages on that processor.
    virtual void doneInserting();
    virtual void beginProcessing(int nelements);
};
\end{verbatim}

Charm++ level strategies also have to implement the insertMessage and
doneInserting methods. Here insertMessage takes a CharmMessageHolder
which is a Charm++ message wrapper. The call to beginProcessing
initializes the strategies on each processor. This additional call is
needed because the constructor of the strategy is called by user code
in main::main on processor 0. Along with initializing its data,
beginProcessing can also register message handlers, as the
communication library strategies use Converse to communicate between
processors. The flags {\em isArray} and {\em isGroup} store the type
of objects that call the strategy and the flag {\em
isStrategyBracketed} flag specifies if the CharmStrategy is bracketed
or not. Bracketed strategies require that the application deposits
messages in brackets demarcated by the calls ComlibBeginIteration and
ComlibEndIteration. Bracketed strategies are discussed in detail in
Section~\ref{sec:bracket}.
