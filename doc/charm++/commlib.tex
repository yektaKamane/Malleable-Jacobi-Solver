\subsection{Communication Optimizations Framework}

The communications framework in charm++/converse is aimed at
optimizing certain communication patterns. Currently the programmer
has to specify which communication pattern. In future this is aimed at
being automatic!

The communications library uses the delegation framework. This is to
make it transparent to the programmer. For each optimization there is
a Strategy which needs to be initialized and passed to the
Communication Library framework. Each strategy inherits from the class
{\em Strategy} and implements its entry methods.  Each strategy has
its own set of options passed to its constructor.

The communications library currently has the following strategies implemented.

\begin{itemize} 
\item EachToManyStrategy. EachToManyStrategy optimizes Collective 
personalized communication. In this communication operation each array
element sends a distinct message to many other array elements. The
sending and receiving elements need not belong to the same array.

Strategy * strategy = new EachToManyStrategy(topology);

The header file for this strategy is EachToManyStrategy.h.

The constructor takes am integer parameter {\em topology}. This tells
the strategy how to optimize the collective personalized communication
pattern. The options for topology are USE\_DIRECT, USE\_MESH,
USE\_HYPERCBE, USE\_GRID. USE\_DIRECT sends the message
directly. USE\_MESH imposes a 2d Mesh virtual topology on the
processors so now each processor sends messages to its neighbors in
its row and column of the mesh which forward the messages to their
correct destinations. USE\_HYPERCUBE and USE\_GRID impose a hypercube
and a 3d Grid topologies on the processors. USE\_HYPERCUBE will do
best for very small messages and small number of processors, 3d has
better performance for slightly higher message sizes and then Mesh
starts performing best. The programmer is encouraged to try out all
the strategies.

\item EachToManyMulticast. This strategy optimized the collective 
multicast operation. Here each array element sends the same message to
many other array elements.

Strategy * strategy = new EachToManyMulticast(topology);

here topology has the same values as explained above. Also the
header file is EachToManyMulticast.h.

\item StreamingStrategy. In this communication optimization strategy 
each array element sends many small messages to other array elements
but these sends are not synchronized and the library periodically
collects messages and sends them to their destinations. The period is
a parameter to the StreamingStrategy. It needs to be specified in
milli seconds. 10ms is the default

Strategy * strategy = new StreamingStrategy(period\_in\_ms);

Header file is StreamingStrategy.h.

\end{itemize}

\subsubsection{Initialization}

To use the communications library it needs to be compiled first.

\begin{verbatim}
cd charm/tmp/libs/ck-libs/commlib;
make;
\end{verbatim}

Calls to the communications library have to be made at three places in
the user program. They are :

\begin{enumerate}

\item main.ci, \\
\begin{verbatim}
 extern module ComlibModule; 
 readonly CkGroupID dmid; 
\end{verbatim}

\item main.C \\
\begin{verbatim}
 #include ''ComlibManager.h'' //Call this before all other includes!
 CkGroupID dmid; 

//In main::main() 
//Include the appropriate header file
#include <EachToManyStrategy.h>
//Create your strategy, options to strategy explained later
Strategy *strategy = new EachToManyStrategy(USE_MESH);

//Initialize the library and add strategies later
dmid = CProxy_ComlibManager::ckNew(); 

//Initialize the library and pass the strategy to the constructor
dmid = CProxy_ComlibManager::ckNew(strategy); 
//or 
dmid = CProxy_ComlibManager::ckNew(); 
int stratid = (CProxy_ComlibManager(dmid).ckLocalBranch())->createStrategy(strategy);
(CProxy_ComlibManager(dmid).ckLocalBranch())->doneCreating();
\end{verbatim}

\item In the array element \\
\begin{verbatim}
//Called in the constructor
//Registers the array element with the communications framework
(CProxy_ComlibManager(dmid).ckLocalBranch())->registerElement(stratid);

//Here the stratid is 0, if the strategy is passed in the 
//constructor or stratid if it is created from createStrategy

//Before calling an entry method whose message should go thorough the
//library the proxy has to be delegated. Create a new copy of the
//proxy and delegate it before using it.

<Array Proxy Type> dproxy = array_proxy;
dproxy.ckDelegate((CProxy_ComlibManager(dmid).ckLocalBranch());

(CProxy_ComlibManager(dmid).ckLocalBranch())->beginIteration();
dproxy[index].entry();
.....
.....
(CProxy_ComlibManager(dmid).ckLocalBranch())->endIteration();

//Now all calls to proxy will go through the library.
//So non library calls should use another proxy!
//The begin and end calls do not have to be called for the streaming strategy.
\end{verbatim}
\end{enumerate}

Creating more than one strategy \\
To create more than one strategy do the following in main::main()

Strategy strat1 = new ....; \\
Strategy strat2 = new ....; \\
Strategy strat3 = new ....; \\

int stratid1 = (CProxy\_ComlibManager(dmid).ckLocalBranch())->createStrategy(strat1); \\
int stratid2 = (CProxy\_ComlibManager(dmid).ckLocalBranch())->createStrategy(strat2); \\
int stratid3 = (CProxy\_ComlibManager(dmid).ckLocalBranch())->createStrategy(strat3); \\

(CProxy\_ComlibManager(dmid).ckLocalBranch())->doneCreating(); \\

Note: If more than one strategy is created array elements have to be
registerd for each of the strategies it participating in, with the
appropriate strategy id.
