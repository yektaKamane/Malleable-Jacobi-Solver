\subsection{Load Balancing Framework}
\label{lbFramework}

In \charmpp{}, objects(except groups) can migrate from processor to 
processor at run-time. Object migration can potentially improve the 
performance of the parallel program by migrating objects from overloaded 
processors to underloaded ones at run-time. However, we can see it is 
non-trivial to decide which objects to move and where to move them in 
order to achieve load balance in a fashion without the knowledge about the 
application. 

 \charmpp{} implements a generic, measurement-based load balancing framework 
which automatically instruments all \charmpp{} objects, collects computation 
load and communication pattern during execution and stores them into a 
\kw{load balancing database}. \charmpp{} then provides a collection of 
\kw{load balancing strategies} whose job is to decide on a new mapping of 
objects to processors based on information from the database.
This is made possible because we can reasonably assume that objects
in \charmpp{} application tend to exhibit temporal correlation in
their computation and communication patterns, i.e. future can be to some
extent predicted using the historical measurement data, allowing effective
measurement-based load balancing without application-specific knowledge.

Here are the two terms often used in \charmpp{} load balancing framework:
\begin{itemize}
\item \kw{Load balancer or strategy} takes the measurement
   data and produces the new mapping of the objects. In \charmpp{}, it is
   implemented as Chare Group inherited from BaseLB.
\item \kw{Load balancing database} provides the interface of almost all
   load balancing calls. On each processor, it stores the load
   balancing instrument data and coordinates the load balancing manager and
   balancer. it is implemented as a Chare Group.
\end{itemize}

\subsubsection{Available Load Balancing Strategies}
\label{lbStrategy}

Listed below are the available load balancers and their brief 
descriptions:
\begin{itemize}
\item {\bf RefineLB}:     Move objects away from the most overloaded processors to reach average;
\item {\bf RandCentLB}:   Randomly assign objects to processors;
\item {\bf RandRefLB}:    Randomly assign objects to processors, then refine;
\item {\bf RecBisectBfLB}:        Recursively partition with Breadth first enumeration;
\item {\bf MetisLB}:      Use Metis(tm) to partitioning object communication graph;
\item {\bf CommLB}:       Greedy algorithm which takes communication graph into account;
\item {\bf Comm1LB}:      another variation of CommLB;
\item {\bf HeapCentLB}:   Similar to RefineLB, but using heap to sort by load;
\item {\bf GreedyRefLB}:  Apply greedy, then refine;
\item {\bf NeighborLB}:   A neighborhood load balancer
\end{itemize}

It is up to the users to choose which load balancing algorithm for the
application at compile or run-time. The compiler and run-time options
are described at section \ref{lbOption}.

\subsubsection{Load Balancing Chare Arrays}
\label{lbarray}

Load balancing framework is well integrated with Chare array implementation - 
chare array when created automatically registers itself to load balancing
framework, instrument of compute wall/cpu time and communication is 
done automatically and APIs are provided for triggering the load balancing; 
thus load balancing with array is preferred in \charmpp{}, although 
experienced users still can do load balancing on normal chares using load 
balancing framework API, but this topic is currently beyond the scope of 
this manual.

To use the load balancer, you must make your array elements migratable
(see migration section above) and choose a \kw{load balancing strategy} 
(see the section \ref{lbStrategy} for a description
of available load balancing strategies).

We implemented three methods to use load balancing for chare arrays
trying to meet different needs of the application. These methods
are different in how and when a load balancing phase starts.
The three methods are: {\bf automatic without Sync}, 
{\bf automatic with Sync} and {\bf manual mode}.

In case of the two {\em automatic} load balancing modes, users don't need 
to worry about how to start the load balancing phase. Load balancer 
starts itself at some certain point based on the hint given by users. 
The users can either tell load balancer when is the good time to start 
load balancing({\em sync mode}) or simply say that he/she doesn't care
({\em without sync mode}). 
In {\em automatic without sync mode}, application asserts
that load balancer can start working at any time during the execution, and
guarantees that the chare arrays are always ready to 
migrate\footnote{All the state data of the array elements have to be 
properly packed before migrating to 
other processors}. In this mode, load balancer works in parallel with 
the application so application doesn't need to stop waiting for load 
balancing to complete. However, in most cases, 
application does not want load balancing to occur arbitrarily because it knows 
when is the proper time for load balancing\footnote{For example, in the 
application with multiple iterations, load balancing best happens 
every a few iterations}. {\em Automatic with sync} mode is designed for this 
scenario. In this mode, user inserts {\em AtSync()} calls at certain points 
in application where load balancing is desired. Load balancing is triggered 
after all the local array elements on each processor reach the sync 
point\footnote{It is implemented as a local barrier of all the array elements
on one processor}. However, {\em AtSync()} is not a blocking call, 
load balancing does not force the application to block until it  
finishes. When load balancing finishes, load balancer notifies every array
element by calling {\em ResumeFromSync()}
\footnote{{\em ResumeFromSync()} is a virtual function of array element
base class which can be redefined in application.}. In many applications,
it is often desirable that application waits for load balancing complete since
there may be migration occurs when load balancing and application may want to
respond to the migration. Thus, one of the popular strategy is that array
elements stop sending message after {\em AtSync()} is called, and resume 
work after load balancer calls back {\em ResumeFromSync()}.

The two {\em automatic} load balancing modes described above hide nicely
the details of invoking load balancer into the array implementation itself,
which makes the use of load balancing easier. 
However, this is relying on the assumption that load balancing occur only
after all array elements are created, i.e. {\em doneInserting()} 
must be called in case of dynamic inserting array elements. 
This is because array manager needs to maintain a head count of 
local array elements for the sync barrier
in order to tell if {\it everybody} is ready for load balancing, but
 dynamic inserting of array elements makes it impossible. In this case,
users have to use the {\em manual mode} to start load balancer themselves.
The API is described below.

A few notes about {\em ResumeFromSync()}\footnote{It used to 
only work in automatic with sync mode.}. It can be used in all above three
load balancing modes. To array element(whether it is migrated or not), 
it is more like getting a notification from load
balancer about the completeness of load balancing phase.
Users can choose to handle it by writing their own
code for {\em ResumeFromSync()}, or just ignore it. The proper use of both 
{\em AtSync()} and {\em ResumeFromSync()} gives you the effect of 
load balancing barrier. 

The detailed APIs of these three methods are described as follows:
\begin{enumerate}

\item {\bf automatic without Sync}: By default, the array elements may be asked to migrate at any time
provided that they are not in the middle of executing an entry method. 
The array element's variable \kw{usesAtSync} being CmiFalse attributes
to this default behavior. 

\item {\bf automatic with Sync}: Using the AtSync method, elements can 
only be migrated at certain points in the execution. For the AtSync method, 
set \kw{usesAtSync} to CmiTrue in your 
array element constructor.  When an element is ready to migrate,
call \kw{ArrayElement::AtSync()}.  
After the first \kw{doneInserting} call (which starts the load balancer)
and once all local elements have reached \kw{AtSync},
the load balancer runs and migrates elements.  Once
all migrations are completed, the load balancer calls the 
virtual function \kw{ArrayElement::ResumeFromSync()} for each of the
array element.  

Note that {\em AtSync()} is not a blocking call, it just suggests to load
balancing that it is time for load balancing. Between the calls to
{\em AtSync} and {\em ResumeFromSync}, the object
may be migrated. So the most commonly used approach is to stop sending
messages after array elements call {\em AtSync()}, and start sending
messages again in {\em ResumeFromSync}.
If processing some messages would prevent your object
from migrating (for example, because it would register itself with
a local group object, or set up some persistent communication),
then it is your responsibility to ensure such messages either aren't
sent during an {\em AtSync}, or are buffered until the {\em ResumeFromSync}.

\item {\bf manual mode}: The load balancer can be programmed to be started
manually. To switch to the manual mode, you should call
{\em TurnManualLBOn()} on every processor, so that no Load Balancer will 
be started automatically. {\em TurnManualLBOn()} should be called as 
early as possible in the program. It could be called at the initialization 
part of the program, 
for example from a global variable constructor, or an initcall.
It can also be called in the constructor of a static array and
definitely before the {\em doneInserting} call for a dynamic array.  This call 
has to be made on all processors. It can be called multiple times on one 
processor, but only the last one takes effect. One way to do this is to call
{\em TurnManualLBOn()} in a {\em initcall} function.  

The function call {\em StartLB()} will start the load balancer. 
This call should be made at only one place on a processors as it automatically 
start load balancing on all processors. The load balancer works in 
the background and won't stop the array elements from functioning. 
But since migration may happen at any time before load balancing finishes,
it is user's responsibility to make sure processing messages won't 
prevent objects from migrating. You can also choose to stop sending messages 
after calling {\em StartLB()}
\footnote{A global barrier is desired in this case}, and resume 
in {\em ResumeFromSync}.

{\em TurnManualLBOff()} turns off manual load balancing and 
switches back to the automatic Load balancing mode (using or not using AtSync). 

\end{enumerate}

\subsubsection{Other utility functions}

There are several utility functions that can be called in applications to
configure the load balancer, etc. These functions are:

\begin{itemize}
\item {\bf setMigratable(CmiBool migratable)}: is a member function of array
      element. This function can be called 
      in an array element constructor to tell load balancer wether this object
      is migratable or not\footnote{Currently not all load balancers 
      recognize this setting though.}.
\item {\bf lbdb->SetLBPeriod(double s)}: this function can be called
      anywhere\footnote{except that it must be called after LBDatabase
      has been initialized in Charm++ init phase, so for example global 
      variable constructor is not a good place to call it.} to regulate 
      the load balancing period. It tells load balancer not to start next 
      load balancing in less than s seconds. This can be used to prevent 
      load balancing from occuring too often in 
      {\em automatic without sync mode}. Here is how to use it:
      \begin{alltt}
// if used in an array element
LBDatabase *lbdb = getLBDB();
lbdb->SetLBPeriod(5);

// if used outside of an array element
// must be called after load balancer is initialized.
LBDatabase *lbdb = LBDatabase::Object();
lbdb->SetLBPeriod(5);
\end{alltt}
\end{itemize}

\subsubsection{Compiler and run-time options to use load balancing module}
\label{lbOption}

Load balancing strategies are implemented as libraries in \charmpp{}. This
allows programmers to easily experiment with different existing strategies 
by simply linking a pool of strategy modules and choose 
one to use at run-time via command line options.

Please note that linking a load balancing module is different from activating it:
\begin{itemize}
\item link a LB module: is to link a Load Balancer module(library) at 
   compile time; You can link against multiple LB libraries as candidates.
\item activate a LB: is to actually ask to create a LB strategy and 
   start it. You can only activate one LB either at compile time or at
   run-time and the LB module must be one of the LB module linked at 
   compile time.
\end{itemize}


Below are the descriptions about the compiler and run-time options:

\begin{enumerate}
\item {\bf compile time options:}

\begin{itemize}
\item {\em -module NeighborLB -module CommLB ...}  \\
  links module NeighborLB, CommLB ...
\item {\em -module EveryLB -lmetis} \\
  links special module EveryLB which includes all the load balancing strategy modules in \charmpp{}
\item {\em -balancer CommLB} \\
  links module CommLB and make it a default load balancer to activate at runtime.
\end{itemize}

The list of existing load balancers are in section \ref{lbStrategy}.
Note: you can have multiple -module *LBs options. LB modules are
linked into a program, but they are not activated.
Using -balancer to activate one LB as default at compile time. Having -balancer A implies -module A, so you don't have to write -module A, although it does
not hurt.
Using EveryLB is a convenient way to link against all existing LBs. 
One of the load balancer in EveryLB called MetisLB requires METIS library 
which is located at: charm/src/libs/conv-libs/metis. 
You need to compile it first by "make METIS" under charm/tmp.

\item {\bf run-time option:}

\begin{itemize}
\item {\em +balancer CommLB} \\
  activates a load balancer CommLB.
\end{itemize}

Note: +balancer option works only if you have already linked the LB module 
at compile time. +balancer with a 
wrong LB name will show you all the available LBs linked at compile time.
When you have used -balancer A as compile time option, you don't need to use 
+balancer A again to activate it at runtime. However, you can 
use +balancer B to override the compile time option and choose to
activate another LB - B.

\item {\bf When there is no LB activated}

When you don't activate any of load balancer at compile or run time, you still 
can run the program. This is done by automatically creating a NullLB which 
does nothing but calling {\em ResumeFromSync()}. 
The NullLB takes over when there is no LB activated, and will keep silent 
when non NULL LB is doing its job. 

\end{enumerate}

\subsubsection{Load Balancing Simulation}
The simulation feature of load balancing framework allows the users to collect information
about the compute wall/cpu time and communication of the chares during a particular run of
the program and use this information to later test different load balancing strategies to
see which one is suitable for the programs behavious. Currently, this feature is supported only for
the centralized load balancing strategies. For this, the load balancing framework
accepts the following command line options:
\begin{enumerate}
\item {\em +LBDump StepNo}\\
      This will dump the instrument/communication data collected by the load balancing framework
	  during the load balancing step {\em StepNo} into a file on the disk. The name of the file
	  is given by the {\em +LBDumpFile} option. After dumping the data, the program exists.
\item {\em +LBDumpFile FileName}\\
	This option specified the name of the file into which to dump the load balancing data. If this
	option is not specified, the framework uses the default file lbdata.dat.
\item {\em +LBSim} \\
	This option instructs the framework to do the simulation during the first load balancing step.
	When this option is specified, the load balancing data from the file specified in the {\em +LBDumpFile}
	option will be read and this data will be used for the load balancing. The program will then print
	the results of the load balancing and exit.
\end{enumerate}
As an example, we can collect tha data for a 1000 processor run if a program using:
\begin{alltt}
./charmrun pgm +p 1000 +balancer RandCentLB +LBDump 0 +LBDumpFile dump.dat
\end{alltt}
And then, we can use this data to observe various centralized strategies using:
\begin{alltt}
./charmrun pgm +balancer <Strategy to test> +LBSim +LBDumpFile
\end{alltt}
