\subsection{Load Balancing Framework}
\label{lbFramework}

In \charmpp{}, objects(except groups, nodegroups) can migrate from 
processor to processor at run-time. Object migration can potentially 
improve the performance of the parallel program by migrating objects from 
overloaded processors to underloaded ones. 

%However, it is not
%trivial to decide which objects to move and where to move them in 
%order to achieve load balance in a fashion without the knowledge about the 
%application. The strategy used in \charmpp{} load balancing framework
%is a measurement-based one.

 \charmpp{} implements a generic, measurement-based load balancing framework 
which automatically instruments all \charmpp{} objects, collects computation 
load and communication structure during execution and stores them into a 
\kw{load balancing database}. \charmpp{} then provides a collection of 
\kw{load balancing strategies} whose job is to decide on a new mapping of 
objects to processors based on the information from the database.
This is made possible because we can reasonably assume that objects
in \charmpp{} application tend to exhibit temporal correlation in
their computation and communication patterns, i.e. future can be to some
extent predicted using the historical measurement data, allowing effective
measurement-based load balancing without application-specific knowledge.

Here are the two terms often used in \charmpp{} load balancing framework:
\begin{itemize}
\item \kw{Load balancing database} provides the interface of almost all
   load balancing calls. On each processor, it stores the load
   balancing instrument data and coordinates the load balancing manager and
   balancer. it is implemented as a Chare Group called {\kw LBDatabase}.
\item \kw{Load balancer or strategy} takes the load balancing database
   and produces the new mapping of the objects. In \charmpp{}, it is
   implemented as Chare Group inherited from BaseLB. Two schemes are
   implemented, they are (a) centralized load balancers and (b)
   distributed load balancers.
\end{itemize}

\subsubsection{Available Load Balancing Strategies}
\label{lbStrategy}

Load balancing can be performed in either a centralized or distributed
fashion.

In centralized approaches, the entire machine's load and communication
structure are accumulated to a single point, typically processor 0, 
followed by a decision making process to determine the new distribution
of \charmpp objects. Centralized load balancing requires synchronization
which may incur an overhead and delay. However, due to the fact that
the decision process has a high degree of the knowledge about the entire
machine, it tends to be more accurate.

In distributed approaches, machine states are only exchanges among 
neighboring processors. There is no global synchronization. However,
it will not, in general, provide an immediate solution for load balance -
the process is iterated until the load balance can be achieved.

Listed below are the available centralized load balancers and their brief 
descriptions:
\begin{itemize}
\item {\bf RefineLB}:     Move objects away from the most overloaded processors to reach average;
\item {\bf RefineCommLB}:     Same idea as in RefineLB, but take communication into account;
\item {\bf RandCentLB}:   Randomly assign objects to processors;
\item {\bf RandRefLB}:    Randomly assign objects to processors, then refine;
\item {\bf RecBisectBfLB}:        Recursively partition with Breadth first enumeration;
\item {\bf MetisLB}:      Use Metis(tm) to partitioning object communication graph;
\item {\bf GreedyLB}:   Use greedy algorithm, always pick the heaviest object to the least loaded processor.
\item {\bf GreedyRefLB}:  Apply greedyLB, and then refine;
\item {\bf GreedyCommLB}:       Greedy algorithm which also takes communication graph into account;
\item {\bf ComboCentLB}:  A special load balancer that can be used to combine any number of above centralized load balancers;
\end{itemize}

Listed below are the distributed load balancers:
\begin{itemize}
\item {\bf NeighborLB}:   A neighborhood load balancer in which each processor tries to average out its load only among its neighbors.
\item {\bf WSLB}:   A load balancer for workstation clusters, which can detect load changes on desktops and adjust load without interfere with other's use of the desktop.
\end{itemize}

User can choose any load balancing strategy he or she thinks is the good
for the application. 
The compiler and run-time options
are described in section \ref{lbOption}.

%In some cases, one may need to create and invoke multiple load balancing
%strategies/algorithms at the different phases. \charmpp{} now supports
%multiple load balancers created at runtime. For example, one can use 
%an aggressive load balancer such as GreedyRefLB in the first load balancing
%step, and use RefineLB for the later load balancing steps.

\subsubsection{Load Balancing Chare Arrays}
\label{lbarray}

Load balancing framework is well integrated with Chare array implementation - 
chare array when created automatically registers itself to load balancing
framework, instrument of compute time (wall/cpu time) and communication 
pattern is done automatically and APIs are provided for users to trigger the 
load balancing; thus load balancing with array is preferred in \charmpp{}, 
although experienced users still can do load balancing on normal chares 
using load balancing framework, but this topic is beyond the scope of 
this manual.

To use the load balancer, you must make your array elements migratable
(see migration section above) and choose a \kw{load balancing strategy} 
(see the section \ref{lbStrategy} for a description
of available load balancing strategies).

We implemented three methods to use load balancing for chare arrays
trying to meet different needs of the applications. These methods
are different in how and when a load balancing phase starts.
The three methods are: {\bf periodical load balancing mode}, 
{\bf automatic with Sync mode} and {\bf manual mode}.

In {\em periodical load balancing mode}, user just need to specify how
often he wants the load balancing to occur, using +LBPeriod runtime
option to specify a time interval. 

In {\em sync mode}, users can tell load balancer explicitly when is a good 
time to trigger load balancing by inserting function call in the user
code.


%In this mode, load balancer works in parallel with 
%the application so application doesn't need to stop waiting for load 
%balancing to complete. However, in most cases, 
%application does not want load balancing to occur arbitrarily because it 
%has better idea about when a load balancing should 
%happen\footnote{For example, in the application with multiple iterations, 
%load balancing should happens in every a few iterations}. 
%{\em Automatic with sync} mode is designed for this 
%scenario. In this mode, user inserts {\em AtSync()} calls at certain points 
%in application where he thinks the load balancing is desired. 
%Load balancing is then triggered after all the local array elements on 
%the processor reach the sync point\footnote{It is implemented as a local 
%barrier of all the array elements on one processor}. 
%However, {\em AtSync()} is not a blocking call, 
%load balancing does not force the application to block until it  
%finishes. When load balancing finishes, load balancer notifies every array
%element by calling {\em ResumeFromSync()}
%\footnote{{\em ResumeFromSync()} is a virtual function of array element
%base class which can be redefined in application.}. In many applications,
%it is often desirable that application waits for load balancing complete since
%there may be migration occurs when load balancing and application may want to
%respond to the migration. Thus, one of the commonly applied strategy is 
%that array elements stop sending message after {\em AtSync()} is called, 
%and resume work after load balancer calls back {\em ResumeFromSync()}.

In the above two load balancing modes, users don't need 
to worry about how to start load balancing. 
However, in one scenario, the above automatic load balancers will fail to
work - array elements are created by dynamic insertion.
This is because the above two load balancing modes require an application
to have fixed number of objects at the time of load balancing.
The array manager needs to maintain a head count of local array elements
for the local barrier.
In this case, users have to use the {\em manual mode} to trigger 
load balancer themselves. The API is described below.

%A few notes about {\em ResumeFromSync()}\footnote{It used to 
%only work in automatic with sync mode.}. It can be used in all above three
%load balancing modes. For an array element(whether it is migrated or not), 
%it is more like getting a notification from load
%balancer about the completeness of load balancing phase.
%Users can choose to handle it by writing their own
%code for {\em ResumeFromSync()}, or just ignore it. The proper use of both 
%{\em AtSync()} and {\em ResumeFromSync()} gives you the effect of 
%load balancing barrier. 

The detailed APIs of these three methods are described as follows:
\begin{enumerate}

\item {\bf periodical load balancing mode}: By default, the array elements 
may be asked to migrate at any time provided that they are not in 
the middle of executing an entry method. 
The array element's variable \kw{usesAtSync} being CmiFalse attributes
to this default behavior. In the default setting, load balancing happens
whenever the array elements are ready with interval of 1 second. It is 
desirable for the application to set a larger interval using +LBPeriod
runtime option. For example "+LBPeriod 5" to start load balancing roughly
every 5 seconds.

\item {\bf automatic with Sync}: Using the AtSync method, elements can 
only be migrated at certain points in the execution when user calls 
\kw{AtSync()}. 
For the AtSync method, set \kw{usesAtSync} to CmiTrue in your 
array element constructor.  When an element is ready to migrate,
call \kw{AtSync()}~\footnote{AtSync() is a member function of class ArrayElement}.  
When all local elements call \kw{AtSync}, the load balancer is triggered.  
Once all migrations are completed, the load balancer calls the 
virtual function \kw{ArrayElement::ResumeFromSync()} on each of the
array element.  

Note that {\em AtSync()} is not a blocking call, it just give a hint to load
balancing that it is time for load balancing. During the time between 
{\em AtSync} and {\em ResumeFromSync}, the object may be migrated. 
One can choose to let objects continue working with incoming messages,
however keep in mind the object may suddenly show up in another processor
and make sure no operations that could possibly prevent migration 
be performed. The most commonly used approach is to force the object to 
be idle until load balancing finishes, the object can start working again
when \kw{ResumeFromSync()} is called.

\item {\bf manual mode}: The load balancer can be programmed to be started
manually. To switch to the manual mode, you should call
{\em TurnManualLBOn()} on every processor to prevent load balancer from 
starting automatically. {\em TurnManualLBOn()} should be called as 
early as possible in the program. It could be called at the initialization 
part of the program, 
for example from a global variable constructor, or in an initcall~\ref{initcall}.
It can also be called in the constructor of a static array and
definitely before the {\em doneInserting} call for a dynamic array.  
It can be called multiple times on one 
processor, but only the last one takes effect.

The function call {\em StartLB()} starts load balancing immediately. 
This call should be made at only one place on only one processor.
This function is also not blocking, the object will continue to process
messages and the load balancing when triggered
happens at the background.

{\em TurnManualLBOff()} turns off manual load balancing and 
switches back to the automatic Load balancing mode.

\end{enumerate}

\subsubsection{Migrating objects}
\label{lbmigobj}

Load balancers migrate objects automatically.
For an array element to migrate, user can refer to section~\ref{arraymigratable}
for how to write a ``pup'' for an array element.

In general one needs to pack the whole snapshot of the member data in an 
array element in the pup subroutine. This is because the migration of
the object may happen at any time. In certain load balancing scheme where
user explicitly control when the load balancing happens, user may choose
to pack only a part of the data and may skip those temporary data.

\subsubsection{Other utility functions}

There are several utility functions that can be called in applications to
configure the load balancer, etc. These functions are:

\begin{itemize}
\item {\bf setMigratable(CmiBool migratable)}: is a member function of array
      element. This function can be called 
      in an array element constructor to tell load balancer whether this object
      is migratable or not\footnote{Currently not all load balancers 
      recognize this setting though.}.
\item {\bf lbdb->SetLBPeriod(double s)}: this function can be called
      anywhere\footnote{except that it must be called after LBDatabase
      has been initialized in Charm++ init phase, so for example global 
      variable constructor is not a good place to call it.} to regulate 
      the load balancing period. It tells load balancer not to start next 
      load balancing in less than s seconds. This can be used to prevent 
      load balancing from occurring too often in 
      {\em automatic without sync mode}. Here is how to use it:
      \begin{alltt}
// if used in an array element
LBDatabase *lbdb = getLBDB();
lbdb->SetLBPeriod(5);

// if used outside of an array element
// must be called after load balancer is initialized.
LBDatabase *lbdb = LBDatabase::Object();
lbdb->SetLBPeriod(5);
\end{alltt}
\end{itemize}

\subsubsection{Compiler and run-time options to use load balancing module}
\label{lbOption}

Load balancing strategies are implemented as libraries in \charmpp{}. This
allows programmers to easily experiment with different existing strategies 
by simply linking a pool of strategy modules and choose 
one to use at run-time via command line options.

Please note that linking a load balancing module is different from activating it:
\begin{itemize}
\item link a LB module: is to link a Load Balancer module(library) at 
   compile time; You can link against multiple LB libraries as candidates.
\item activate a LB: is to actually ask to create a LB strategy and 
   start it. You can only activate one LB either at compile time or at
   run-time and the LB module must be one of the LB module linked at 
   compile time.
\end{itemize}


Below are the descriptions about the compiler and run-time options:

\begin{enumerate}
\item {\bf compile time options:}

\begin{itemize}
\item {\em -module NeighborLB -module GreedyCommLB ...}  \\
  links module NeighborLB, GreedyCommLB ...
\item {\em -module EveryLB} \\
  links special module EveryLB which includes all the load balancing strategy modules in \charmpp{}
\item {\em -balancer GreedyCommLB} \\
  links module GreedyCommLB and invoke this load balancer at runtime. One can specify multiple load balancers for example: \\
   {\em -balancer GreedyCommLB -balancer RefineLB}   \\
   This will start first load balancing using GreedyCommLB, and second load balancing using RefineLB, and same RefineLB in the subsequent load balancing.
\item {\em -balancer ComboCentLB:GreedyLB,RefineLB}  \\
   One can choose to invoke mixes of load balancers in one load balancing step. The above example specify a default load balancer which first apply GreedyLB algorithm followed by RefineLB algorithm.
\end{itemize}

The list of existing load balancers are in section \ref{lbStrategy}.
Note: you can have multiple -module *LB options. LB modules are
linked into a program, but they are not activated.
Using -balancer to activate load balancers as default at compile time. 
Having -balancer A implies -module A, so you don't have to write -module A, 
although it does not hurt.
Using EveryLB is a convenient way to link against all existing load balancers. 
One of the load balancer in EveryLB called MetisLB requires METIS library 
which is located at: charm/src/libs/conv-libs/metis. 
You need to compile it first by "make METIS" under charm/tmp.

\item {\bf run-time options:}

Run-time options are doing the same thing as compile time options, but they override the compile time options.

\begin{itemize}
\item {\em +balancer GreedyCommLB} \\
  activates a load balancer GreedyCommLB. Multiple load balancers can be created at the runtime. (same as compile time options)
\item {\em +balancer ComboCentLB:GreedyLB,RefineLB}  \\
  same as the example in +balancer compile time option.
\end{itemize}

Note: +balancer option works only if you have already linked the load balancers module at compile time. +balancer with a 
wrong LB name will show you all the available LBs linked at compile time.
When you have used -balancer A as compile time option, you don't need to use 
+balancer A again to activate it at runtime. However, you can 
use +balancer B to override the compile time option and choose to
activate B instead of A.

\item {\bf When there is no load balancer activated}

When you don't activate any of load balancer at compile or run time, you still 
can run the program. This is done by automatically creating a NullLB which 
does nothing but calling {\em ResumeFromSync()}. 
The NullLB takes over when there is no LB activated, and will keep silent 
when non NULL LB is doing its job. 

\end{enumerate}

\subsubsection{Load Balancing Simulation}
The simulation feature of load balancing framework allows the users to collect information
about the compute wall/cpu time and communication of the chares during a particular run of
the program and use this information to later test different load balancing strategies to
see which one is suitable for the programs behaviour. Currently, this feature is supported only for
the centralized load balancing strategies. For this, the load balancing framework
accepts the following command line options:
\begin{enumerate}
\item {\em +LBDump StepStart}\\
        This will dump the instrument/communication data collected by the load balancing framework
	starting from the load balancing step {\em StepStart} into a file on the disk. The name of the file
	is given by the {\em +LBDumpFile} option.
\item {\em +LBDumpSteps StepsNo}\\
        This option specify for how many steps to dump the data to the disk. If omitted, default value is 1.
	The program will exit after StepsNo files are dumped.
\item {\em +LBDumpFile FileName}\\
	This option specified the base name of the file into which to dump the load balancing data. If this
	option is not specified, the framework uses the default file {\tt lbdata.dat}. Since multistep is allowed,
	to this base name it is added the step number in the form {\tt Filename.\#}; this apply to both dump and
	simulation.
\item {\em +LBSim StepStart}\\
	This option instructs the framework to do the simulation during the first load balancing step.
	When this option is specified, the load balancing data from the file specified in the {\em +LBDumpFile}
	option, with the addition of the step number, will be read and this data
	will be used for the load balancing. The program will print the results
	of the balancing for a number of steps given by the {\em +LBSimSteps} option, and then will exit.
\item {\em +LBSimSteps StepsNo}\\
        This options has the same meaning of {\em +LBDumpSteps}, except that apply for the simulation mode.
	Default value is 1.
\item {\em +LBSimProcs}\\
        This option may change the number of processors target of the load balancer strategy. It may be used to test
	the load balancer in conditions where some processor crashes or someone becomes available. If this number is not
	changed since the original run, starting from the second step file the program will print other additional
	information about how the simulated load differ from the real load during the run (considering all
	strategies that were applied while running). This may be used to test the validity of a load balancer
	prediction over the reality. If the strategies used during run and simulation differ, the additional data
	printed may not be useful.
\end{enumerate}
As an example, we can collect the data for a 1000 processor run of a program using:
\begin{alltt}
./charmrun pgm +p 1000 +balancer RandCentLB +LBDump 2 +LBDumpSteps 4 +LBDumpFile dump.dat
\end{alltt}
This will collect data on files data.dat.{2,3,4,5}. Then, we can use this data to observe various centralized strategies using:
\begin{verbatim}
./charmrun pgm +balancer <Strategy to test> +LBSim 2 +LBSimSteps 4 
               +LBDumpFile dump.dat [+LBSimProcs 900]
\end{verbatim}
