\subsection{Load Balancing Framework}
\label{lbFramework}

In \charmpp{}, objects(except groups) can migrate from processor to 
processor at run-time. Object migration can potentially improve the 
performance of the parallel program by migrating objects from overloaded 
processors to underloaded ones at run-time. However, we can see it is 
non-trivial to decide which objects to move and where to move them in 
order to achieve load balance in a fashion without the knowledge about the 
application. 

 \charmpp{} implements a generic, measurement-based load balancing framework 
which automatically instruments all \charmpp{} objects, collects computation 
load and communication pattern during execution and stores them into a 
\kw{load balancing database}. \charmpp{} then provides a collection of 
\kw{load balancing strategies} whose job is to decide on a new mapping of 
objects to processors based on information from the database.
This is made possible because we can reasonably assume that objects 
in \charmpp{} application tend to exhibit temporal correlation in 
their computation and communication patterns, i.e. future can be to some 
extent predicted using the historical measurement data, allowing effective 
measurement-based load balancing without application-specific knowledge. 

Here are the two terms oftenly used in \charmpp{} load balancing framework:
\begin{itemize}
\item \kw{Load balancer or strategy} takes the measurement
   data and produces the new mapping of the objects. In \charmpp{}, it is
   implemented as Chare Group inherited from BaseLB.
\item \kw{Load balancing database} provides the interface of almost all
   load balancing calls. On each processor, it stores the load 
   balancing instrument data and coordinates the load balancing manager and 
   balancer. it is implemented as a Chare Group.
\end{itemize}

\subsubsection{Available Load Balancing Strategies}
\label{lbStrategy}

Listed below are the available load balancers and their brief 
descriptions:
\begin{itemize}
\item \kw{RandCentLB}:   Randomly assign objects to processors;
\item \kw{RandRefLB}:    Randomly assign objects to processors, then refine;
\item \kw{RefineLB}:     Move a few objects away from the most overloaded processors;
\item \kw{RecBisectBfLB}:        Recursive partition with Breadth first enumeration;
\item \kw{MetisLB}:      Use Metis(tm) to partitioning object communication graph;
\item \kw{CommLB}:       Greedy with communication;
\item \kw{Comm1LB}:      another variation of CommLB;
\item \kw{HeapCentLB}:   Heap Centralized;
\item \kw{GreedyRefLB}:  Apply greedy, then refine;
\item \kw{NeighborLB}:   The neighborhood load balancer
\end{itemize}

It is up to the users to choose which load balancing algorithm for the 
application at compile or run-time. The compiler and run-time options 
are described at section \ref{lbOption}.

\subsubsection{Load Balancing Chare Arrays}
\label{lbarray}

Load balancing framework is well integrated with Chare array implementation - 
chare array when created automatically registers itself to load balancing
framework, instrument of compute wall/cpu time and communication is 
done automatically and APIs are provided for triggering the load balancing; 
thus load balancing with array is prefered in \charmpp{}, although 
experienced users still can do load balancing on normal chares using load 
balancing framework API, but this topic is currently beyond the scope of 
this manual.

To use the load balancer, you must make your array elements migratable
(see migration section above) and choose a \kw{load balancing strategy} 
(see the section \ref{lbStrategy} for a description
of available load balancing strategies).

We implemented three methods to use load balancing for chare arrays
trying to meet different needs of the application. These methods
are different in how and when a load balancing phase starts.
The three methods are: {\bf automatic without Sync}, 
{\bf automatic with Sync} and {\bf manual mode}.

In case of the two {\em automatic} load balancing modes, users don't need 
to worry about how to start the load balancing phase. Load balancer 
starts itself at some certain point based on the hint given by users. 
The users can either tell load balancer when is the good time to start 
load balancing({\em sync mode}) or simply say that he/she doesn't care
({\em without sync mode}). 
In {\em automatic without sync mode}, application asserts
that load balancer can start working at any time during the execution, and 
guarantees that the chare arrays are always ready to 
migrate\footnote{All the state data of the array elements have to be 
properly packed before migrating to 
other processors}. In this mode, load balancer works in parallel with 
the application so application doesn't need to stop waiting for load 
balancing to complete. However, in most cases, 
application doesn't want load balancing to occur arbitarily because it knows 
when is the proper time for load balancing\footnote{For example, in the 
application with multiple iterations, load balancing best happens 
every a few iterations}. {\em Automatic with sync} mode is designed for this 
scenario. In this mode, user inserts {\em AtSync()} calls at certain points 
in application where load balancing is desired. Load balancing takes 
control after all the local array elements reach the sync 
point\footnote{It is implemented as a local barrier of all the array elements
on one processor}, and starts load balancing phases from there. The common
practice is that the application would choose to take a break and 
wait for the load balancing and migration complete until it regains 
the control when load balancer calls back {\em ResumeFromSync()} for every
array element. {\em ResumeFromSync()} is a virtual function of array element 
base class which can be redefined in application.

The two {\em automatic} load balancing modes described above hide nicely
the details of invoking load balancer into the array implemetation itself,
which makes the use of load balancing easier. 
However, this is relying on the assumption that load balancing occur only
after all array elements are created, i.e. {\em doneInserting()} 
must be called in case of dynamic inserting array elements. 
This is because array manager needs to maintain a head count of 
local array elements for the sync barrier
in order to tell if {\it everybody} is ready for load balancing, but
 dynamic inserting of array elements makes it impossible. In this case,
users have to use the {\em manual mode} to start load balancer themselves.

A few more words about {\em ResumeFromSync()}\footnote{It used to 
only work in automatic with sync mode.}. It works in all above three
load balancing modes. To array element(whether it is migrated or not), 
it is more like getting a notification from load
balancer about the completeness of load balancing phase.
Users can choose to handle it by writing their own
code for {\em ResumeFromSync()}, or just ignore it. The proper use of both 
{\em AtSync()} and {\em ResumeFromSync()} gives you the effect of 
load balancing barrier.

The detailed APIs of these three methods are described as follows:
\begin{enumerate}

\item {\bf automatic without Sync}: By default, the array elements may be asked to migrate at any time
provided that they are not in the middle of executing an entry method. 
The array element's variable \kw{usesAtSync} being CmiFalse attributes
to this default behaviour. 

\item {\bf automatic with Sync}: Using the AtSync method, elements can 
only be migrated at certain points in the execution. For the AtSync method, 
set \kw{usesAtSync} to CmiTrue in your 
array element constructor.  When an element is ready to migrate,
call \kw{ArrayElement::AtSync()}.  
After the first \kw{doneInserting} call (which starts the load balancer)
and once all local elements have reached \kw{AtSync},
the load balancer runs and migrates elements.  Once
all migrations are completed, the load balancer calls the 
virtual function \kw{ArrayElement::ResumeFromSync()} for each of the
array element.  One must ensure that no messages are
sent to an array element between its calls to \kw{AtSync} and
\kw{ResumeFromSync}. 

Note: Setting usesAtSync to true makes it mandatory for the array
element to call \kw{AtSync} and implement the \kw{ResumeFromSync}
 function.

\item {\bf manual mode}: The load balancer can be programmed to be started
manually. To use this feature, the load balancing database object - LBDatabase 
must first be retrieved explicitly by making the call \kw{LBDatabase::Object()}.
For example, 
\begin{alltt}
LBDatabase * myLbdb = LBDatabase::Object()
\end{alltt}
{\em myLbdb-$>$TurnManualLBOn()} will enable the manual switching on of
the Load Balancer, so that no Load Balancer will be started automatically.
{\em TurnManualLBOn()} should be called as early as possible in the
program. It must be ideally called in the constructor of a static array and
definitely before the doneInserting call for a dynamic array.  This call 
has to be made on all processors. It can be called multiple times on one 
pe, but the last one takes effect.   
The function call {\em myLbdb-$>$StartLB()} will start the load balancer. 
This call can be made on only one pe as the start message is broadcasted 
to all processors. The load balancing happens in the background and 
won't stop the array elements from functioning. 
{\em myLbdb-$>$TurnManualLBOff()} turns off manual load balancing and 
switches back to the automatic Load balancing mode (using or not using AtSync). 

\end{enumerate}


\subsubsection{Compiler and run-time options to use load balancing module}
\label{lbOption}

Load balancing strategies are implemented as libraries in \charmpp{}. This
allows programmers to easily experiment with different existing strategies 
by simply linking a pool of strategy modules and choose 
one to use at run-time via command line options.

Please note that linking a load balancing module is different from activating it:
\begin{itemize}
\item link a LB module: is to link a Load Balancer module(library) at 
   compile time; You can link against multiple LB libraries as candidates.
\item activate a LB: is to actually ask to create a LB strategy and 
   start it. You can only activate one LB either at compile time or at
   run-time and the LB module must be one of the LB module linked at 
   compile time.
\end{itemize}


Below are the descriptions about the compiler and run-time options:

\begin{enumerate}
\item {\bf compile time options:}

\begin{itemize}
\item {\em -module NeighborLB -module CommLB ...}  \\
  links module NeighborLB, CommLB ...
\item {\em -module EveryLB -lmetis} \\
  links special module EveryLB which includes all the load balancing strategy modules in \charmpp{}
\item {\em -balancer CommLB} \\
  links module CommLB and make it a default load balancer to activate at runtime.
\end{itemize}

Note: you can have multiple -module *LBs options. LB modules are
linked into a program, but they are not activated.
Using -balancer to activate one LB as default at compile time. Having -balancer A implies -module A, so you don't have to write -module A, although it does't hurt.
Using EveryLB is a convenient way to link against all existing LBs. 
One of the load balancer in EveryLB called MetisLB requires METIS library 
which is located at: charm/src/libs/conv-libs/metis. 
You need to compile it first by "make METIS" under charm/tmp.

\item {\bf run-time option:}

\begin{itemize}
\item {\em +balancer CommLB} \\
  activates a load balancer CommLB.
\end{itemize}

Note: +balancer option works only if you have already linked the LB module 
at compile time. +balancer with a 
wrong LB name will show you all the available LBs linked at compile time.
When you have used -balancer A as compile time option, you don't need to use 
+balancer A again to activate it at runtime. However, you can 
use +balancer B to override the compile time option and choose to
activate another LB - B.

\item {\bf When there is no LB activated}

When you don't activate any of load balancer at compile or run time, you still 
can run the program. This is done by automatically creating a NullLB which 
does nothing but calling {\em ResumeFromSync()}. 
The NullLB takes over when there is no LB activated, and will keep silent 
when non NULL LB is doing its job. 

\end{enumerate}


