
\subsection{Load Balancing}
\label{loadbalancing}

%(This introduction added on 11/12/2003)

Charm++ supports Load Balancing, enabled by the fact there are a large
number of chares or chare-array-elements typically available to map to
existing processors, and that they can be migrated at runtime.

Many parallel applications, especially physical simulations, are
iterative in nature. They may contain a series of time-steps, and/or
iterative solvers that run to convergence. For such computations,
typically, the heuristic principle that we call "principle of
persistence" holds: the computational loads and communication patterns
between objects (chares) tend to persist over time, even in dynamic
applications. In such cases, recent past is a good predictor of near
future. Measurement-based chare migration strategies are useful in
this context. Currently these apply to chare-array elements, but they
may be extended to chares in future.

For applications without such iterative structure, or with iterative
structure but without the predictability (i.e. where the principle of
persistence does not apply), Charm++ supports "seed balancers" that
move seeds for new chares among processors (possibly repeatedly) to
achieve load balance. These strategies are currently available for
both chares and chare-arrays. 
Seed balancers were the original load balancers provided in Charm since the
late '80s. They are extremely useful for state-space search
applications, and are also useful in other computations, as well as in
conjunction with migration strategies.

For iterative computations when there is a correlation between
iterations/steps but either it is not strong or the machine
environment is not predictable (noise due to OS interrupts on small
time steps, or time-shared desk-top machines), one can use a
combination of the two kinds of strategies. The base-line load
balancing is provided by migration strategies; But in each iteration
one also spawns off work in the form of chares that can run on any
processor. The seed balancer will handle such work as it arises.

\subsubsection{Measurement-based Object Migration Strategies}
\label{lbFramework}
\label{migrationlb}

In \charmpp{}, objects(except groups, nodegroups) can migrate from 
processor to processor at run-time. Object migration can potentially 
improve the performance of the parallel program by migrating objects from 
overloaded processors to underloaded ones. 

%However, it is not
%trivial to decide which objects to move and where to move them in 
%order to achieve load balance in a fashion without the knowledge about the 
%application. The strategy used in \charmpp{} load balancing framework
%is a measurement-based one.

 \charmpp{} implements a generic, measurement-based load balancing framework 
which automatically instruments all \charmpp{} objects, collects computation 
load and communication structure during execution and stores them into a 
\kw{load balancing database}. \charmpp{} then provides a collection of 
\kw{load balancing strategies} whose job is to decide on a new mapping of 
objects to processors based on the information from the database.
Such measurement based strategies are efficient when
we can reasonably assume that objects
in \charmpp{} application tend to exhibit temporal correlation in
their computation and communication patterns, i.e. future can be to some
extent predicted using the historical measurement data, allowing effective
measurement-based load balancing without application-specific knowledge.

Here are the two terms often used in \charmpp{} load balancing framework:
\begin{itemize}
\item \kw{Load balancing database} provides the interface of almost all
   load balancing calls. On each processor, it stores the load
   balancing instrumented data and coordinates the load balancing manager and
   balancer. it is implemented as a Chare Group called {\kw LBDatabase}.
\item \kw{Load balancer or strategy} takes the load balancing database
   and produces the new mapping of the objects. In \charmpp{}, it is
   implemented as Chare Group inherited from BaseLB. Two kinds of schemes are
   implemented, they are (a) centralized load balancers and (b)
   distributed load balancers.
\end{itemize}

\subsubsection{Available Load Balancing Strategies}
\label{lbStrategy}

Load balancing can be performed in either a centralized or distributed
fashion.

In centralized approaches, the entire machine's load and communication
structure are accumulated to a single point, typically processor 0, 
followed by a decision making process to determine the new distribution
of \charmpp objects. Centralized load balancing requires synchronization
which may incur an overhead and delay. However, due to the fact that
the decision process has a high degree of the knowledge about the entire
machine, it tends to be more accurate.

In distributed approaches, machine states are only exchanged among 
neighboring processors. There is no global synchronization. However,
they will not, in general, provide an immediate restoration for load balance -
the process is iterated until the load balance can be achieved.

Listed below are the available centralized load balancers and their brief 
descriptions:
\begin{itemize}
\item {\bf RefineLB}:     Move objects away from the most overloaded processors to reach average, limits the number of objects migrated;
\item {\bf RefineCommLB}:     Same idea as in RefineLB, but take communication into account;
\item {\bf RandCentLB}:   Randomly assigns objects to processors;
\item {\bf RandRefLB}:    Randomly assigns objects to processors, then refines;
\item {\bf RecBisectBfLB}:        Recursively partition with Breadth first enumeration;
\item {\bf MetisLB}:      Use Metis(tm) to partitioning object communication graph;
\item {\bf GreedyLB}:   Use greedy algorithm, always pick the heaviest object to the least loaded processor.
\item {\bf GreedyRefLB}:  Apply greedyLB, and then refine;
\item {\bf GreedyCommLB}:       Greedy algorithm which also takes communication graph into account;
\item {\bf ComboCentLB}:  A special load balancer that can be used to combine any number of above centralized load balancers;
\end{itemize}

Listed below are the distributed load balancers:
\begin{itemize}
\item {\bf NeighborLB}:   A neighborhood load balancer in which each processor tries to average out its load only among its neighbors.
\item {\bf WSLB}:   A load balancer for workstation clusters, which can detect load changes on desktops (and other timeshared processors) and adjust load without interferes with other's use of the desktop.
\end{itemize}

User can choose any load balancing strategy he or she thinks is the good
for the application. 
The compiler and run-time options
are described in section \ref{lbOption}.

%In some cases, one may need to create and invoke multiple load balancing
%strategies/algorithms at the different phases. \charmpp{} now supports
%multiple load balancers created at runtime. For example, one can use 
%an aggressive load balancer such as GreedyRefLB in the first load balancing
%step, and use RefineLB for the later load balancing steps.

\subsubsection{Load Balancing Chare Arrays}
\label{lbarray}

Load balancing framework is well integrated with Chare array implementation - 
when a chare array is created, it  automatically registers its elements 
to load balancing framework, instrument of compute time (wall/cpu time) 
and communication pattern is done automatically and APIs are provided 
for users to trigger the load balancing. 

To use the load balancer, you must make your array elements migratable
(see migration section above) and choose a \kw{load balancing strategy} 
(see the section \ref{lbStrategy} for a description
of available load balancing strategies).

We implemented three methods to use load balancing for chare arrays
to meet different needs of the applications. These methods
are different in how and when a load balancing phase starts.
The three methods are: {\bf periodic load balancing mode}, 
{\bf automatic with Sync mode} and {\bf manual mode}.

In {\em periodic load balancing mode}, a user just needs to specify how
often he wants the load balancing to occur, using +LBPeriod runtime
option to specify a time interval. 

In {\em sync mode}, users can tell load balancer explicitly when is a good 
time to trigger load balancing by inserting a function call in the user
code.


%In this mode, load balancer works in parallel with 
%the application so application doesn't need to stop waiting for load 
%balancing to complete. However, in most cases, 
%application does not want load balancing to occur arbitrarily because it 
%has better idea about when a load balancing should 
%happen\footnote{For example, in the application with multiple iterations, 
%load balancing should happens in every a few iterations}. 
%{\em Automatic with sync} mode is designed for this 
%scenario. In this mode, user inserts {\em AtSync()} calls at certain points 
%in application where he thinks the load balancing is desired. 
%Load balancing is then triggered after all the local array elements on 
%the processor reach the sync point\footnote{It is implemented as a local 
%barrier of all the array elements on one processor}. 
%However, {\em AtSync()} is not a blocking call, 
%load balancing does not force the application to block until it  
%finishes. When load balancing finishes, load balancer notifies every array
%element by calling {\em ResumeFromSync()}
%\footnote{{\em ResumeFromSync()} is a virtual function of array element
%base class which can be redefined in application.}. In many applications,
%it is often desirable that application waits for load balancing complete since
%there may be migration occurs when load balancing and application may want to
%respond to the migration. Thus, one of the commonly applied strategy is 
%that array elements stop sending message after {\em AtSync()} is called, 
%and resume work after load balancer calls back {\em ResumeFromSync()}.

In the above two load balancing modes, users don't need 
to worry about how to start load balancing. 
However, in one scenario, the above automatic load balancers will fail to
work - array elements are created by dynamic insertion.
This is because the above two load balancing modes require an application
to have fixed number of objects at the time of load balancing.
The array manager needs to maintain a head count of local array elements
for the local barrier.
In this case, users have to use the {\em manual mode} to trigger 
load balancer themselves. The API is described below.

%A few notes about {\em ResumeFromSync()}\footnote{It used to 
%only work in automatic with sync mode.}. It can be used in all above three
%load balancing modes. For an array element(whether it is migrated or not), 
%it is more like getting a notification from load
%balancer about the completeness of load balancing phase.
%Users can choose to handle it by writing their own
%code for {\em ResumeFromSync()}, or just ignore it. The proper use of both 
%{\em AtSync()} and {\em ResumeFromSync()} gives you the effect of 
%load balancing barrier. 

The detailed APIs of these three methods are described as follows:
\begin{enumerate}

\item {\bf periodical load balancing mode}: By default, the array elements 
may be asked to migrate at any time provided that they are not in 
the middle of executing an entry method. 
The array element's variable \kw{usesAtSync} being CmiFalse attributes
to this default behavior. In the default setting, load balancing happens
whenever the array elements are ready with interval of 1 second. It is 
desirable for the application to set a larger interval using +LBPeriod
runtime option. For example "+LBPeriod 5" to start load balancing roughly
every 5 seconds.

\item {\bf automatic with Sync}: Using the AtSync method, elements can 
only be migrated at certain points in the execution when user calls 
\kw{AtSync()}. 
For the AtSync method, set \kw{usesAtSync} to CmiTrue in your 
array element constructor.  When an element is ready to migrate,
call \kw{AtSync()}~\footnote{AtSync() is a member function of class ArrayElement}.  
When all local elements call \kw{AtSync}, the load balancer is triggered.  
Once all migrations are completed, the load balancer calls the 
virtual function \kw{ArrayElement::ResumeFromSync()} on each of the
array element.  

Note that {\em AtSync()} is not a blocking call, it just give a hint to load
balancing that it is time for load balancing. During the time between 
{\em AtSync} and {\em ResumeFromSync}, the object may be migrated. 
One can choose to let objects continue working with incoming messages,
however keep in mind the object may suddenly show up in another processor
and make sure no operations that could possibly prevent migration 
be performed. The most commonly used approach is to force the object to 
be idle until load balancing finishes, the object can start working again
when \kw{ResumeFromSync()} is called.

\item {\bf manual mode}: The load balancer can be programmed to be started
manually. To switch to the manual mode, you should call
{\em TurnManualLBOn()} on every processor to prevent load balancer from 
starting automatically. {\em TurnManualLBOn()} should be called as 
early as possible in the program. It could be called at the initialization 
part of the program, 
for example from a global variable constructor, or in an initcall~\ref{initcall}.
It can also be called in the constructor of a static array and
definitely before the {\em doneInserting} call for a dynamic array.  
It can be called multiple times on one 
processor, but only the last one takes effect.

The function call {\em StartLB()} starts load balancing immediately. 
This call should be made at only one place on only one processor.
This function is also not blocking, the object will continue to process
messages and the load balancing when triggered
happens at the background.

{\em TurnManualLBOff()} turns off manual load balancing and 
switches back to the automatic Load balancing mode.

\end{enumerate}

\subsubsection{Migrating objects}
\label{lbmigobj}

Load balancers migrate objects automatically.
For an array element to migrate, user can refer to section~\ref{arraymigratable}
for how to write a ``pup'' for an array element.

In general one needs to pack the whole snapshot of the member data in an 
array element in the pup subroutine. This is because the migration of
the object may happen at any time. In certain load balancing scheme where
user explicitly control when the load balancing happens, user may choose
to pack only a part of the data and may skip those temporary data.

\subsubsection{Other utility functions}

There are several utility functions that can be called in applications to
configure the load balancer, etc. These functions are:

\begin{itemize}
\item {\bf LBTurnInstrumentOn()} and {\bf LBTurnInstrumentOff()}: are plain C
      functions to control the load balancing statistics instrumentation
      on or off on the calling processor. No implicit broadcast or 
      synchronization exists in these functions.
\item {\bf setMigratable(CmiBool migratable)}: is a member function of array
      element. This function can be called 
      in an array element constructor to tell load balancer whether this object
      is migratable or not\footnote{Currently not all load balancers 
      recognize this setting though.}.
\item {\bf lbdb$->$SetLBPeriod(double s)}: this function can be called
      anywhere\footnote{except that it must be called after LBDatabase
      has been initialized in Charm++ init phase, so for example global 
      variable constructor is not a good place to call it.} to regulate 
      the load balancing period. It tells load balancer not to start next 
      load balancing in less than s seconds. This can be used to prevent 
      load balancing from occurring too often in 
      {\em automatic without sync mode}. Here is how to use it:
      \begin{alltt}
// if used in an array element
LBDatabase *lbdb = getLBDB();
lbdb->SetLBPeriod(5);

// if used outside of an array element
// must be called after load balancer is initialized.
LBDatabase *lbdb = LBDatabase::Object();
lbdb->SetLBPeriod(5);
\end{alltt}
      Alternatively, one can specify +LBPeriod <second> at command line.
\end{itemize}

\subsubsection{Compiler and run-time options to use load balancing module}
\label{lbOption}

Load balancing strategies are implemented as libraries in \charmpp{}. This
allows programmers to easily experiment with different existing strategies 
by simply linking a pool of strategy modules and choose 
one to use at run-time via command line options.

Please note that linking a load balancing module is different from activating it:
\begin{itemize}
\item link a LB module: is to link a Load Balancer module(library) at 
   compile time; You can link against multiple LB libraries as candidates.
\item activate a LB: is to actually ask to create a LB strategy and 
   start it. You can only activate one LB either at compile time or at
   run-time and the LB module must be one of the LB module linked at 
   compile time.
\end{itemize}


Below are the descriptions about the compiler and run-time options:

\begin{enumerate}
\item {\bf compile time options:}

\begin{itemize}
\item {\em -module NeighborLB -module GreedyCommLB ...}  \\
  links module NeighborLB, GreedyCommLB etc into an application, but these 
load balancers will remain inactive at execution time unless overriden by 
other runtime options.
\item {\em -module EveryLB} \\
  links special module EveryLB which includes all the charmpp{} built-in load balancers.
\item {\em -balancer GreedyCommLB} \\
  links load balancer GreedyCommLB and invoke this load balancer at runtime. One can specify multiple load balancers for example: \\
   {\em -balancer GreedyCommLB -balancer RefineLB}   \\
   This will start first load balancing step with GreedyCommLB, and second load balancing step with RefineLB, and same RefineLB in the subsequent load balancing steps.
\item {\em -balancer ComboCentLB:GreedyLB,RefineLB}  \\
   One can choose to create a new combo load balancer made of multiple load balancers. The above example specifes {\em one} load balancer which first applies GreedyLB algorithm followed by RefineLB algorithm.
\end{itemize}

The list of existing load balancers are in section \ref{lbStrategy}.
Note: you can have multiple -module *LB options. LB modules are
linked into a program, but they are not activated automatically at runtime.
Using -balancer at compile time in order to activate load balancers automatically at run time. 
Having -balancer A implies -module A, so you don't have to write -module A again, although it does not hurt.
Using EveryLB is a convenient way to link against all existing load balancers. 
One of the load balancer called MetisLB requires METIS library 
which is located at: charm/src/libs/ck-libs/parmetis/METISLib/. 
You need to compile METIS library by "make METIS" under charm/tmp after you
compile Charm++.

\item {\bf run-time options:}

Run-time options are doing the same thing as compile time options, but they can override the compile time options.

\begin{itemize}
\item {\em +balancer help} \\
  displays all available balancers already linked in.
\item {\em +balancer GreedyCommLB} \\
  activates GreedyCommLB. Multiple load balancers can be activated at the runtime to work in sequence. (same as compile time options described above)
\item {\em +balancer ComboCentLB:GreedyLB,RefineLB}  \\
  same as the example in +balancer compile time option.
\end{itemize}

Note: +balancer option works only if you have already linked the load balancers module at compile time. 
Given +balancer with a wrong LB name will results in runtime error.
When you have used -balancer A as compile time option, you don't need to use 
+balancer A again to activate it at runtime. However, you can 
use +balancer B to override the compile time option and choose to
activate B instead of A.

\item {\bf When there is no load balancer activated}

When you don't activate any of load balancer at compile time or run time, 
and your program counts on a load balancer because you use {\em AtSync()}
and expect {\em ResumeFromSync()} to be called to continue,
be assured that your program still can run. 
What happens is that a special load balancer called {\em NullLB} is 
automatically created in this case which basically does nothing 
but calling {\em ResumeFromSync()} after {\em AtSync()}. 
This is to make sure program does not hang because of {\em AtSync()}.
The {\em NullLB} is smart enough to keep silent if there is any other 
load balancer is created.

\item {\bf Other Useful Run-time options}

There are a few opther run-time options that may be useful:

\begin{itemize}
\item {\em +LBDebug <verbose level>} \\
     ask load balancer to output more information to the stdout at load 
balancing time. The bigger the verbose level, the more verbose the output is.
\item {\em +LBPeriod <seconds>} \\
     <seconds> can be any float number. This sets the minimum period time in 
seconds between two consecutive load balancing steps. The default value is 
1 second. That is to say a second load balancing step won't happen until
after 1 second since the last load balancing step.
\item {\em +LBSameCpus} \\
     this option simply tells load balancer that all processors are of same speed. The load balancer will then skip the measurement of CPU speed at run-time.
\item {\em +LBObjOnly} \\
     this tells load balancer to ignore processor background load when making migration decisions.
\item {\em +LBSyncResume} \\
     after load balancing step, normally a processor can resume computation 
once all objects are received on that processor, even when other processors
are still working on migrations.  If this turns out to be a problem, 
that is when some processors start working on computation while the other 
processors are still working on migration, then use this option to force 
a global barrier on all processors to make sure processors can only resume 
computation after migrations finish on all processors.
\end{itemize}

\end{enumerate}

\subsubsection{Load Balancing Simulation}
The simulation feature of load balancing framework allows the users to collect information
about the compute wall/cpu time and communication of the chares during a particular run of
the program and use this information to later test different load balancing strategies to
see which one is suitable for the programs behaviour. Currently, this feature is supported only for
the centralized load balancing strategies. For this, the load balancing framework
accepts the following command line options:
\begin{enumerate}
\item {\em +LBDump StepStart}\\
        This will dump the instrument/communication data collected by the load balancing framework
	starting from the load balancing step {\em StepStart} into a file on the disk. The name of the file
	is given by the {\em +LBDumpFile} option. The first step in the program is number 0. Negative
	numbers will be converted to 0.
\item {\em +LBDumpSteps StepsNo}\\
        This option specify for how many steps to dump the data to the disk. If omitted, default value is 1.
	The program will exit after StepsNo files are dumped.
\item {\em +LBDumpFile FileName}\\
	This option specified the base name of the file into which to dump the load balancing data. If this
	option is not specified, the framework uses the default file {\tt lbdata.dat}. Since multistep is allowed,
	to this base name it is added the step number in the form {\tt Filename.\#}; this apply to both dump and
	simulation.
\item {\em +LBSim StepStart}\\
	This option instructs the framework to do the simulation during the first load balancing step.
	When this option is specified, the load balancing data from the file specified in the {\em +LBDumpFile}
	option, with the addition of the step number, will be read and this data
	will be used for the load balancing. The program will print the results
	of the balancing for a number of steps given by the {\em +LBSimSteps} option, and then will exit.
\item {\em +LBSimSteps StepsNo}\\
        This options has the same meaning of {\em +LBDumpSteps}, except that apply for the simulation mode.
	Default value is 1.
\item {\em +LBSimProcs}\\
        This option may change the number of processors target of the load balancer strategy. It may be used to test
	the load balancer in conditions where some processor crashes or someone becomes available. If this number is not
	changed since the original run, starting from the second step file the program will print other additional
	information about how the simulated load differ from the real load during the run (considering all
	strategies that were applied while running). This may be used to test the validity of a load balancer
	prediction over the reality. If the strategies used during run and simulation differ, the additional data
	printed may not be useful.
\end{enumerate}
As an example, we can collect the data for a 1000 processor run of a program using:
\begin{alltt}
./charmrun pgm +p 1000 +balancer RandCentLB +LBDump 2 +LBDumpSteps 4 +LBDumpFile dump.dat
\end{alltt}
This will collect data on files data.dat.{2,3,4,5}. Then, we can use this data to observe various centralized strategies using:
\begin{verbatim}
./charmrun pgm +balancer <Strategy to test> +LBSim 2 +LBSimSteps 4 
               +LBDumpFile dump.dat [+LBSimProcs 900]
\end{verbatim}

\subsubsection{Future load predictor}

When objects do not follow the assumption that the future workload will be the
same as the past, the load balancer might not have the correct information to do
a correct rebalancing job. To prevent this the user can provide a transition
function to the load balancer to predict what will be the future workload, given
the past, instrumented one. As said, the user might provide a specific function
which inherit from {\tt LBPredictorFunction} and implement its
functions. Here is the abstract class:
\begin{verbatim}
class LBPredictorFunction {
public:
  int num_params;
 
  virtual void initialize_params(double *x);

  virtual double predict(double x, double *params) =0;
  virtual void print(double *params) {PredictorPrintf("LB: unknown model\n");};
  virtual void function(double x, double *param, double &y, double *dyda) =0;
};
\end{verbatim}
\begin{itemize}
\item {\tt initialize\_params} by default initializes the parameters randomly. If the user
knows how they should be, this function can be reimplemented.
\item {\tt predict} is the function the model implements. For example, if the function is
$y=ax+b$, the method in the implemented class should be like:
\begin{verbatim}
double predict(double x, double *param) {return (param[0]*x + param[1]);}
\end{verbatim}
\item {\tt print} is a debugging function and it can be reimplemented to have a meaningful
print of the learnt model
\item {\tt function} is a function internally needed to learn the parameters, {\tt x} and
{\tt param} are input, {\tt y} and {\tt dyda} are output (the computed function and
all its derivatives with respect to the parameters, respectively).
For the function in the example should look like:
\begin{verbatim}
void function(double x, double *param, double &y, double *dyda) {
  y = predict(x, param);
  dyda[0] = x;
  dyda[1] = 1;
}
\end{verbatim}
\end{itemize}
Other than these function, the user should provide a constructor which must initialize
{\tt num\_params} to the number of parameters the model has to learn. This number is
the dimension of {\tt param} and {\tt dyda} in the previous functions. For the given
example, the constructor is {\tt \{num\_params = 2;\}}.

If the model behind the computation is not known, the user can leave the system to
use a predefined default function.

As seen, the function can have several parameters which will be learned during
the execution of the program. For this, two parameters can be setup at command
line to specify the learning behaviour:
\begin{enumerate}
\item {\em +LBPredictorWindow size}\\
This parameter will specify how many statistics the load balancer will keep for
keeping updated the function parameters. The greater this number is, the best
approximation of the workload will be, but more memory will be required to store
the intermediate information. The default is 20.
\item {\em +LBPredictorDelay steps}\\
This will tell how many load balancer steps to wait before considering the
function parameters learnt and start using the mode. The load balancer will
collect statistics for a {\em +LBPredictorWindow} steps, but it will start using
the model as soon as {\em +LBPredictorDelay} information are collected. The
default is 10.
\end{enumerate}
Moreover another flag can be set to enable the predictor from command line: {\em
+LBPredictor}.\\
Other than the command line options, there are some methods
callable from user program to modify the predictor. These methods are:
\begin{itemize}
\item {\tt void PredictorOn(LBPredictorFunction *model);}
\item {\tt void PredictorOn(LBPredictorFunction *model,int wind);}
\item {\tt void PredictorOff();}
\item {\tt void ChangePredictor(LBPredictorFunction *model);}
\end{itemize}


\subsubsection{Seed load balancers - load balancing Chares at creation time}
\label{seedlb}

Seed load balancing involves the movement of object creation messages, or
"seeds", to create a balance of work across a set of processors. This load
balancing scheme is used for load balancing chares only at creation time. When
the chare is created on a processor, there is no movement of the chare due to
the seed load balancer. The measurement based load balancer described in
previous subsection perform the task of moving chares during work to achieve
load balance.

Several variations of strategies have been designed and analyzed. 
\begin{enumerate}
\item {\em random}\\  
 A strategy that places seeds randomly when they are created and does
no movement of seeds thereafter. This is used as the default seed 
load balancer.
\item {\em neighbor}\\  
 a strategy which imposes a virtual topology on the processors,
 load exchange happens to neighbors only. The overloaded processors
 initiate the load balancing, where a processor send work to its neighbors
 when it becomes overloaded. The default topology is mesh2D, one can use
 command line option to choose other topology such as ring, mesh3D and 
 dense graph.
\item {\em spray}\\  
 a strategy which imposes a spanning tree organization on the processors,
 results in communication via global reduction amongst all processors 
 to compute global average load via periodic reduction. 
 It uses averaging of loads to determine how seeds should be
distributed.
\end{enumerate}

Other strategies can also be explored follow the simple API of the 
seed load balancer.
\linebreak

{\bf Seed load balancers for Chares:}

Seed load balancers can be directly used for load balancing Chares.
The default seed load balancer that is always linked without overridden 
is the random seed load balancer.
User can picks one of the other strategies listed above and link as a plugin
module into binary as described below to override the default strategy.

{\bf Seed load balancers for Array Elements:}

Seed load balancers can also be used for array elements in the same way 
as they are used for individual chares.
Chare array is a collection of individule Chares in Charm++.
Since Chare Array has its internal strategy of static mapping of individule
array elements to processors using {\em CkArrayMap}~\ref{array map}~\footnote{by default it always distributed array elements to procesors in Round-Robin fashion unless a different CkArrayMap is used}, 
a special CkArrayMap called {\em CldMap} must be created and passed into
array creation calls to interface with seed load balancer.

For creating an empty array and then inserting chares into it, the API is as follows:

\begin{alltt}
  CkArrayOptions opt;
  CkGroupID cldmapID = CProxy_CldMap::ckNew();
  opt.setMap(cldmapID);
  CProxy_WorkUnit arr = CProxy_WorkUnit::ckNew(param, opt); 
  for (int i=0; i<numChares; i++) 
    arr[i].insert(param);
\end{alltt}

For initially populating the array with chares at time of creation the API is as follows:
\begin{alltt}
  CkArrayOptions opt(numChares);
  CkGroupID cldmapID = CProxy_CldMap::ckNew();
  opt.setMap(cldmapID);
  CProxy_WorkUnit arr = CProxy_WorkUnit::ckNew(param, opt); 
\end{alltt}

The details about array creation are explained in section~\ref{advanced arrays} of the manual.

{\bf Compile and run time options for seed load balancers}

To choose a seed load balancer other than the default {\em rand} strategy,
use link time command line option {\bf -balance foo}. 

When using {\rm neighbor} seed load balancer, one can also specify
the virtual topology at runtime. Use {\bf +LBTopo topo}, where {\em topo}
can be one of: (a) ring, (b) mesh2d, (c) mesh3d and (d) graph.

To write a seed load balancer, name your file as {\em cldb.foo.c},
where {\em foo} is the strategy name.  Compile it in the form of library
under charm/lib, named as {\em libcldb-foo.a}, where {\em foo} is the strategy 
name used above. Now one can use {\bf -balance foo} as compile time option
to {\bf charmc} to link with the {\em foo} seed load balancer.
