\chapter{Futures}

This library supports the {\em future} abstraction, defined and used by
Halstead and other researchers. The library itself provides only
local (sequential) functions. If necessary, the user (or a language
implementor who wishes to use futures) can send converse messages
across processors, and have their handlers set the future's values.

\verb#futuresInitialize()#

This function initializes the futures module. It can deal with
repeated (redundant) initializations, without losing information
entered after the previous initialization. Currently, 100 distinct
future values may be alive at any moment on each processor. This
number will be made a parameter to the futuresInitialize function in
future versions.

{\large \bf createFuture}

\verb#int createFuture()#

Returns an integer key designating the future-value-holder just
created.


{\large \bf setFuture}

\verb#setFuture(int key, void*pointer)#

Sets the value of the future indicate by the key to the given pointer.
All the threads waiting for the future specified by the key are
awakened. (Each such thread, when it resumes, will return from the
waitFuture function with the \verb#pointer# as its return value.)

{\large \bf sendToFuture}

\verb#sendToFuture(void *m, int key)#

Makes an entry in the scheduler's queue that will (when scheduled) set
the future value, and awaken the waiting threads. This is an
asynchronous version of \verb#setFuture#. 


{\large \bf  waitFuture}

\verb#void* waitFuture (int key, int free)#

The caller for this function must be a thread. If the future value is
ready (i.e. set by \verb#setFuture# or \verb#sendToFuture#), the
function returns immediately with a pointer to the value. Otherwise,
the calling thread suspends, and the call returns after another thread
has set the future value. This call can be made before or after the future
is set.

destroyFuture(int key)

Allows  the key to be used for other futures.

{\large \bf Bugs:} Currently, the number of futures is limited to 100.
Although you can reuse a key with destroyFuture, this limits the
number of futures alive at a time to 100. With a hash table
implementation this could be completely eliminated in a future
release, or at least an ability to change the number of available keys
at the initialization time will be added.

