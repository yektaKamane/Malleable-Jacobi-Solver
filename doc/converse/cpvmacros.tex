%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RCS INFORMATION:
%
%       $RCSfile$
%       $Author$        $Locker$                $State$
%       $Revision$      $Date$
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DESCRIPTION:
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% REVISION HISTORY:
%
% $Log$
% Revision 1.6  1997-06-25 06:53:48  jyelon
% Just trying to make this whole manual make more sense.
%
% Revision 1.5  1995/11/16 22:11:11  milind
% removed hardwired reference.
%
% Revision 1.4  1995/11/01  21:16:23  milind
% Added index entries.
%
% Revision 1.3  1995/10/30  17:33:54  milind
% Changed Cth variables macros to Ctv macros.
% Added "More on Shared Memory Machines" section.
%
% Revision 1.2  1995/10/27  21:02:54  milind
% Integrated into Manual.
%
% Revision 1.1  1995/10/26  21:08:23  gursoy
% Initial revision
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Machine Model and Global Variables}

The machine model assumed by Converse consists of a collection of
nodes, where each node comprises of a number of processors that
share memory. In addition, each of the processors could have multiple
threads running on them which share code and data but have different
stacks. On networks of workstations or distributed memory MIMD
machines, number of processors in each node is assumed to be one and on
machines that do not have native thread support, there is only one
thread per processor. Converse provides functions to determine rank of
a processor within a node and a consistent access/modification
mechanism to manipulate global variables.

\section{Global Variables}

Global variables are allowed in Converse via specific macros.  These macros 
ensure that the program runs portably on various parallel machines. 
Three classes of global variables are supported: node-private,
process-private, and thread-private variables. 

\begin{description}
\item[Node-private global variables] are specific to a node. They are
     shared among all the processes within the node.
\item[Process-private global variables]  are specific to a process. They are
     shared among all the threads within the process.
\item[Thread-private global variables] are specific to a thread. They are 
     truely private.
\end{description}

There are five macros for each class. These macros are for
declaration, static declaration, extern declaration, initialization, and
access. The declaration, static and extern specifications have the same
meaning as in C. In order to support portability, however, the global
variables must be installed properly, by using the initialization macros.
For example, if the underlying machine is a simulator for the machine model 
supported by Converse, then the thread-private variables must be turned into 
arrays of variables.  Initialize and Access macros hide these details from 
the user.  It is possible to use global variables without these macros, 
as supported by the underlying machine, but at the expense of portability.


Macros for node-private variables:
\begin{verbatim}
CsvDeclare(type,variable)
CsvStaticDeclare(type,variable)
CsvExtern(type,variable)
CsvInitialize(type,variable)
CsvAccess(variable)
\end{verbatim}

\index{CsvDeclare}
\index{CsvStaticDeclare}
\index{CsvExtern}
\index{CsvInitialize}
\index{CsvAccess}

Macros for process-private variables:
\begin{verbatim}
CpvDeclare(type,variable)
CpvStaticDeclare(type,variable)
CpvExtern(type,variable)
CpvInitialize(type,variable)
CpvAccess(variable)
\end{verbatim}
\index{CpvDeclare}
\index{CpvStaticDeclare}
\index{CpvExtern}
\index{CpvInitialize}
\index{CpvAccess}

Macros for thread-private variables:
\begin{verbatim}
CtvDeclare(type,variable)
CtvStaticDeclare(type,variable)
CtvExtern(type,variable)
CtvInitialize(type,variable)
CtvAccess(variable)
\end{verbatim}
\index{CtvDeclare}
\index{CtvStaticDeclare}
\index{CtvExtern}
\index{CtvInitialize}
\index{CtvAccess}


    A sample code to illustrate the usage of the macros is provided
    in Figure~\ref{fig:cpv}.
    There are a few rules that user must pay attention: The
    {\tt type} and {\tt variable} fields of the macros must be a single
    word. Therefore, structures or pointer types can be used by defining
    new types with the {\tt typedef}. In the sample code, for example,
    a {\tt struct point} type is redefined with a {\tt typedef} as {\tt Point}
    in order to use it in the macros. Similarly,  the access macros contain
    only the name of the global variable. Any indexing or member access
    must be outside of the macro as shown in the sample code 
    (function {\tt func1}). Finally, all the global variables must be
    installed before they are used. One way to do this systematically is
    to provide a module-init function for each file (in the sample code - 
    {\tt ModuleInit()}. The module-init functions of each file, then, can be 
    called at the beginning of execution to complete the installations of 
    all global variables.
    
\begin{figure}
\begin{verbatim}
File Module1.c

    typedef struct point
    {
         float x,y;
    } Point;


    CpvDeclare(int, a);
    CpvDeclare(Point, p);

    void ModuleInit()
    {
         CpvInitialize(int, a)
         CpvInitialize(Point, p);

         CpvAccess(a) = 0;
    }

    int func1() 
    {
         CpvAccess(p).x = 0;
         CpvAccess(p).y = CpvAccess(p).x + 1;
    }
\end{verbatim}
\caption{An example code for global variable usage}
\label{fig:cpv}
\end{figure}

\section{Utility Functions}
\label{utility}

To further simplify programming with global variables on shared memory machines,
Converse provides following functions and/or macros. \note{These functions
are defined on machines other than shared-memory machines also, and
have the effect of only one processor per node and only one thread per 
processor.}

\function{int CmiMyRank()}
\index{CmiMyRank}
\desc{Returns the rank of the calling processor within a shared memory node.}

\function{void CmiNodeBarrier()}
\index{CmiNodeBarrier}
\desc{Provide barrier synchronization at the node level, i.e. all the 
processors belonging to the node participate in this barrier.}

\function{void *CmiSvAlloc(int size)}
\index{CmiSvAlloc}
\desc{Allocates a block of memory of \param{size} bytes from the heap in node's 
local memory and returns pointer to the start of this block. \note{On 
machines other than shared-memory machines, this is equivalent to 
\param{CmiAlloc}.}}
