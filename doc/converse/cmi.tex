\chapter{Machine Interface and Scheduler}

This chapter describes two of Converse's modules: the CMI, and the
CSD.  Together, they serve to transmit messages and schedule the
delivery of messages.

\section{Defining Handler Numbers}

When a message arrives at a processor, it triggers the execution of a
{\em handler function}, not unlike a UNIX signal handler.  The handler
function receives, as an argument, a pointer to a copy of the message.
The message itself specifies which handler function is to be
called when the message arrives.  Messages are contiguous sequences of
bytes.  The message has two parts: the header, and the data.  The data
may contain anything you like.  The header contains a {\em handler
number}, which specifies which handler function is to be executed when
the message arrives.  Before you can send a message, you have to
define the handler numbers.

Converse maintains a table mapping handler numbers to function
pointers.  Each processor has its own copy of the mapping.  There is a
caution associated with this approach: it is the user's responsibility
to ensure that all processors have identical mappings.  This is easy
to do, nonetheless, the user must be aware that this is (usually)
required.

The following functions are provided to define the handler numbers:

\function{typedef void (*CmiHandler)(void *)}
\index{CmiHandler}
\desc{Functions that handle Converse messages must be of this type.}

\function{int CmiRegisterHandler(CmiHandler h)}
\index{CmiRegisterHandler}
\desc{This represents the standard technique for associating numbers
with functions.  To use this technique, the Converse user registers
each of his functions, one by one, using CmiRegisterHandler.  One must
register exactly the same functions in exactly the same order on all
processors.  The system assigns monotonically increasing numbers to
the functions, the same numbers on all processors.  This insures
global consistency.  CmiRegisterHandler returns the number which was
chosen for the function being registered.}

\function {int CmiRegisterHandlerGlobal(CmiHandler h)}
\index{CmiRegisterHandlerLocal}
\desc{This represents a second registration technique.   The Converse
user registers his functions on processor zero, using
CmiRegisterHandlerGlobal.  The Converse user is then responsible for
broadcasting those handler numbers to other processors, and installing
them using CmiNumberHandler below.  The user should take care not to
invoke those handlers until they are fully installed.}

\function {int CmiRegisterHandlerLocal(CmiHandler h)}
\index{CmiRegisterHandlerLocal}
\desc{This function is used when one wishes to register functions
in a manner that is not consistent across processors.  This function
chooses a locally-meaningful number for the function, and records it
locally.  No attempt is made to ensure consistency across processors.}

\function {void CmiNumberHandler(int n, CmiHandler h)}
\index{CmiNumberHandler}
\desc{Forces the system to associate the specified handler number {\em n}
with the specified handler function {\em h}.  If the function number
{\em n} was previously mapped to some other function, that old mapping
is forgotten.  The mapping that this function creates is local to the
current processor.  CmiNumberHandler can be useful in combination with
CmiRegisterGlobalHandler.  It can also be used to implement
user-defined numbering schemes: such schemes should keep in mind that
the size of the table that holds the mapping is proportional to the
largest handler number --- do not use big numbers!}

Note: of the three registration methods, the CmiRegisterHandler method
is by far the simplest, and is strongly encouraged.  The others are
primarily to ease the porting of systems that already use similar
registration techniques.  One may use all three registration methods
in a program.  The system guarantees that no numbering conflicts will
occur as a result of this combination.

\section{Building Messages}

To send a message, one first creates a buffer to hold the message.
The buffer must be large enough to hold the header and the data.
The buffer can be in any kind of memory: it could be a local variable,
it could be a global, it could be allocated with {\tt malloc}, and
finally, it could be allocated with {\tt CmiAlloc}.  The Converse user
fills the buffer with the message data.  One puts a handler number
in the message, thereby specifying which handler function the message
should trigger when it arrives.  Finally, one uses a message-transmission
function to send the message.

The following functions are provided to help build message buffers:

\function{void *CmiAlloc(int size)}
\index{CmiAlloc}
\desc{Allocates memory of size \param{size} in heap and returns pointer to 
the usable space.  There are some message-sending functions that
accept only message buffers that were allocated with CmiAlloc.  Thus,
this is the preferred way to allocate message buffers.}

\function{void CmiFree(void *ptr)}
\index{CmiFree}
\desc{This function frees the memory pointed to by \param{ptr}. \param{ptr}
should be a pointer that was previously returned by \param{CmiAlloc}.}

\function {\#define CmiMsgHeaderSizeBytes}
\index{CmiMsgHeaderSizeBytes}
\desc{This constant contains the size of the message header.  When one
allocates a message buffer, one must set aside enough space for the header
and the data.  This macro helps you to do so.}

\function {void CmiSetHandler(int *MessageBuffer, int HandlerId)}
\index{CmiSetHandler}
\desc{This macro sets the handler number of a message to \param{HandlerId}.}

\function {int CmiGetHandler(int *MessageBuffer)}
\index{CmiGetHandler}
\desc{This call returns the handler of a message in the form of a
handler number.}
 
\function {CmiHandler CmiGetHandlerFunction(int *MessageBuffer)}
\index{CmiGetHandlerFunction}
\desc{This call returns the handler of a message in the form of a
function pointer.}

\function{void CmiGrabBuffer(void **pbuf)}
\index{CmiGrabBuffer}
\desc{A handler function receives a pointer to a message buffer
as an argument.  Normally, it is supposed to copy the data out of the
message buffer, and then return, at which time Converse automatically
frees the message buffer.  However, a handler function may use
CmiGrabBuffer to claim ownership of the message buffer (and therefore
prevent Converse from freeing it).  Assuming, for example, that the
handler function called its argument {\tt msg}, it would call {\tt
CmiGrabBuffer(\&msg)}.  Afterward, {\tt msg} contains a pointer to the
message, or a copy of it.  From that point forward, it is the user's
responsibility to free the message using \param{CmiFree.}}

\section{Sending Messages}

The following functions allow you to send messages:

\function{void CmiSyncSend(unsigned int destPE, unsigned int size, void *msg)}
\index{CmiSyncSend}

\desc{Sends \param{msg} of size \param{size} bytes to processor
\param{destPE}.  The call does not return until the data has been
copied from the user-provided message buffer into system buffers.
Therefore, once this call returns, you are free to reuse the
message buffer immediately.}

\function{void CmiSyncSendAndFree(unsigned int destPE, unsigned int size, void *msg)}
\index{CmiSyncSendAndFree}
\desc{Sends \param{msg} of size \param{size} bytes to processor
\param{destPE} and then {\tt CmiFree}s the message buffer \param{msg}.
Caution: the message buffer {\em must} have been allocated using {\tt
CmiAlloc}.}

\function{CmiCommHandle CmiAsyncSend(unsigned int destPE, unsigned int size, void *msg)}
\index{CmiAsyncSend}
\desc{Sends a message of size \param{size} bytes to processor
\param{destPE}.  This function returns before the data has even been
copied out of the user's message buffer.  Therefore, the Converse
user must leave the message buffer alone for a time after calling
this function.  This function returns a communication handle which
can be tested to determine whether or not the buffer can be reused
yet.}

\function{int CmiAsyncMsgSent(CmiCommHandle handle)}
\index{CmiAsyncMsgSent}
\desc{Returns true if the communication specified by the given
CmiCommHandle has proceeded to the point where the message buffer can
be reused.}

\function{void CmiReleaseCommHandle(CmiCommHandle handle)}
\index{CmiReleaseCommHandle}
\desc{Releases the communication handle \param{handle} and
associated resources. It does not free the message buffer.}

\function{void CmiSyncVectorSend(int destPE, int len, int sizes[], char *msgComps[])}
\desc{Synchronous send of data to processor
\param{destPE}.  The data consists of \param{len} pieces residing in
different areas of memory, which are logically concatenated.  The
\param{msgComps} array contains pointers to the pieces; the size of
\param{msgComps[i]} is taken from \param{sizes[i]}. 
\param{sizes}, \param{msgComps} and the message components specified in
\param{msgComps} could be reused after the function call returns.
}

\function{void CmiSyncVectorSendAndFree(int destPE, int len, int sizes[], char *msgComps[])}
\desc{Synchronous send of data to processor
\param{destPE}.  The data consists of \param{len} pieces residing in
different areas of memory, which are logically concatenated.  The
\param{msgComps} array contains pointers to the pieces; the size of
\param{msgComps[i]} is taken from \param{sizes[i]}. 
The message components specified in \param{msgComps} are {\tt
CmiFree}d by this function therefore, they should be dynamically
allocated using \param{CmiAlloc()}.  However, the \param{sizes} and
\param{msgComps} array themselves are not freed.}

\function{CmiCommHandle CmiAsyncVectorSend(int destPE, int len, int sizes[], char *msgComps[])}
\desc{Initiates an asynchronous send of data to processor
\param{destPE}.  The data consists of \param{len} pieces residing in
different areas of memory, which are logically concatenated.  The
\param{msgComps} array contains pointers to the pieces; the size of
\param{msgComps[i]} is taken from \param{sizes[i]}. 
This function returns a communication handle which could be used to enquire
about the status of communication using \param{CmiAsyncMsgSent()}.
Individual pieces of data as well as the arrays \param{sizes} and
\param{msgComps} should not be overwritten or freed before the
communication is complete.}

\section{Broadcasting Messages}

\function{void CmiSyncBroadcast(unsigned int size, void *msg)}
\index{CmiSyncBroadcast}
\desc{Sends \param{msg} of length \param{size} bytes to all processors
excluding the processor on which the caller resides. }

\function{void CmiSyncBroadcastAndFree(unsigned int size, void *msg)}
\index{CmiSyncBroadcastAndFree}
\desc{Sends \param{msg} of length \param{size} bytes to all processors
excluding the processor on which the caller resides.  Uses {\tt
CmiFree} to deallocate the message buffer for \param{msg} when the
broadcast completes. Therefore \param{msg} must point to a buffer
allocated with {\tt CmiAlloc}.}

\function{void CmiSyncBroadcastAll(unsigned int size, void *msg)}
\index{CmiSyncBroadcastAll}
\desc{Sends \param{msg} of length \param{size} bytes to all processors
including the processor on which the caller resides. This function
does not free the message buffer for \param{msg}.}

\function{void CmiSyncBroadcastAllAndFree(unsigned int size, void *msg)}
\index{CmiSyncBroadcastAllAndFree}
\desc{Sends \param{msg} of length \param{size} bytes to all processors
including the processor on which the caller resides. This function
frees the message buffer for \param{msg} before returning, so
\param{msg} must point to a dynamically allocated buffer.}

\function{CmiCommHandle CmiAsyncBroadcast(unsigned int size, void *msg)}
\index{CmiAsyncBroadcast}
\desc{Initiates asynchronous broadcast of message \param{msg} of
length \param{size} bytes to all processors excluding the processor on
which the caller resides. It returns a communication handle which
could be used to check the status of this send using
\param{CmiAsyncMsgSent()}. \param{msg} should not be overwritten or
freed before the communication is complete.}

\function{CmiCommHandle CmiAsyncBroadcastAll(unsigned int size, void *msg)}
\index{CmiAsyncBroadcastAll}
\desc{Initiates asynchronous broadcast of message \param{msg} of
length \param{size} bytes to all processors including the processor on
which the caller resides. It returns a communication handle which
could be used to check the status of this send using
\param{CmiAsyncMsgSent()}. \param{msg} should not be overwritten or
freed before the communication is complete.}

\section{Scheduling Messages}

The scheduler queue is a powerful priority queue.  The following
functions can be used to place messages into the scheduler queue.
These messages are treated very much like newly-arrived messages: when
they reach the front of the queue, they trigger handler functions,
just like messages transmitted with Cmi functions.  Note that unlike
the Cmi send functions, these cannot move messages across processors.

\function{void CsdEnqueueGeneral(void *Message, int strategy, int priobits, int *prioptr)}
\index{CsdEnqueueGeneral}
\desc{This call enqueues a message to the scheduler's queue, to be processed in 
accordance with the queueing \param{strategy}. \param{priobits} and
\param{prioptr} specify information about priority associated with the message
if prioritized queueing strategies are used. \param{strategy} can take values 
defined in {\tt converse.h} depending upon the queueing strategy (FIFO or LIFO)
and the nature of priority information used (none, integer or bit-vector).
These predefined constants are: 
{\tt CQS\_QUEUEING\_FIFO}, {\tt CQS\_QUEUEING\_LIFO},
{\tt CQS\_QUEUEING\_IFIFO}, {\tt CQS\_QUEUEING\_ILIFO},
{\tt CQS\_QUEUEING\_BFIFO}, and\\  {\tt CQS\_QUEUEING\_BLIFO}.
This call is usually made from
a message handler when the message is not to be processed immediately,
but may be processed later (e.g. depending on the message's priority).
Also, it is used to enqueue local ready entities, such as threads.
\note{It is necessary to grab the ownership of the message buffer before queuing
because on returning from the handler, the system can reuse the buffer.}}

\function {void CsdEnqueue(void *Message)}
\index{CsdEnqueue}
\desc{This macro is a shorthand for 
{\tt CsdEnqueueGeneral(Message, CQS\_QUEUEING\_FIFO,0, NULL)} 
provided here for backward compatibility.}

\function{void CsdEnqueueFifo(void *Message)}
\index{CsdEnqueueFifo}
\desc{This macro is a shorthand for 
{\tt CsdEnqueueGeneral(Message, CQS\_QUEUEING\_FIFO,0, NULL)} 
provided here for backward compatibility.}


\function{void CsdEnqueueLifo(void *Message)}
\index{CsdEnqueueLifo}
\desc{This macro is a shorthand for
{\tt CsdEnqueueGeneral(Message, CQS\_QUEUEING\_LIFO,0, NULL)} 
provided here for backward compatibility.}

\function{int CsdEmpty()}
\index{CsdEmpty}
\desc{This function returns non-zero integer when the scheduler's queue
is empty, zero otherwise.}

\section{Polling for Messages}

As we stated earlier, Converse messages trigger handler functions when
they arrive.  In fact, for this to work, the processor must
occasionally poll for messages.  When the user starts Converse, he can
put it into one of several modes.  In the normal mode, the message
polling happens automatically.  However {\em user-calls-scheduler}
mode is designed to let the user poll manually.  To do this, the user
must use one of two polling functions: CmiDeliverMsgs, or
CsdScheduler.  CsdScheduler is more general, it will notice any
Converse event.  CmiDeliverMsgs is a lower-level function that ignores
all events except for recently-arrived messages.  (In particular, it
ignores messages in the scheduler queue).  You can save a tiny amount
of overhead by using the lower-level function.  We recommend the use
of CsdScheduler for all applications except those that are using only
the lowest level of Converse, the Cmi.  A third polling function,
CmiDeliverSpecificMsg, is used when you know the exact event you want
to wait for: it does not allow any other event to occur.

\function {void CsdScheduler(int NumberOfMessages)}
\index{CsdScheduler}
\desc{This call invokes the Converse scheduler, which repeatedly
delivers messages to their handlers (i.e. invokes the handler for each
message it selects).  Each message header encodes a pointer to its
handler as described in the next chapter. 
In each iteration, the scheduler first looks for any
message that  has arrived from another processor, and delivers it.
If there isn't any, it selects a message from the locally enqueued
messages (see below), and delivers it.
The {\tt NumberOfMessages}
parameter specifies how many messages should be processed (i.e. delivered
to their handlers). If set to -1, the scheduler continues delivering
messages until CsdExitScheduler() is called from a message handler.
if {\tt NumberOfMessages} is 0, the scheduler continues delivering messages
until it exhausts its supply of messages (i.e. becomes idle) or some 
handler calls CsdExitScheduler().}

\function{int CmiDeliverMsgs(int MaxMsgs)}
\index{CmiDeliverMsgs}
\desc{Retrieves messages from the network message queue and invokes 
corresponding handler functions for arrived messages. This function 
returns after either the network message queue becomes empty or after
\param{MaxMsgs} messages have been retrieved and their handlers called. 
It returns the difference between total messages delivered and \param{MaxMsgs}.
The handler is given a pointer to the message as  its parameter.
Normally, the delivered message is owned by CMI,  and so the handler
should not free it, or store it for later use.  
If the handler wishes to  use the message later (for example, by
enqueueing the message with the scheduler), it must call
\param{CmiGrabBuffer()} to
acquire the  ownership of the message buffer.}

\function{void CmiDeliverSpecificMsg(int HandlerId)}
\index{CmiDeliverSpecificMsg}
\desc{Retrieves messages from the network queue and delivers the first message
with its handler field equal to \param{HandlerId}. This functions queues
the remaining messages retrieved from the network. It returns after the 
invoked handler function returns.}

\function {void CsdExitScheduler(void)}
\index{CsdExitScheduler}
\desc{This call causes the scheduler
to stop processing messages when control has returned back to it.
The scheduler then returns to its calling routine.}

\internal{
\section{Global Pointer}

\function{int CmiGptrCreate(GlobalPtr *gptr, void *lptr, unsigned int size)}
\desc{This function creates a global pointer by initializing contents of
\param{*gptr} to point to memory on the local processor pointed to by
\param{lptr} of \param{size} bytes. \param{*gptr} could then be sent to other 
processors, and could be used by \param{CmiGet()} and \param{CmiPut()}
to read and write this memory by remote processors. This functions returns
a positive integer on success.}

\function{void *CmiGptrDref(GlobalPtr *gptr)}
\desc{This function returns the address of local memory associated
with global pointer \param{gptr}.}

\function{int CmiSyncGet(GlobalPtr *gptr, void *lptr, unsigned int size)}
\desc{Copies \param{size} bytes from 
memory pointed to by global pointer \param{gptr}
to local memory pointed to by \param{lptr}. 
This is a synchronous operation and the calling processor blocks until
the data is transferred to local memory. This function returns
a positive integer on success.}

\function{CommHandle CmiGet(GlobalPtr *gptr, void *lptr, unsigned int size)}
\desc{Initiates copying of \param{size} bytes from 
memory pointed to by global pointer \param{gptr}
to local memory pointed to by \param{lptr}. 
This function returns a  communication handle which could be used
to  enquire about the status of this operation.}

\function{CommHandle CmiPut(GlobalPtr *gptr, void *lptr, unsigned int size)}
\desc{Initiates copying of \param{size} bytes from a processor's local
memory pointed to by \param{lptr} to the memory pointed to by global
pointer \param{gptr}.  This function returns a  communication handle
which could be used to  enquire about the status of this operation.}
}

\section{The Timer}

\function{double CmiTimer(void)}
\index{CmiTimer}
\desc{Returns current value of the timer in seconds. This is
typically the time spent since the \param{ConverseInit()} call.
The precision of this timer is the best available on the particular machine,
and usually has at least microsecond accuracy.}

\section{Processor Ids}

\function{int CmiNumPe(void)}
\index{CmiNumPe}
\desc{Returns total number of processors in the machine on which the 
parallel program is being run.}

\function{int CmiMyPe(void)}
\index{CmiMyPe}
\desc{Returns the logical processor identifier of processor on which the 
caller resides. A processor Id is between \param{0} and \param{CmiNumPe()-1}.}

Also see the calls in Section~\ref{utility}.  % put a ref here..??

\section{Input/Output}

\function{void CmiPrintf(char *format, arg1, arg2, ...)}
\index{CmiPrintf}
\desc{This function does an atomic \param{printf()} on \param{stdout}. 
On machine with host, this is implemented on top of the messaging 
layer using asynchronous sends.}

\function{int CmiScanf(char *format, void *arg1, void *arg2, ...)}
\index{CmiScanf}
\desc{This function performs an atomic \param{scanf} from \param{stdin}.
The processor, on which the caller resides, blocks for input. On machines with
host, this is implemented on top of the messaging layer using asynchronous
send and blocking receive.}

\function{void CmiError(char *format, arg1, arg2, ...)}
\index{CmiError}
\desc{This function does an atomic \param{printf()} on \param{stderr}. 
On machines with host, this is implemented on top of the messaging 
layer using asynchronous sends.}

\internal{
\section{Processor Groups}

\function{void CmiPgrpCreate(Pgrp *group)}
\desc{Creates a processor-group with calling processsor as the root processor.}

\function{void CmiPgrpDestroy(Pgrp *group)}
\desc{Frees resources associated with a processor group \param{group}.}

\function{void CmiAddChildren(Pgrp *group, int penum, int size, int procs[])}
\desc{Adds \param{size} processors from array \param{procs[]} to the
processor-group \param{group} as children of processor penum. This function
could be called only by the root processor of processor-group \param{group}.}

\function{CommHandle CmiAsyncMulticast(Pgrp *group, unsigned int size, void *msg)}
\desc{Initiates asynchronous broadcast of message \param{msg} of
length \param{size} bytes to all processors belonging to \param{group}
excluding the processor on which the caller resides. It returns a
communication handle which could be used to check the status of this
send using \param{CmiAsyncMsgSent()}. \param{msg} should not be
overwritten or freed before the communication is complete. \note{Caller
need not belong to \param{group}.}} 

\function{int CmiPgrpRoot(Pgrp *group)}
\desc{Returns the processor id of root of processor-group \param{group}. }

\function{int CmiNumChildren(Pgrp *group, int penum)}
\desc{Returns  number of children of processor \param{penum} 
in the processor-group \param{group}.}

\function{int CmiParent(Pgrp *group, int penum)}
\desc{Returns  processor id of parent of processor \param{penum} 
in the processor-group \param{group}.}

\function{void CmiChildren(Pgrp *group, int node, int *children)}
\desc{Fills in array \param{children} with processor ids of all the
children processor \param{node} in processor-group \param{group}. This
array should at least be of size \param{CmiNumChildren()}.}
}

\section{Spanning Tree Calls}

Converse defines a spanning tree organization of the processor procNums along
with routines for accessing elements of that tree.  The spanning tree
routines come in handy when writing programs with collective communication
because message communication patterns can be made to proceed along the
spanning tree arcs to avoid bottlenecks at a single procNum.

\function{int CmiSpanTreeRoot()}
\index{CmiSpanTreeRoot}
\desc{Returns the processor number of the root of the spanning tree.}

\function{int CmiSpanTreeParent(int procNum)}
\index{CmiSpanTreeParent}
\desc{This function returns the processor number of the parent of
\param{procNum} in the spanning tree.}

\function{int CmiNumSpanTreeChildren(int procNum)}
\index{CmiNumSpanTreeChildren}
\desc{Returns the number of children of \param{procNum} in the spanning tree.}

\function{void CmiSpanTreeChildren(int procNum, int *children)}
\index{CmiSpanTreeChildren}
\desc{This function fills the array \param{children} with processor
numbers of children of \param{procNum} in the spanning tree.}

