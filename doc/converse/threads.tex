\chapter{Threads}

The calls in this chapter can be used to put together runtime systems
for languages that support threads.

To use the threads package, you must include {\tt converse.h} and link
with the converse library.  Note: threads are not implemented on all
hardware platforms.  Although a program that calls thread-functions
will {em link} on all platforms, it won't necessarily {\tt execute}.
Attempting to initialize the threads package on a machine that does
not support threads will result in an error message.

This threads package, like most thread packages, provides a function
for creating threads, one for destroying threads, one for explicitly
transferring control to another thread, and one for retrieving the
currently-executing thread.  Note that these functions do not include
any intelligent strategy for choosing which thread executes when: in
other words, they provide no scheduler.

However, though the threads package does not provide an actual
scheduler, it does assume that the user is going to need one.
Therefore, it defines an interface to which all schedulers can comply.
This makes it possible for users to write blocking code (eg, locks,
barriers, etc) without knowing exactly how the scheduler will work.
The scheduler interface consists of an awaken function and a suspend
function, provided by whomever implements the scheduler.  The awaken
function is called by the thread user to notify the scheduler that a
particular thread wants the CPU.  The scheduler is expected to respond
to this by inserting the thread into a ready-queue or something
similar.  The suspend function tells the scheduler that the current
thread no longer wants the CPU, whereupon the scheduler must choose
another thread to execute instead.  No stipulation is made about how
the scheduler chooses the thread to execute next, except that the
thread must want the CPU. (Eg, somebody must have declared that the
thread wants the CPU using the awaken-function.)

The threads-package makes it possible to associate private data
with a thread.  To this end, we provide functions for storing and
retrieving arbitrary user data in the thread-object.

Finally, as a convenience to converse users, we provide a function
that causes a thread to be automatically scheduled by the converse
scheduler {\tt CsdScheduler}.

\function{int CthImplemented()}
\index{CthImplemented}
\desc{Returns true if the current hardware platform supports the threads
functions described below.}

\function{typedef struct CthThreadStruct *CthThread;}
\index{CthThread}
\desc{This is an opaque type defined in {\tt converse.h}.  It represents
a first-class thread object.  No information is publicized about the
contents of a CthThreadStruct.}

\function{typedef void (CthVoidFn)();}
\index{CthVoidFn}
\desc{This is a type defined in {\tt threads.h}.  It represents
a function that returns nothing.}

\function{typedef CthThread (CthThFn)();}
\index{CthThFn}
\desc{This is a type defined in {\tt threads.h}.  It represents
a function that returns a CthThread.}

\function{void CthInit()}
\index{CthInit}
\desc{Caution: you must call either {\tt ConverseInit} {\tt or} {\tt
CthInit} before calling any of the thread functions described below,
but you must {\tt not} call both.}

\function{CthThread CthSelf()}
\index{CthSelf}
\desc{Returns the currently-executing thread.  Note: even the initial
flow of control that inherently existed when the program began
executing {\tt main} counts as a thread.  You may retrieve that thread
object using {\tt CthSelf} and use it like any other.}

\function{void CthResume(CthThread t)}
\index{CthResume}
\desc{Immediately transfers control to thread {\tt t}.  Note:
normally, the user of a thread package wouldn't explicitly choose
which thread to transfer to.  Instead, the user would rely upon a
scheduler to choose the next thread.  Therefore, this routine is
primarily intended for people who are implementing schedulers, not for
end-users.  End-users should probably call {\tt CthSuspend} or {\tt
CthAwaken} (see below).  Likewise, programmers implementing locks,
barriers, and other synchronization devices should also probably
rely on {\tt CthSuspend} and {\tt CthAwaken}.}

\function{CthThread CthCreate(CthVoidFn fn, void *arg, int size)}
\index{CthCreate}
\desc{Creates a new thread object.  The thread is not given control
yet.  The thread is not passed to any scheduler.  When (and if) the
thread eventually receives control, it will begin executing the
specified function {\tt fn} with the specified argument.  The {\tt size}
parameter specifies the stack size in bytes, 0 means use the default
size.

Caution: almost all threads are created with CthCreate, but not all.
In particular, the one initial thread of control that came into
existence when your program was first {\tt exec}'d was not created
with {\tt CthCreate}, but it can be retrieved (say, by calling {\tt
CthSelf} in {\tt main}), and it can be used like any other {\tt
CthThread}.}

\function{void CthFree(CthThread t)}
\index{CthFree}
\desc{Frees thread {\tt t}.  You may ONLY free the
currently-executing thread (yes, this sounds strange, it's
historical).  Naturally, the free will actually be postponed until the
thread suspends.  This is how a thread terminates itself: it calls
{\tt CthFree(CthSelf())}, then gives up control to another thread.}

\function{void CthSuspend()}
\index{CthSuspend}
\desc{This is part of the scheduler-interface.  When a scheduler is
being used, threads should call {\tt CthSuspend} when they wish to
give up control of the CPU.  {\tt CthSuspend} will then automatically
transfer control to some other thread that wants the CPU.  {\tt
CthSuspend} will select the thread to transfer control to by calling a
user-supplied ``choose-next'' function (see {\tt CthSetStrategy}
below).}

\function{void CthAwaken(CthThread t)}
\index{CthAwaken}
\desc{This is part of the scheduler-interface.  When a scheduler is
being used, this function should be used to notify the scheduler that
thread {\tt t} wants the CPU.  This will enable the scheduler to
select thread {\tt t} for execution at some point in the future.
In actuality, {\tt CthAwaken} simply calls the user-supplied ``awaken''
function (see {\tt CthSetStrategy} below).  It is illegal to call
{\tt CthAwaken} on a thread which has already been awakened, unless
the thread has been scheduled since the last awaken.}

\function{void CthSetStrategy(CthThread t, CthVoidFn awakenfn, CthThFn choosefn)}
\index{CthSetStrategy}
\desc{This is part of the scheduler-interface.  It should be used by
the creator of thread {\tt t} to specify the scheduling functions to
be used for thread {\tt t}.  The scheduling functions must have the
following prototypes:
\begin{itemize}

\item{{\tt void awakenfn(CthThread t);}}

\item{{\tt CthThread choosefn();}}

\end{itemize}
These functions must be provided on a per-thread basis.  (Eg, if you
{\tt CthAwaken} a thread {\tt X}, then {\tt X}'s {\tt awakenfn} will
be called.  If a thread {\tt Y} calls {\tt CthSuspend}, then thread
{\tt Y}'s {\tt choosefn} will be called to pick the next thread.)  Of
course, you may use the same functions for all threads (the common
case), but the specification on a per-thread basis gives you maximum
flexibility in controlling scheduling.

A final caution about the {\tt choosefn}: it may only return a thread
that wants the CPU, eg, a thread that has been awakened using the {\tt
awakefn}.  If no such thread exists, if the {\tt choosefn} cannot
return an awakened thread, then it must not return at all: instead, it
must wait until, by means of some pending IO event, a thread becomes
awakened (pending events could be asynchonous disk reads, networked
message receptions, signal handlers, etc).  For this reason, many
schedulers perform the task of polling the IO devices as a side
effect.  If handling the IO event causes a thread to be awakened, then
the choosefn may return that thread.  If no pending events exist, then
all threads will remain permanently blocked, the program is therefore
done, and the {\tt choosefn} should call {\tt exit}.

There is one minor exception to the rule stated above (``the scheduler
may not resume a thread unless it has been declared that the thread
wants the CPU using the {\tt awakefn}'').  If a thread {\tt t} is
part of the scheduling module, it is permitted for the scheduling
module to resume {\tt t} whenever it so desires: presumably, the
scheduling module knows when its threads want the CPU.}

\function{void CthYield()}
\index{CthYield}
\desc{This function is part of the scheduler-interface.  It simply
executes {\tt \{ CthAwaken(CthSelf()); CthSuspend(); \} }.  This combination
gives up control temporarily, but ensures that control will eventually
return.}

\internal{
\function{void CthSetVar(CthThread t, void **var, void *val)}
\desc{Specifies that the global variable pointed to by {\tt
var} should be set to value {\tt val} whenever thread {\tt t} is
executing.  {\tt var} should be of type {\tt void *}, or at least
should be coercible to a {\tt void *}.  This can be used to associate
thread-private data with thread {\tt t}.

it is intended that this function be used as follows:}

\begin{verbatim}
    /* User defines a struct th_info containing all the thread-private  */
    /* data he wishes to associate with threads.  He also defines       */
    /* a global variable 'current_thread_info' which will always hold   */
    /* the th_info of the currently-executing thread.                   */
    struct th_info { ... } *current_thread_info;

    /* User creates a thread 't', and allocates a block of memory       */
    /* 'tinfo' to hold the thread's private data.  User tells the       */
    /* system that whenever thread 't' is running, the global variable  */
    /* 'current_thread_info' should be set to 'tinfo'.  Thus, thread    */
    /* 't' can access its private data just by dereferencing            */
    /* 'current_thread_info'.                                           */
    t = CthCreate( ... );
    tinfo = (struct th_info *)malloc(sizeof(struct th_info));
    CthSetVar(t, &current_thread_info, tinfo);
\end{verbatim}

\desc{Note: you can use CthSetVar multiple times on a thread, thereby
attaching multiple data items to it.  However, each data item slows
down context-switch to that thread by a tiny amount.  Therefore, a
module should ideally attach no more than one data item to a thread.
We allow multiple data items to be attached so that independent
modules can attach data to a thread without interfering with each
other.}

\function{void *CthGetVar(CthThread t, void **var)}
\desc{This makes it possible to retrieve values previously stored with
{\tt CthSetVar} when {\tt t} is {\it not} executing.  Returns the value
that {\tt var} will be set to when {\tt t} is running.}
}

\function{void CthSetStrategyDefault(CthThread t)}
\index{CthSetStrategyDefault}
\desc{This the simple scheduler provided to converse users as a
convenience.  Calling this function on a thread {\tt t} causes thread
{\tt t} to be scheduled by the built-in converse scheduler {\tt
CsdScheduler}.  Awakening thread {\tt t} will cause it to be inserted
into the {\tt CsdScheduler} queue, and it will then be resumed when it
gets to the head of the queue.  If it then suspends, it will return
control to the thread running the {\tt CsdScheduler}.}

