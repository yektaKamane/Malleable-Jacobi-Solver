module selfCompute {

  // Include md_config.h on the accelerator (for physics constants)
  accelblock { #include "md_config.h" };

  array[3D] SelfCompute {

    entry SelfCompute();

    entry void init(int numParticlesPerPatch);

    entry void patchData(int numParticles,
                         float particleX[numParticles],
                         float particleY[numParticles],
                         float particleZ[numParticles],
                         float particleQ[numParticles]
                        );

    entry [accel] void doCalc()[
                                 readonly : int numParticles <impl_obj->numParticles>,
                                 readonly : int thisIndex_x <impl_obj->thisIndex.x>,
                                 readonly : int thisIndex_y <impl_obj->thisIndex.y>,
                                 readonly : float particleX[numParticles] <impl_obj->particleX>,
                                 readonly : float particleY[numParticles] <impl_obj->particleY>,
                                 readonly : float particleZ[numParticles] <impl_obj->particleZ>,
                                 readonly : float particleQ[numParticles] <impl_obj->particleQ>,
                                writeonly : float f0_x[numParticles] <impl_obj->forceX>,
                                writeonly : float f0_y[numParticles] <impl_obj->forceY>,
                                writeonly : float f0_z[numParticles] <impl_obj->forceZ>,
                                writeonly : unsigned int localFlopCount <impl_obj->localFlopCount>
                               ] {

      // DMK - DEBUG
      #if (ENABLE_USER_EVENTS != 0) && defined(CMK_CELL) && (CMK_CELL == 0)
        double __start_time__ = CmiWallTimer();
      #endif

      // Calculate the electrostatic force (coulumb's law) between the particles
      //   F = (k_e * (q_0 * q_1)) / (r^2)

      // DMK - DEBUG
      #if COUNT_FLOPS != 0
        localFlopCount = 0;
      #endif

      register vecf* p0_x_vec = (vecf*)particleX;
      register vecf* p0_y_vec = (vecf*)particleY;
      register vecf* p0_z_vec = (vecf*)particleZ;
      register vecf* p0_q_vec = (vecf*)particleQ;
      register vecf* f0_x_vec = (vecf*)f0_x;
      register vecf* f0_y_vec = (vecf*)f0_y;
      register vecf* f0_z_vec = (vecf*)f0_z;
      register int i;
      register int j;
      register const int numParticlesByVecSize = numParticles / vecf_numElems;

      // Zero out the force output
      vecf zero_vec = vspreadf(0.0f);
      for (j = 0; j < numParticlesByVecSize; j++) {
        f0_x_vec[j] = zero_vec;
        f0_y_vec[j] = zero_vec;
        f0_z_vec[j] = zero_vec;
      }

      // Spread coulumb's constant across a vector
      vecf coulomb_vec = vspreadf(COULOMBS_CONSTANT);

      // Outer-loop
      for (i = 0; i < numParticles; i++) {

        // Interact with all particles (one-by-one) until the vector boundary
        for (j = i + 1; ((j & 0x3) != 0x0) && (j < numParticles); j++) {

          float p_x_diff = particleX[i] - particleX[j];
          float p_y_diff = particleY[i] - particleY[j];
          float p_z_diff = particleZ[i] - particleZ[j];
          float r_2 = (p_x_diff * p_x_diff) + (p_y_diff * p_y_diff) + (p_z_diff * p_z_diff);
          float r = sqrt(r_2);

          float p_x_diff_norm = p_x_diff / r;
          float p_y_diff_norm = p_y_diff / r;
          float p_z_diff_norm = p_z_diff / r;

          float p_q_prod = particleQ[i] * particleQ[j];
          float f_mag = COULOMBS_CONSTANT * (p_q_prod / r_2);

          float f_x = f_mag * p_x_diff_norm;
          float f_y = f_mag * p_y_diff_norm;
          float f_z = f_mag * p_z_diff_norm;

          f0_x[i] += f_x;
          f0_y[i] += f_y;
          f0_z[i] += f_z;
          f0_x[j] -= f_x;
          f0_y[j] -= f_y;
          f0_z[j] -= f_z;

          // DMK - DEBUG
          #if COUNT_FLOPS != 0
            localFlopCount += 26;
          #endif
        }

        // Spread this particle's (p0[i]) values out over vectors
        vecf p0_x_i_vec = vspreadf(particleX[i]);
        vecf p0_y_i_vec = vspreadf(particleY[i]);
        vecf p0_z_i_vec = vspreadf(particleZ[i]);
        vecf p0_q_i_vec = vspreadf(particleQ[i]);
        vecf f0_x_i_vec = vspreadf(0.0f);
        vecf f0_y_i_vec = vspreadf(0.0f);
        vecf f0_z_i_vec = vspreadf(0.0f);

        // Switch to vectorized loop for the remaining elements in the particle array
        for (j = j >> 2; j < numParticlesByVecSize; j++) {

          // Load the particles' data
          vecf p0_x_j_vec = p0_x_vec[j];
          vecf p0_y_j_vec = p0_y_vec[j];
          vecf p0_z_j_vec = p0_z_vec[j];
          vecf p0_q_j_vec = p0_q_vec[j];

          // Calculate the vector between the particles
          vecf p_x_diff_vec = p0_x_i_vec - p0_x_j_vec;
          vecf p_y_diff_vec = p0_y_i_vec - p0_y_j_vec;
          vecf p_z_diff_vec = p0_z_i_vec - p0_z_j_vec;

          // Calculate r and r^2 between the particles
          vecf r_2_vec = (p_x_diff_vec * p_x_diff_vec) + (p_y_diff_vec * p_y_diff_vec) + (p_z_diff_vec * p_z_diff_vec);
          vecf r_vec = vsqrtf(r_2_vec);

          // Normalize the vector between the particles
          vecf r_recip_vec = vrecipf(r_vec);
          vecf r_2_recip_vec = vrecipf(r_2_vec);
          vecf p_x_diff_norm_vec = p_x_diff_vec * r_recip_vec;
          vecf p_y_diff_norm_vec = p_y_diff_vec * r_recip_vec;
          vecf p_z_diff_norm_vec = p_z_diff_vec * r_recip_vec;
          vecf f_mag_vec = coulomb_vec * p0_q_i_vec * p0_q_j_vec * r_2_recip_vec;  // Calc force magnitude

          // Multiply the magnitude by the normalized postition difference vector to
          //   create the force vector
          vecf f_x_vec = p_x_diff_norm_vec * f_mag_vec;
          vecf f_y_vec = p_y_diff_norm_vec * f_mag_vec;
          vecf f_z_vec = p_z_diff_norm_vec * f_mag_vec;

          // Add the force to the outer-loop particle and subtract it from the inner-loop particles
          f0_x_i_vec += f_x_vec;
          f0_y_i_vec += f_y_vec;
          f0_z_i_vec += f_z_vec;
          f0_x_vec[j] -= f_x_vec;
          f0_y_vec[j] -= f_y_vec;
          f0_z_vec[j] -= f_z_vec;

          // DMK - DEBUG
          #if COUNT_FLOPS != 0
            localFlopCount += (31 * 4);
          #endif
        }

        // Add force values for p0[i] into f0
        f0_x[i] += vextractf(f0_x_i_vec, 0) + vextractf(f0_x_i_vec, 1) + vextractf(f0_x_i_vec, 2) + vextractf(f0_x_i_vec, 3);
        f0_y[i] += vextractf(f0_y_i_vec, 0) + vextractf(f0_y_i_vec, 1) + vextractf(f0_y_i_vec, 2) + vextractf(f0_y_i_vec, 3);
        f0_z[i] += vextractf(f0_z_i_vec, 0) + vextractf(f0_z_i_vec, 1) + vextractf(f0_z_i_vec, 2) + vextractf(f0_z_i_vec, 3);
      }

      // DMK - DEBUG
      #if (ENABLE_USER_EVENTS != 0) && defined(CMK_CELL) && (CMK_CELL == 0)
        double __end_time__ = CmiWallTimer();
        traceUserBracketEvent(PROJ_USER_EVENT_SELFCOMPUTE_DOCALC_WORK, __start_time__, __end_time__);
      #endif

    } doCalc_callback;

  };

};
