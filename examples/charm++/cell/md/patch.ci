module patch {

  accelblock { #include "md_config.h" };

  accelblock {

    void accumForce(int numParticles,
                    float* forceSumX, float* forceSumY, float* forceSumZ,
                    float* forceX, float* forceY, float* forceZ
                   ) {
      register vecf* fsx = (vecf*)forceSumX;
      register vecf* fsy = (vecf*)forceSumY;
      register vecf* fsz = (vecf*)forceSumZ;
      register vecf* fx = (vecf*)forceX;
      register vecf* fy = (vecf*)forceY;
      register vecf* fz = (vecf*)forceZ;
      register const int numParticles_vec = numParticles / vecf_numElems;
      register int i;
      for (i = 0; i < numParticles_vec; i++) {
        fsx[i] = vaddf(fsx[i], fx[i]);
        fsy[i] = vaddf(fsy[i], fy[i]);
        fsz[i] = vaddf(fsz[i], fz[i]);
      }
    }
  };

  group ProxyPatch {

    entry ProxyPatch(int patchIndex);

    entry void init(int numParticles);

    entry void patchData(int numParticles,
                         float particleX[numParticles],
                         float particleY[numParticles],
                         float particleZ[numParticles],
                         float particleQ[numParticles]
                        );

    entry void forceCheckIn(int numParticles,
                            float forceX[numParticles],
                            float forceY[numParticles],
                            float forceZ[numParticles]
                           );
  };

  array[3D] Patch {

    entry Patch();

    entry void init(int numParticles);
    entry void init(int numParticles, CProxy_ProxyPatch proxyPatchProxy);

    entry void startIteration();
    entry void startIterations(int numIters);

    entry void forceCheckIn(int numParticles,
                            float forceX[numParticles],
                            float forceY[numParticles],
                            float forceZ[numParticles]
                           );
    entry void forceCheckIn(int numParticles,
                            float forceX[numParticles],
                            float forceY[numParticles],
                            float forceZ[numParticles],
                            int numForceCheckIns
                           );

    entry [accel] void integrate()[ readonly : int numParticles <impl_obj->numParticles>,
                                    readonly : int thisIndex_x <impl_obj->thisIndex.x>,
                                    readonly : int thisIndex_y <impl_obj->thisIndex.y>,
                                    readonly : int thisIndex_z <impl_obj->thisIndex.z>,
                                   readwrite : float p_x[numParticles] <impl_obj->particleX>,
                                   readwrite : float p_y[numParticles] <impl_obj->particleY>,
                                   readwrite : float p_z[numParticles] <impl_obj->particleZ>,
                                    readonly : float p_m[numParticles] <impl_obj->particleM>,
                                    readonly : float f_x[numParticles] <impl_obj->forceSumX>,
                                    readonly : float f_y[numParticles] <impl_obj->forceSumY>,
                                    readonly : float f_z[numParticles] <impl_obj->forceSumZ>,
                                   readwrite : float v_x[numParticles] <impl_obj->velocityX>,
                                   readwrite : float v_y[numParticles] <impl_obj->velocityY>,
                                   readwrite : float v_z[numParticles] <impl_obj->velocityZ>,
                                   writeonly : unsigned int localFlopCount <impl_obj->localFlopCount>
                                  ] {

      // DMK - DEBUG
      #if COUNT_FLOPS != 0
        localFlopCount = 0;
      #endif

      register vecf* p_x_vec = (vecf*)p_x;
      register vecf* p_y_vec = (vecf*)p_y;
      register vecf* p_z_vec = (vecf*)p_z;
      register vecf* p_m_vec = (vecf*)p_m;
      register vecf* f_x_vec = (vecf*)f_x;
      register vecf* f_y_vec = (vecf*)f_y;
      register vecf* f_z_vec = (vecf*)f_z;
      register vecf* v_x_vec = (vecf*)v_x;
      register vecf* v_y_vec = (vecf*)v_y;
      register vecf* v_z_vec = (vecf*)v_z;
      register int i;
      register const int numParticles_vec = numParticles / vecf_numElems;

      vecf delta_time_vec = vspreadf(TIME_PER_STEP);

      // Add the acceleration to the velocity and add the update velocity to the position
      for (i = 0; i < numParticles_vec; i++) {

        // Update the velocity : v_new = v_old + (F/m)dt
        vecf new_v_x_vec = v_x_vec[i] + (delta_time_vec * (f_x_vec[i] / p_m_vec[i]));
        vecf new_v_y_vec = v_y_vec[i] + (delta_time_vec * (f_y_vec[i] / p_m_vec[i]));
        vecf new_v_z_vec = v_z_vec[i] + (delta_time_vec * (f_z_vec[i] / p_m_vec[i]));
        v_x_vec[i] = new_v_x_vec;
        v_y_vec[i] = new_v_y_vec;
        v_z_vec[i] = new_v_z_vec;

        // Update the position : pos_new = pos_old + v_new
        p_x_vec[i] += delta_time_vec * new_v_x_vec;
        p_y_vec[i] += delta_time_vec * new_v_y_vec;
        p_z_vec[i] += delta_time_vec * new_v_z_vec;

        // DMK - DEBUG
        #if COUNT_FLOPS != 0
          localFlopCount += (15 * 4);
        #endif
      }

    } integrate_callback;

  };

};
